{
  "metadata": {
    "source_file": "map-app\\static\\js\\index.5da8ba4c.js",
    "chunk_index": 7,
    "total_chunks": 918,
    "chunk_size": 6714,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:50.143Z"
  },
  "content": "directionColor; // 箭头颜色\\nuniform vec4 outlineColor; // 边界颜色\\nuniform float outlineWidth; // 边界宽度\\n\\nin float v_width; // 线段宽度\\nin float v_polylineAngle; // 线段角度\\n\\nconst float fragLength = 100.0; // 每个箭头线段有多长\\nconst float startPosition = 0.45; // 开始的位置，从 0 ～ 1\\nconst float endPosition = 0.55; // 结束的位置，从 0 ～ 1\\n\\nmat2 rotate(float rad) {\\n float c = cos(rad);\\n float s = sin(rad);\\n return mat2(\\n c, s,\\n -s, c\\n );\\n}\\n\\nfloat getPointOnLine(vec2 p0, vec2 p1, float x)\\n{\\n float slope = (p0.y - p1.y) / (p0.x - p1.x); // 根据两个点获取斜率\\n return slope * (x - p0.x) + p0.y; // 根据斜率和 x 值获取 y 值\\n}\\n\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n{\\n // 用 Dash 的方式渲染正常的线\\n czm_material material = czm_getDefaultMaterial(materialInput);\\n vec2 st = materialInput.st;\\n\\n // copy from polyline outline\\n float halfInteriorWidth = 0.5 * (v_width - outlineWidth) / v_width;\\n float b = step(0.5 - halfInteriorWidth, st.t);\\n b *= 1.0 - step(0.5 + halfInteriorWidth, st.t);\\n\\n // Find the distance from the closest separator (region between two colors)\\n float d1 = abs(st.t - (0.5 - halfInteriorWidth));\\n float d2 = abs(st.t - (0.5 + halfInteriorWidth));\\n float dist = min(d1, d2);\\n\\n vec4 currentColor = mix(outlineColor, color, b);\\n vec4 outColor = czm_antialias(outlineColor, color, currentColor, dist);\\n outColor = czm_gammaCorrect(outColor);\\n\\n // 获取当前位置处于窗口的相对位置（像素值）\\n vec2 pos = rotate(v_polylineAngle) * gl_FragCoord.xy;\\n\\n // 获取当前位置处于箭头线段的哪部分, 0 ~ 1\\n float maskS = fract(pos.x / (fragLength * czm_pixelRatio));\\n// float maskS = fract(st.s / (abs(fwidth(st.s)) * fragLength * czm_pixelRatio));\\n float maskT = st.t;\\n // 判断是正常的线还是箭头\\n bool isDirection = (maskS > startPosition) && (maskS <= endPosition);\\n\\n vec4 fragColor;\\n if (isDirection) {\\n // 渲染箭头\\n float arrowWidth = (endPosition - startPosition) / 2.0;\\n float midS = startPosition + arrowWidth;\\n\\n float t = 1.0;\\n if (maskS < midS) {\\n // 左边的三角形\\n vec2 center = vec2(midS, 0.5);\\n float ptOnUpperLine = getPointOnLine(vec2(startPosition, 1.0), center, maskS); // 三角形上边的线\\n float ptOnLowerLine = getPointOnLine(vec2(startPosition, 0.0), center, maskS); // 三角形下边的线\\n\\n t *= 1.0 - step(ptOnUpperLine, maskT); // 低于上面的线\\n t *= step(ptOnLowerLine, maskT); // 而且高于下面的线\\n t = 1.0 - t; // 取反\\n } else {\\n // 右边的三角形\\n vec2 center = vec2(endPosition, 0.5);\\n float ptOnUpperLine = getPointOnLine(vec2(midS, 1.0), center, maskS); // 三角形上边的线\\n float ptOnLowerLine = getPointOnLine(vec2(midS, 0.0), center, maskS); // 三角形下边的线\\n\\n t *= 1.0 - step(ptOnUpperLine, maskT); // 低于上面的线\\n t *= step(ptOnLowerLine, maskT); // 而且高于下面的线\\n }\\n\\n vec4 outsideColor = outColor;\\n vec4 currentColor = mix(outsideColor, directionColor, clamp(t, 0.0, 1.0));\\n fragColor = currentColor;\\n } else {\\n fragColor = outColor;\\n }\\n\\n fragColor = czm_gammaCorrect(fragColor);\\n material.diffuse = fragColor.rgb;\\n material.alpha = fragColor.a;\\n return material;\\n}\\n\"},translucent:!0});class h4{constructor(e=uf.Color.WHITE,a=0,r=uf.Color.WHITE){this.color=e,this.outlineWidth=a,this.outlineColor=r}color;outlineWidth;outlineColor;definitionChanged=new uf.Event;isConstant=!0;equals(e){return this===e||e instanceof h4&&uf.Color.equals(this.color,e.color)&&this.outlineWidth===e.outlineWidth}getType(e){return h3}getValue(e,a){return!(0,uf.defined)(a)&&(a={}),a.color=this.color,a.outlineWidth=this.outlineWidth,a.outlineColor=this.outlineColor,a}}let h5=\"PolylineCustomEndpoint\";uf.Material._materialCache.addMaterial(h5,{strict:!0,fabric:{type:h5,uniforms:{color:uf.Color.WHITE,startType:sw.normal,endType:sw.normal,outlineColor:uf.Color.WHITE,outlineShow:!1,lineWidth:3},source:\"uniform vec4 color; // 线主体颜色\\nuniform float startType; // 起始点的类型\\nuniform float endType; // 终点的类型\\nuniform vec4 outlineColor; // 边界颜色\\nuniform bool outlineShow;\\nuniform float lineWidth;\\n\\nconst float SHAPE_TYPE_NORMAL = 0.0; // 普通\\nconst float SHAPE_TYPE_ARROW= 1.0; // 箭头\\nconst float SHAPE_TYPE_CIRCLE = 2.0; // 圆\\nconst float SHAPE_TYPE_END = 3.0; // 终止竖线\\n\\nconst float ratio = 2.5; // 线宽和base的比例，测试经验值\\n\\nfloat outlineWidth = 0.005; // 效果比较好的经验值，后面有需要再传入\\n\\nfloat getArrowPointOnLine(vec2 p0, vec2 p1, float x){\\n float slope = (p0.y - p1.y) / (p0.x - p1.x);\\n return slope * (x - p0.x) + p0.y;\\n}\\n\\nfloat getCirclePointOnLine(vec2 center, float radius, float x, float upper) {\\n // 计算 x 到圆心的水平距离的平方\\n float dx = x - center.x;\\n \\n // 在圆方程中求解出 y 变化部\\n float dy = sqrt(radius * radius - dx * dx);\\n\\n dy = dy * 0.5 / radius;\\n \\n // 根据 upper 的值决定上边还是下边\\n if (upper == 1.0) {\\n return center.y + dy; // 上半边\\n } else {\\n return center.y - dy; // 下半边\\n }\\n}\\n\\nczm_material czm_getMaterial(czm_materialInput materialInput)\\n{\\n czm_material material = czm_getDefaultMaterial(materialInput);\\n\\n vec2 st = materialInput.st;\\n\\n #if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives))\\n float base = 1.0 - abs(fwidth(st.s)) * lineWidth * ratio * czm_pixelRatio;\\n #else\\n // If no derivatives available (IE 10?), 2.5% of the line will be the arrow head\\n float base = 0.975;\\n #endif\\n\\n float reverseBase = 1.0 - base;\\n float halfB = reverseBase / 2.0;\\n float baseLeft = reverseBase;\\n\\n if(startType == SHAPE_TYPE_END) {\\n baseLeft = halfB;\\n }\\n\\n if(endType == SHAPE_TYPE_END) {\\n base += halfB;\\n }\\n\\n // 这里用来解决圆形端点的裂缝问题\\n float circleOffset = 0.01 * baseLeft;\\n\\n float halfWidth = 0.08;\\n\\n // 左侧 \\n if(st.s < baseLeft) {\\n\\n if(outlineShow) {\\n halfWidth += outlineWidth;\\n }\\n\\n float ptOnUpperLineLeft = 0.5 + halfWidth;\\n float ptOnLowerLineLeft = 0.5 - halfWidth;\\n\\n if(startType == SHAPE_TYPE_CIRCLE && st.s < baseLeft - circleOffset) {\\n float r = baseLeft / 2.0;\\n vec2 leftCenter = vec2(r, 0.5);\\n\\n ptOnUpperLineLeft = getCirclePointOnLine(leftCenter, r, st.s, 1.0);\\n ptOnLowerLineLeft = getCirclePointOnLine(leftCenter, r, st.s, 0.0);\\n } else if(startType == SHAPE_TYPE_END) {\\n ptOnUpperLineLeft = 1.0;\\n ptOnLowerLineLeft = 0.0;\\n } else if(startType == SHAPE_TYPE_ARROW) {\\n vec2 leftCenter = vec2(0.0, 0.5);\\n ptOnUpperLineLeft = getArrowPointOnLine(vec2(baseLeft, 1.0), leftCenter, st.s);\\n ptOnLowerLineLeft = getArrowPointOnLine(vec2(baseLeft, 0.0), leftCenter, st.s);\\n }\\n\\n float t = 1.0 - step(ptOnUpperLineLeft, st.t);\\n t *= step(ptOnLowerLineLeft, st.t);\\n\\n float d1 = czm_infinity;\\n if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth)\\n {\\n d1 = abs(st.s - baseLeft);\\n }\\n float d2 = abs(st.t - ptOnUpperLineLeft);\\n float d3 = abs(st.t - ptOnLowerLineLeft);\\n float dist = min(min(d1, d2), d3);\\n\\n float dtUpper = abs(st.t - ptOnUpperLineLeft);\\n dtUpper = step(dtUpper, outlineWidth);\\n\\n float dtLower = abs(st.t - ptOnLowerLineLeft);\\n dtLower = step(dtLower, outlineWidth);\\n\\n vec4 contentColor;\\n if(outlineShow)"
}