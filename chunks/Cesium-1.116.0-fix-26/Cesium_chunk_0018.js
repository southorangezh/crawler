{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 18,
    "total_chunks": 194,
    "chunk_size": 4957,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.657Z"
  },
  "content": "color (hue, saturation, brightness) to RGB * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl} * * @name czm_HSBToRGB * @glslFunction * * @param {vec3} hsb The color in HSB. * * @returns {vec3} The color in RGB. * * @example * vec3 hsb = czm_RGBToHSB(rgb); * hsb.z *= 0.1; * rgb = czm_HSBToRGB(hsb); */ const vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 czm_HSBToRGB(vec3 hsb) { vec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www); return hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y); } `;var v2t=T(S(),1),jZ=`/** * Converts an HSL color (hue, saturation, lightness) to RGB * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html} * * @name czm_HSLToRGB * @glslFunction * * @param {vec3} rgb The color in HSL. * * @returns {vec3} The color in RGB. * * @example * vec3 hsl = czm_RGBToHSL(rgb); * hsl.z *= 0.1; * rgb = czm_HSLToRGB(hsl); */ vec3 hueToRGB(float hue) { float r = abs(hue * 6.0 - 3.0) - 1.0; float g = 2.0 - abs(hue * 6.0 - 2.0); float b = 2.0 - abs(hue * 6.0 - 4.0); return clamp(vec3(r, g, b), 0.0, 1.0); } vec3 czm_HSLToRGB(vec3 hsl) { vec3 rgb = hueToRGB(hsl.x); float c = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y; return (rgb - 0.5) * c + hsl.z; } `;var F2t=T(S(),1),qZ=`/** * Converts an RGB color to HSB (hue, saturation, brightness) * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl} * * @name czm_RGBToHSB * @glslFunction * * @param {vec3} rgb The color in RGB. * * @returns {vec3} The color in HSB. * * @example * vec3 hsb = czm_RGBToHSB(rgb); * hsb.z *= 0.1; * rgb = czm_HSBToRGB(hsb); */ const vec4 K_RGB2HSB = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec3 czm_RGBToHSB(vec3 rgb) { vec4 p = mix(vec4(rgb.bg, K_RGB2HSB.wz), vec4(rgb.gb, K_RGB2HSB.xy), step(rgb.b, rgb.g)); vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r)); float d = q.x - min(q.w, q.y); return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + czm_epsilon7)), d / (q.x + czm_epsilon7), q.x); } `;var M2t=T(S(),1),$Z=`/** * Converts an RGB color to HSL (hue, saturation, lightness) * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html} * * @name czm_RGBToHSL * @glslFunction * * @param {vec3} rgb The color in RGB. * * @returns {vec3} The color in HSL. * * @example * vec3 hsl = czm_RGBToHSL(rgb); * hsl.z *= 0.1; * rgb = czm_HSLToRGB(hsl); */ vec3 RGBtoHCV(vec3 rgb) { // Based on work by Sam Hocevar and Emil Persson vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0 / 3.0) : vec4(rgb.gb, 0.0, -1.0 / 3.0); vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx); float c = q.x - min(q.w, q.y); float h = abs((q.w - q.y) / (6.0 * c + czm_epsilon7) + q.z); return vec3(h, c, q.x); } vec3 czm_RGBToHSL(vec3 rgb) { vec3 hcv = RGBtoHCV(rgb); float l = hcv.z - hcv.y * 0.5; float s = hcv.y / (1.0 - abs(l * 2.0 - 1.0) + czm_epsilon7); return vec3(hcv.x, s, l); } `;var k2t=T(S(),1),eR=`/** * Converts an RGB color to CIE Yxy. * <p>The conversion is described in * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform} * </p> * * @name czm_RGBToXYZ * @glslFunction * * @param {vec3} rgb The color in RGB. * * @returns {vec3} The color in CIE Yxy. * * @example * vec3 xyz = czm_RGBToXYZ(rgb); * xyz.x = max(xyz.x - luminanceThreshold, 0.0); * rgb = czm_XYZToRGB(xyz); */ vec3 czm_RGBToXYZ(vec3 rgb) { const mat3 RGB2XYZ = mat3(0.4124, 0.2126, 0.0193, 0.3576, 0.7152, 0.1192, 0.1805, 0.0722, 0.9505); vec3 xyz = RGB2XYZ * rgb; vec3 Yxy; Yxy.r = xyz.g; float temp = dot(vec3(1.0), xyz); Yxy.gb = xyz.rg / temp; return Yxy; } `;var D2t=T(S(),1),tR=`/** * Converts a CIE Yxy color to RGB. * <p>The conversion is described in * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform} * </p> * * @name czm_XYZToRGB * @glslFunction * * @param {vec3} Yxy The color in CIE Yxy. * * @returns {vec3} The color in RGB. * * @example * vec3 xyz = czm_RGBToXYZ(rgb); * xyz.x = max(xyz.x - luminanceThreshold, 0.0); * rgb = czm_XYZToRGB(xyz); */ vec3 czm_XYZToRGB(vec3 Yxy) { const mat3 XYZ2RGB = mat3( 3.2405, -0.9693, 0.0556, -1.5371, 1.8760, -0.2040, -0.4985, 0.0416, 1.0572); vec3 xyz; xyz.r = Yxy.r * Yxy.g / Yxy.b; xyz.g = Yxy.r; xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b; return XYZ2RGB * xyz; } `;var Y2t=T(S(),1),nR=`// See: // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/ vec3 czm_acesTonemapping(vec3 color) { float g = 0.985; float a = 0.065; float b = 0.0001; float c = 0.433; float d = 0.238; color = (color * (color + a) - b) / (color * (g * color + c) + d); color = clamp(color, 0.0, 1.0); return color; } `;var z2t=T(S(),1),iR=`/** * @private */ float czm_alphaWeight(float a) { float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2];"
}