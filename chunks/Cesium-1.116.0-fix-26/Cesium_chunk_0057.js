{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 57,
    "total_chunks": 194,
    "chunk_size": 11520,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.680Z"
  },
  "content": "Float64Array(m*3),_=new Float32Array(p),C=new Float32Array(p),V=new Float32Array(p),L=new Float32Array(p),R=new Float32Array(p),G,X,v,W;s&&(G=new Float32Array(p),X=new Float32Array(p),v=new Float32Array(p),W=new Float32Array(m*2));let F=r.length/2,A=0,y=mie;y.height=0;let Z=hie;Z.height=0;let E=eie,I=XO;if(s)for(c=0,a=1;a<F;a++)y.latitude=r[c],y.longitude=r[c+1],Z.latitude=r[c+2],Z.longitude=r[c+3],E=t.project(y,E),I=t.project(Z,I),A+=h.distance(E,I),c+=2;let w=i.length/3;I=h.unpack(i,0,I);let k=0;for(c=3,a=1;a<w;a++)E=h.clone(I,E),I=h.unpack(i,c,I),k+=h.distance(E,I),c+=3;let B;c=3;let U=0,Y=0,N=0,J=0,z=!1,ee=h.unpack(n,0,nie),H=h.unpack(i,0,XO),j=h.unpack(o,0,iie);if(e){let Re=h.unpack(n,n.length-6,tie);Jne(j,Re,ee,H)&&(j=h.negate(j,j))}let q=0,pe=0,_e=0;for(a=0;a<u;a++){let Re=h.clone(ee,tie),ke=h.clone(H,eie),rt=h.clone(j,U2e);z&&(rt=h.negate(rt,rt)),ee=h.unpack(n,c,nie),H=h.unpack(i,c,XO),j=h.unpack(o,c,iie),z=Jne(j,Re,ee,H),y.latitude=r[U],y.longitude=r[U+1],Z.latitude=r[U+2],Z.longitude=r[U+3];let yt,Dt,it,Ie;if(s){let zi=k2e(y,Z);yt=t.project(y,K2e),Dt=t.project(Z,J2e);let ds=Lp(Dt,yt,rie);ds.y=Math.abs(ds.y),it=IO,Ie=WO,zi===0||h.dot(ds,h.UNIT_Y)>cie?(it=NE(t,y,rt,yt,IO),Ie=NE(t,Z,j,Dt,WO)):zi===1?(Ie=NE(t,Z,j,Dt,WO),it.x=0,it.y=P.sign(y.longitude-Math.abs(Z.longitude)),it.z=0):(it=NE(t,y,rt,yt,IO),Ie.x=0,Ie.y=P.sign(y.longitude-Z.longitude),Ie.z=0)}let ft=h.distance(ke,H),Ke=Yn.fromCartesian(Re,tPe),ct=h.subtract(ee,Re,Q2e),Jt=h.normalize(ct,oie),be=h.subtract(ke,Re,j2e);be=h.normalize(be,be);let Ve=h.cross(Jt,be,oie);Ve=h.normalize(Ve,Ve);let Bt=h.cross(be,rt,$2e);Bt=h.normalize(Bt,Bt);let mt=h.subtract(H,ee,q2e);mt=h.normalize(mt,mt);let Pi=h.cross(j,mt,ePe);Pi=h.normalize(Pi,Pi);let Co=ft/k,Es=q/k,$r=0,Nr,Qs,De,et=0,qe=0;if(s){$r=h.distance(yt,Dt),Nr=Yn.fromCartesian(yt,nPe),Qs=h.subtract(Dt,yt,rie),De=h.normalize(Qs,iPe);let zi=De.x;De.x=De.y,De.y=-zi,et=$r/A,qe=pe/A}for(B=0;B<8;B++){let zi=J+B*4,ds=Y+B*2,es=zi+3,dl=B<4?1:-1,Uo=B===2||B===3||B===6||B===7?1:-1;h.pack(Ke.high,_,zi),_[es]=ct.x,h.pack(Ke.low,C,zi),C[es]=ct.y,h.pack(Bt,V,zi),V[es]=ct.z,h.pack(Pi,L,zi),L[es]=Co*dl,h.pack(Ve,R,zi);let ur=Es*Uo;ur===0&&Uo<0&&(ur=9),R[es]=ur,s&&(G[zi]=Nr.high.x,G[zi+1]=Nr.high.y,G[zi+2]=Nr.low.x,G[zi+3]=Nr.low.y,v[zi]=-it.y,v[zi+1]=it.x,v[zi+2]=Ie.y,v[zi+3]=-Ie.x,X[zi]=Qs.x,X[zi+1]=Qs.y,X[zi+2]=De.x,X[zi+3]=De.y,W[ds]=et*dl,ur=qe*Uo,ur===0&&Uo<0&&(ur=9),W[ds+1]=ur)}let Ye=z2e,gt=H2e,zt=Y2e,Gn=O2e,Vo=le.fromCartographicArray(D2e,B2e),tr=ai.getMinimumMaximumHeights(Vo,d),Da=tr.minimumTerrainHeight,nr=tr.maximumTerrainHeight;_e+=Math.abs(Da),_e+=Math.abs(nr),$ne(Re,ke,Da,nr,Ye,zt),$ne(ee,H,Da,nr,gt,Gn);let ir=h.multiplyByScalar(Ve,P.EPSILON5,sie);h.add(Ye,ir,Ye),h.add(gt,ir,gt),h.add(zt,ir,zt),h.add(Gn,ir,Gn),I5(Ye,gt),I5(zt,Gn),h.pack(Ye,x,N),h.pack(gt,x,N+3),h.pack(Gn,x,N+6),h.pack(zt,x,N+9),ir=h.multiplyByScalar(Ve,-2*P.EPSILON5,sie),h.add(Ye,ir,Ye),h.add(gt,ir,gt),h.add(zt,ir,zt),h.add(Gn,ir,Gn),I5(Ye,gt),I5(zt,Gn),h.pack(Ye,x,N+12),h.pack(gt,x,N+15),h.pack(Gn,x,N+18),h.pack(zt,x,N+21),U+=2,c+=3,Y+=16,N+=24,J+=32,q+=ft,pe+=$r}c=0;let ae=0;for(a=0;a<u;a++){for(B=0;B<aie;B++)f[c+B]=fie[B]+ae;ae+=8,c+=aie}let ye=oPe;ce.fromVertices(n,h.ZERO,3,ye[0]),ce.fromVertices(i,h.ZERO,3,ye[1]);let Te=ce.fromBoundingSpheres(ye);Te.radius+=_e/(u*2);let Le={position:new Ee({componentDatatype:Q.DOUBLE,componentsPerAttribute:3,normalize:!1,values:x}),startHiAndForwardOffsetX:Ab(_),startLoAndForwardOffsetY:Ab(C),startNormalAndForwardOffsetZ:Ab(V),endNormalAndTextureCoordinateNormalizationX:Ab(L),rightNormalAndTextureCoordinateNormalizationY:Ab(R)};return s&&(Le.startHiLo2D=Ab(G),Le.offsetAndRight2D=Ab(X),Le.startEndNormals2D=Ab(v),Le.texcoordNormalization2D=new Ee({componentDatatype:Q.FLOAT,componentsPerAttribute:2,normalize:!1,values:W})),new ut({attributes:Le,indices:f,boundingSphere:Te})}function Ab(e){return new Ee({componentDatatype:Q.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}Mb._projectNormal=NE;var Tx=Mb;var A4t=T(S(),1),kE=`in vec4 v_startPlaneNormalEcAndHalfWidth; in vec4 v_endPlaneNormalEcAndBatchId; in vec4 v_rightPlaneEC; // Technically can compute distance for this here in vec4 v_endEcAndStartEcX; in vec4 v_texcoordNormalizationAndStartEcYZ; // @uranus change \\u65B0\\u589E\\u53D8\\u91CF\\u7528\\u6765\\u8BA1\\u7B97\\u8FB9\\u7F18\\u6297\\u952F\\u9F7F in float v_aa_width; in float v_aa_out; #ifdef PER_INSTANCE_COLOR in vec4 v_color; #endif void main(void) { float logDepthOrDepth = czm_branchFreeTernary(czm_sceneMode == czm_sceneMode2D, gl_FragCoord.z, czm_unpackDepth(texture(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw))); vec3 ecStart = vec3(v_endEcAndStartEcX.w, v_texcoordNormalizationAndStartEcYZ.zw); // Discard for sky if (logDepthOrDepth == 0.0) { #ifdef DEBUG_SHOW_VOLUME out_FragColor = vec4(1.0, 0.0, 0.0, 0.5); return; #else // DEBUG_SHOW_VOLUME discard; #endif // DEBUG_SHOW_VOLUME } vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); eyeCoordinate /= eyeCoordinate.w; float halfMaxWidth = v_startPlaneNormalEcAndHalfWidth.w * czm_metersPerPixel(eyeCoordinate); // Check distance of the eye coordinate against the right-facing plane float widthwiseDistance = czm_planeDistance(v_rightPlaneEC, eyeCoordinate.xyz); // Check eye coordinate against the mitering planes float distanceFromStart = czm_planeDistance(v_startPlaneNormalEcAndHalfWidth.xyz, -dot(ecStart, v_startPlaneNormalEcAndHalfWidth.xyz), eyeCoordinate.xyz); float distanceFromEnd = czm_planeDistance(v_endPlaneNormalEcAndBatchId.xyz, -dot(v_endEcAndStartEcX.xyz, v_endPlaneNormalEcAndBatchId.xyz), eyeCoordinate.xyz); if (abs(widthwiseDistance) > halfMaxWidth || distanceFromStart < 0.0 || distanceFromEnd < 0.0) { #ifdef DEBUG_SHOW_VOLUME out_FragColor = vec4(1.0, 0.0, 0.0, 0.5); return; #else // DEBUG_SHOW_VOLUME discard; #endif // DEBUG_SHOW_VOLUME } // Check distance of the eye coordinate against start and end planes with normals in the right plane. // For computing unskewed lengthwise texture coordinate. // Can also be used for clipping extremely pointy miters, but in practice unnecessary because of miter breaking. // aligned plane: cross the right plane normal with miter plane normal, then cross the result with right again to point it more \"forward\" vec3 alignedPlaneNormal; // start aligned plane alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_startPlaneNormalEcAndHalfWidth.xyz); alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz)); distanceFromStart = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, ecStart), eyeCoordinate.xyz); // end aligned plane alignedPlaneNormal = cross(v_rightPlaneEC.xyz, v_endPlaneNormalEcAndBatchId.xyz); alignedPlaneNormal = normalize(cross(alignedPlaneNormal, v_rightPlaneEC.xyz)); distanceFromEnd = czm_planeDistance(alignedPlaneNormal, -dot(alignedPlaneNormal, v_endEcAndStartEcX.xyz), eyeCoordinate.xyz); // @uranus change start: \\u8FB9\\u7F18\\u6297\\u952F\\u9F7F\\u8BA1\\u7B97\\uFF0C\\u8FB9\\u7F18\\u586B\\u5145 float t = (widthwiseDistance + halfMaxWidth) / (2.0 * halfMaxWidth); // \\u9ED8\\u8BA4\\u7684 t float width_out = v_aa_out * 2.0; // \\u8FB9\\u7F18\\u6297\\u952F\\u9F7F\\u989D\\u5916\\u589E\\u52A0\\u7684\\u5BBD\\u5EA6 float dist = (abs(t - 0.5)) * v_aa_width * 2.0; // t - 0.5 \\u8DDD\\u79BB\\u4E2D\\u5FC3\\u70B9\\u7684\\u4F4D\\u7F6E\\uFF08\\u4E24\\u500D\\u5316\\uFF09 float alpha = clamp((v_aa_width - dist - (1.0 / czm_pixelRatio)) / width_out, 0.0, 1.0); // \\u6297\\u952F\\u9F7F\\u586B\\u5145\\u900F\\u660E\\u5EA6 // @uranus change end #ifdef PER_INSTANCE_COLOR // @uranus change start: \\u8FB9\\u7F18\\u6297\\u952F\\u9F7F\\u900F\\u660E\\u5EA6\\u8BA1\\u7B97 vec4 color = v_color; color.a *= alpha; out_FragColor = czm_gammaCorrect(color); // @uranus change end #else // PER_INSTANCE_COLOR // Clamp - distance to aligned planes may be negative due to mitering, // so fragment texture coordinate might be out-of-bounds. float s = clamp(distanceFromStart / (distanceFromStart + distanceFromEnd), 0.0, 1.0); s = (s * v_texcoordNormalizationAndStartEcYZ.x) + v_texcoordNormalizationAndStartEcYZ.y; // @uranus change start: \\u8FB9\\u7F18\\u6297\\u952F\\u9F7F\\u8BA1\\u7B97\\uFF0C\\u9700\\u8981\\u628A\\u7EB9\\u7406\\u5BBD\\u5EA6\\u7F29\\u5C0F float m_width = v_aa_width - width_out; // \\u5B9E\\u9645\\u7EBF\\u6BB5\\u5BBD\\u5EA6 float tem_t = (t * v_aa_width - v_aa_out) / m_width; // [-1, x - 1] t = clamp(tem_t, 0.0, 1.0); // \\u5B9E\\u9645\\u7EB9\\u7406\\u5BBD\\u5EA6 // @uranus change end czm_materialInput materialInput; materialInput.s = s; materialInput.st = vec2(s, t); materialInput.str = vec3(s, t, 0.0); czm_material material = czm_getMaterial(materialInput); out_FragColor = vec4(material.diffuse + material.emission, material.alpha); // @uranus change: \\u8FB9\\u7F18\\u6297\\u952F\\u9F7F\\u900F\\u660E\\u5EA6\\u8BA1\\u7B97 out_FragColor.a *= alpha; #endif // PER_INSTANCE_COLOR // Premultiply alpha. Required for classification primitives on translucent globe. out_FragColor.rgb *= out_FragColor.a; czm_writeDepthClamp(); } `;var N4t=T(S(),1),UE=`in vec3 v_forwardDirectionEC; in vec3 v_texcoordNormalizationAndHalfWidth; in float v_batchId; #ifdef PER_INSTANCE_COLOR in vec4 v_color; #else in vec2 v_alignedPlaneDistances; in float v_texcoordT; #endif float rayPlaneDistanceUnsafe(vec3 origin, vec3 direction, vec3 planeNormal, float planeDistance) { // We don't expect the ray to ever be parallel to the plane return (-planeDistance - dot(planeNormal, origin)) / dot(planeNormal, direction); } void main(void) { vec4 eyeCoordinate = gl_FragCoord; eyeCoordinate /= eyeCoordinate.w; #ifdef PER_INSTANCE_COLOR out_FragColor = czm_gammaCorrect(v_color); #else // PER_INSTANCE_COLOR // Use distances for planes aligned with segment to prevent skew in dashing float distanceFromStart = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, -v_forwardDirectionEC, v_forwardDirectionEC.xyz, v_alignedPlaneDistances.x); float distanceFromEnd = rayPlaneDistanceUnsafe(eyeCoordinate.xyz, v_forwardDirectionEC, -v_forwardDirectionEC.xyz, v_alignedPlaneDistances.y); // Clamp - distance to aligned planes may be negative due to mitering distanceFromStart = max(0.0, distanceFromStart); distanceFromEnd = max(0.0, distanceFromEnd); float s = distanceFromStart / (distanceFromStart + distanceFromEnd); s = (s * v_texcoordNormalizationAndHalfWidth.x) + v_texcoordNormalizationAndHalfWidth.y; czm_materialInput materialInput; materialInput.s = s; materialInput.st = vec2(s, v_texcoordT); materialInput.str = vec3(s, v_texcoordT, 0.0); czm_material material = czm_getMaterial(materialInput); out_FragColor = vec4(material.diffuse + material.emission, material.alpha); #endif // PER_INSTANCE_COLOR } `;var U4t=T(S(),1),DE=`in vec3 position3DHigh; in vec3 position3DLow; in vec4 startHiAndForwardOffsetX; in vec4 startLoAndForwardOffsetY; in vec4 startNormalAndForwardOffsetZ; in vec4 endNormalAndTextureCoordinateNormalizationX; in vec4 rightNormalAndTextureCoordinateNormalizationY; in vec4 startHiLo2D; in vec4 offsetAndRight2D; in vec4 startEndNormals2D; in vec2 texcoordNormalization2D; in float batchId; out vec3 v_forwardDirectionEC; out vec3 v_texcoordNormalizationAndHalfWidth; out float v_batchId; // For materials #ifdef WIDTH_VARYING out float v_width; #endif #ifdef ANGLE_VARYING out float v_polylineAngle; #endif #ifdef PER_INSTANCE_COLOR out vec4 v_color; #else out vec2 v_alignedPlaneDistances; out float v_texcoordT; #endif // Morphing planes using SLERP or NLERP doesn't seem to work, so instead draw the material directly on the shadow volume. // Morph views are from very far away and aren't meant to be"
}