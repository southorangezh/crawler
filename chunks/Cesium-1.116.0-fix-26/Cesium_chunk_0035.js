{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 35,
    "total_chunks": 194,
    "chunk_size": 5088,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.665Z"
  },
  "content": "(0 intersections). { return czm_emptyRaySegment; } else // qw < 0.0. { float qw2 = qw * qw; float difference = q2 - 1.0; // Positively valued. float w2 = dot(w, w); float product = w2 * difference; if (qw2 < product) // Imaginary roots (0 intersections). { return czm_emptyRaySegment; } else if (qw2 > product) // Distinct roots (2 intersections). { float discriminant = qw * qw - product; float temp = -qw + sqrt(discriminant); // Avoid cancellation. float root0 = temp / w2; float root1 = difference / temp; if (root0 < root1) { czm_raySegment i = czm_raySegment(root0, root1); return i; } else { czm_raySegment i = czm_raySegment(root1, root0); return i; } } else // qw2 == product. Repeated roots (2 intersections). { float root = sqrt(difference / w2); czm_raySegment i = czm_raySegment(root, root); return i; } } } else if (q2 < 1.0) // Inside ellipsoid (2 intersections). { float difference = q2 - 1.0; // Negatively valued. float w2 = dot(w, w); float product = w2 * difference; // Negatively valued. float discriminant = qw * qw - product; float temp = -qw + sqrt(discriminant); // Positively valued. czm_raySegment i = czm_raySegment(0.0, temp / w2); return i; } else // q2 == 1.0. On ellipsoid. { if (qw < 0.0) // Looking inward. { float w2 = dot(w, w); czm_raySegment i = czm_raySegment(0.0, -qw / w2); return i; } else // qw >= 0.0. Looking outward or tangent. { return czm_emptyRaySegment; } } } `;var Qvt=T(S(),1),rG=`/** * Compute the intersection interval of a ray with a sphere. * * @name czm_raySphereIntersectionInterval * @glslFunction * * @param {czm_ray} ray The ray. * @param {vec3} center The center of the sphere. * @param {float} radius The radius of the sphere. * @return {czm_raySegment} The intersection interval of the ray with the sphere. */ czm_raySegment czm_raySphereIntersectionInterval(czm_ray ray, vec3 center, float radius) { vec3 o = ray.origin; vec3 d = ray.direction; vec3 oc = o - center; float a = dot(d, d); float b = 2.0 * dot(d, oc); float c = dot(oc, oc) - (radius * radius); float det = (b * b) - (4.0 * a * c); if (det < 0.0) { return czm_emptyRaySegment; } float sqrtDet = sqrt(det); float t0 = (-b - sqrtDet) / (2.0 * a); float t1 = (-b + sqrtDet) / (2.0 * a); czm_raySegment result = czm_raySegment(t0, t1); return result; } `;var qvt=T(S(),1),sG=`float czm_readDepth(sampler2D depthTexture, vec2 texCoords) { return czm_reverseLogDepth(texture(depthTexture, texCoords).r); } `;var ewt=T(S(),1),aG=`/** * Reads a value previously transformed with {@link czm_writeNonPerspective} * by dividing it by \\`w\\`, the value used in the perspective divide. * This function is intended to be called in a fragment shader to access a * \\`varying\\` that should not be subject to perspective interpolation. * For example, screen-space texture coordinates. The value should have been * previously written in the vertex shader with a call to * {@link czm_writeNonPerspective}. * * @name czm_readNonPerspective * @glslFunction * * @param {float|vec2|vec3|vec4} value The non-perspective value to be read. * @param {float} oneOverW One over the perspective divide value, \\`w\\`. Usually this is simply \\`gl_FragCoord.w\\`. * @returns {float|vec2|vec3|vec4} The usable value. */ float czm_readNonPerspective(float value, float oneOverW) { return value * oneOverW; } vec2 czm_readNonPerspective(vec2 value, float oneOverW) { return value * oneOverW; } vec3 czm_readNonPerspective(vec3 value, float oneOverW) { return value * oneOverW; } vec4 czm_readNonPerspective(vec4 value, float oneOverW) { return value * oneOverW; } `;var nwt=T(S(),1),cG=`float czm_reverseLogDepth(float logZ) { #ifdef LOG_DEPTH float near = czm_currentFrustum.x; float far = czm_currentFrustum.y; float log2Depth = logZ * czm_log2FarDepthFromNearPlusOne; float depthFromNear = pow(2.0, log2Depth) - 1.0; return far * (1.0 - near / (depthFromNear + near)) / (far - near); #endif return logZ; } `;var owt=T(S(),1),lG=`/** * Round a floating point value. This function exists because round() doesn't * exist in GLSL 1.00. * * @param {float|vec2|vec3|vec4} value The value to round * @param {float|vec2|vec3|vec3} The rounded value. The type matches the input. */ float czm_round(float value) { return floor(value + 0.5); } vec2 czm_round(vec2 value) { return floor(value + 0.5); } vec3 czm_round(vec3 value) { return floor(value + 0.5); } vec4 czm_round(vec4 value) { return floor(value + 0.5); } `;var swt=T(S(),1),dG=`/** * Samples the 4 neighboring pixels and return the weighted average. * * @private */ vec3 czm_sampleOctahedralProjectionWithFiltering(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod) { direction /= dot(vec3(1.0), abs(direction)); vec2 rev = abs(direction.zx) - vec2(1.0); vec2 neg = vec2(direction.x < 0.0 ? rev.x : -rev.x, direction.z < 0.0 ? rev.y : -rev.y); vec2 uv = direction.y < 0.0 ? neg : direction.xz; vec2 coord = 0.5 * uv + vec2(0.5); vec2 pixel = 1.0 / textureSize; if (lod > 0.0) { // Each subseqeuent mip level is half the size float scale = 1.0 / pow(2.0, lod); float offset = ((textureSize.y + 1.0) / textureSize.x); coord.x *="
}