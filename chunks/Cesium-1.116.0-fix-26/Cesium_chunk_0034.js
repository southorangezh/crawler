{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 34,
    "total_chunks": 194,
    "chunk_size": 5709,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.665Z"
  },
  "content": "roughness = 1.0 - glossiness; results.roughness = roughness * roughness; results.diffuseColor = diffuse * (1.0 - max(max(specular.r, specular.g), specular.b)); results.f0 = specular; return results; } `;var Dvt=T(S(),1),tG=`float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material) { return czm_getLambertDiffuse(lightDirectionEC, material.normal); } float czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material) { return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess); } /** * Computes a color using the Phong lighting model. * * @name czm_phong * @glslFunction * * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates. * @param {czm_material} material The fragment's material. * * @returns {vec4} The computed color. * * @example * vec3 positionToEyeEC = // ... * czm_material material = // ... * vec3 lightDirectionEC = // ... * out_FragColor = czm_phong(normalize(positionToEyeEC), material, lightDirectionEC); * * @see czm_getMaterial */ vec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC) { // Diffuse from directional light sources at eye (for top-down) float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material); if (czm_sceneMode == czm_sceneMode3D) { // (and horizon views in 3D) diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material); } float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material); // Temporary workaround for adding ambient. vec3 materialDiffuse = material.diffuse * 0.5; vec3 ambient = materialDiffuse; vec3 color = ambient + material.emission; color += materialDiffuse * diffuse * czm_lightColor; color += material.specular * specular * czm_lightColor; return vec4(color, material.alpha); } vec4 czm_private_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC) { float diffuse = czm_private_getLambertDiffuseOfMaterial(lightDirectionEC, material); float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material); vec3 ambient = vec3(0.0); vec3 color = ambient + material.emission; color += material.diffuse * diffuse * czm_lightColor; color += material.specular * specular * czm_lightColor; return vec4(color, material.alpha); } `;var Yvt=T(S(),1),nG=`/** * Computes distance from a point to a plane. * * @name czm_planeDistance * @glslFunction * * param {vec4} plane A Plane in Hessian Normal Form. See Plane.js * param {vec3} point A point in the same space as the plane. * returns {float} The distance from the point to the plane. */ float czm_planeDistance(vec4 plane, vec3 point) { return (dot(plane.xyz, point) + plane.w); } /** * Computes distance from a point to a plane. * * @name czm_planeDistance * @glslFunction * * param {vec3} planeNormal Normal for a plane in Hessian Normal Form. See Plane.js * param {float} planeDistance Distance for a plane in Hessian Normal form. See Plane.js * param {vec3} point A point in the same space as the plane. * returns {float} The distance from the point to the plane. */ float czm_planeDistance(vec3 planeNormal, float planeDistance, vec3 point) { return (dot(planeNormal, point) + planeDistance); } `;var zvt=T(S(),1),iG=`/** * Computes the point along a ray at the given time. <code>time</code> can be positive, negative, or zero. * * @name czm_pointAlongRay * @glslFunction * * @param {czm_ray} ray The ray to compute the point along. * @param {float} time The time along the ray. * * @returns {vec3} The point along the ray at the given time. * * @example * czm_ray ray = czm_ray(vec3(0.0), vec3(1.0, 0.0, 0.0)); // origin, direction * vec3 v = czm_pointAlongRay(ray, 2.0); // (2.0, 0.0, 0.0) */ vec3 czm_pointAlongRay(czm_ray ray, float time) { return ray.origin + (time * ray.direction); } `;var Kvt=T(S(),1),oG=`/** * DOC_TBA * * @name czm_rayEllipsoidIntersectionInterval * @glslFunction */ czm_raySegment czm_rayEllipsoidIntersectionInterval(czm_ray ray, vec3 ellipsoid_center, vec3 ellipsoid_inverseRadii) { // ray and ellipsoid center in eye coordinates. radii in model coordinates. vec3 q = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.origin, 1.0)).xyz; vec3 w = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ray.direction, 0.0)).xyz; q = q - ellipsoid_inverseRadii * (czm_inverseModelView * vec4(ellipsoid_center, 1.0)).xyz; float q2 = dot(q, q); float qw = dot(q, w); if (q2 > 1.0) // Outside ellipsoid. { if (qw >= 0.0) // Looking outward or tangent (0 intersections). { return czm_emptyRaySegment; } else // qw < 0.0. { float qw2 = qw * qw; float difference = q2 - 1.0; // Positively valued. float w2 = dot(w, w); float product = w2 * difference; if (qw2 < product) // Imaginary roots (0 intersections). { return czm_emptyRaySegment; } else if (qw2 > product) // Distinct roots (2 intersections). { float discriminant = qw * qw - product; float temp = -qw + sqrt(discriminant); // Avoid cancellation. float root0 = temp / w2; float root1 = difference / temp; if (root0 < root1) { czm_raySegment i = czm_raySegment(root0, root1); return i; } else { czm_raySegment i = czm_raySegment(root1, root0); return i; } } else // qw2 == product. Repeated roots (2 intersections). { float root = sqrt(difference / w2); czm_raySegment i = czm_raySegment(root, root); return i; } } } else if (q2 < 1.0) // Inside ellipsoid (2 intersections). { float difference = q2 - 1.0; // Negatively valued. float w2 = dot(w, w); float product = w2 * difference; // Negatively valued. float discriminant = qw * qw - product; float temp = -qw + sqrt(discriminant); // Positively valued. czm_raySegment i = czm_raySegment(0.0, temp / w2); return"
}