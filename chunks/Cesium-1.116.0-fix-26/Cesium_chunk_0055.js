{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 55,
    "total_chunks": 194,
    "chunk_size": 25421,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.679Z"
  },
  "content": "&& upOrRightInBounds.x && upOrRightInBounds.y); float useDownOrLeft = float(useUpOrRight == 0.0); vec3 upOrRightEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY + positiveOffset, upOrRightLogDepth); vec3 downOrLeftEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY - positiveOffset, downOrLeftLogDepth); return (upOrRightEC - (eyeCoordinate.xyz / eyeCoordinate.w)) * useUpOrRight + ((eyeCoordinate.xyz / eyeCoordinate.w) - downOrLeftEC) * useDownOrLeft; } #endif // NORMAL_EC void main(void) { #ifdef REQUIRES_EC float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw)); vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); #endif #ifdef REQUIRES_WC vec4 worldCoordinate4 = czm_inverseView * eyeCoordinate; vec3 worldCoordinate = worldCoordinate4.xyz / worldCoordinate4.w; #endif #ifdef TEXTURE_COORDINATES vec2 uv; #ifdef SPHERICAL // Treat world coords as a sphere normal for spherical coordinates vec2 sphericalLatLong = czm_approximateSphericalCoordinates(worldCoordinate); sphericalLatLong.y += v_uvMinAndSphericalLongitudeRotation.z; sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi); uv.x = (sphericalLatLong.y - v_sphericalExtents.y) * v_sphericalExtents.w; uv.y = (sphericalLatLong.x - v_sphericalExtents.x) * v_sphericalExtents.z; #else // SPHERICAL // Unpack planes and transform to eye space uv.x = czm_planeDistance(v_westPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.x; uv.y = czm_planeDistance(v_southPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.y; #endif // SPHERICAL #endif // TEXTURE_COORDINATES #ifdef PICK #ifdef CULL_FRAGMENTS // When classifying translucent geometry, logDepthOrDepth == 0.0 // indicates a region that should not be classified, possibly due to there // being opaque pixels there in another buffer. // Check for logDepthOrDepth != 0.0 to make sure this should be classified. if (0.0 <= uv.x && uv.x <= 1.0 && 0.0 <= uv.y && uv.y <= 1.0 || logDepthOrDepth != 0.0) { out_FragColor.a = 1.0; // 0.0 alpha leads to discard from ShaderSource.createPickFragmentShaderSource czm_writeDepthClamp(); } #else // CULL_FRAGMENTS out_FragColor.a = 1.0; #endif // CULL_FRAGMENTS #else // PICK #ifdef CULL_FRAGMENTS // When classifying translucent geometry, logDepthOrDepth == 0.0 // indicates a region that should not be classified, possibly due to there // being opaque pixels there in another buffer. if (uv.x <= 0.0 || 1.0 <= uv.x || uv.y <= 0.0 || 1.0 <= uv.y || logDepthOrDepth == 0.0) { discard; } #endif #ifdef NORMAL_EC // Compute normal by sampling adjacent pixels in 2x2 block in screen space vec3 downUp = vectorFromOffset(eyeCoordinate, vec2(0.0, 1.0)); vec3 leftRight = vectorFromOffset(eyeCoordinate, vec2(1.0, 0.0)); vec3 normalEC = normalize(cross(leftRight, downUp)); #endif #ifdef PER_INSTANCE_COLOR vec4 color = czm_gammaCorrect(v_color); #ifdef FLAT out_FragColor = color; #else // FLAT czm_materialInput materialInput; materialInput.normalEC = normalEC; materialInput.positionToEyeEC = -eyeCoordinate.xyz; czm_material material = czm_getDefaultMaterial(materialInput); material.diffuse = color.rgb; material.alpha = color.a; out_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC); #endif // FLAT // Premultiply alpha. Required for classification primitives on translucent globe. out_FragColor.rgb *= out_FragColor.a; #else // PER_INSTANCE_COLOR // Material support. // USES_ is distinct from REQUIRES_, because some things are dependencies of each other or // dependencies for culling but might not actually be used by the material. czm_materialInput materialInput; #ifdef USES_NORMAL_EC materialInput.normalEC = normalEC; #endif #ifdef USES_POSITION_TO_EYE_EC materialInput.positionToEyeEC = -eyeCoordinate.xyz; #endif #ifdef USES_TANGENT_TO_EYE materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(worldCoordinate, normalEC); #endif #ifdef USES_ST // Remap texture coordinates from computed (approximately aligned with cartographic space) to the desired // texture coordinate system, which typically forms a tight oriented bounding box around the geometry. // Shader is provided a set of reference points for remapping. materialInput.st.x = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_uMaxAndInverseDistance.xy, uv) * v_uMaxAndInverseDistance.z; materialInput.st.y = czm_lineDistance(v_uvMinAndSphericalLongitudeRotation.xy, v_vMaxAndInverseDistance.xy, uv) * v_vMaxAndInverseDistance.z; #endif czm_material material = czm_getMaterial(materialInput); #ifdef FLAT out_FragColor = vec4(material.diffuse + material.emission, material.alpha); #else // FLAT out_FragColor = czm_phong(normalize(-eyeCoordinate.xyz), material, czm_lightDirectionEC); #endif // FLAT // Premultiply alpha. Required for classification primitives on translucent globe. out_FragColor.rgb *= out_FragColor.a; #endif // PER_INSTANCE_COLOR czm_writeDepthClamp(); #endif // PICK } `;function uu(e,t,n){this._projectionExtentDefines={eastMostYhighDefine:\"\",eastMostYlowDefine:\"\",westMostYhighDefine:\"\",westMostYlowDefine:\"\"};let i=new xO;i.requiresTextureCoordinates=e,i.requiresEC=!n.flat;let o=new xO;if(o.requiresTextureCoordinates=e,n instanceof ln)i.requiresNormalEC=!n.flat;else{let r=`${n.material.shaderSource} ${n.fragmentShaderSource}`;i.normalEC=r.indexOf(\"materialInput.normalEC\")!==-1||r.indexOf(\"czm_getDefaultMaterial\")!==-1,i.positionToEyeEC=r.indexOf(\"materialInput.positionToEyeEC\")!==-1,i.tangentToEyeMatrix=r.indexOf(\"materialInput.tangentToEyeMatrix\")!==-1,i.st=r.indexOf(\"materialInput.st\")!==-1}this._colorShaderDependencies=i,this._pickShaderDependencies=o,this._appearance=n,this._extentsCulling=e,this._planarExtents=t}uu.prototype.createFragmentShader=function(e){let t=this._appearance,n=this._colorShaderDependencies,i=[];!e&&!this._planarExtents&&i.push(\"SPHERICAL\"),n.requiresEC&&i.push(\"REQUIRES_EC\"),n.requiresWC&&i.push(\"REQUIRES_WC\"),n.requiresTextureCoordinates&&i.push(\"TEXTURE_COORDINATES\"),this._extentsCulling&&i.push(\"CULL_FRAGMENTS\"),n.requiresNormalEC&&i.push(\"NORMAL_EC\"),t instanceof ln&&i.push(\"PER_INSTANCE_COLOR\"),n.normalEC&&i.push(\"USES_NORMAL_EC\"),n.positionToEyeEC&&i.push(\"USES_POSITION_TO_EYE_EC\"),n.tangentToEyeMatrix&&i.push(\"USES_TANGENT_TO_EYE\"),n.st&&i.push(\"USES_ST\"),t.flat&&i.push(\"FLAT\");let o=\"\";return t instanceof ln||(o=t.material.shaderSource),new Ue({defines:i,sources:[o,jS]})};uu.prototype.createPickFragmentShader=function(e){let t=this._pickShaderDependencies,n=[\"PICK\"];return!e&&!this._planarExtents&&n.push(\"SPHERICAL\"),t.requiresEC&&n.push(\"REQUIRES_EC\"),t.requiresWC&&n.push(\"REQUIRES_WC\"),t.requiresTextureCoordinates&&n.push(\"TEXTURE_COORDINATES\"),this._extentsCulling&&n.push(\"CULL_FRAGMENTS\"),new Ue({defines:n,sources:[jS],pickColorQualifier:\"in\"})};uu.prototype.createVertexShader=function(e,t,n,i){return Gne(this._colorShaderDependencies,this._planarExtents,n,e,t,this._appearance,i,this._projectionExtentDefines)};uu.prototype.createPickVertexShader=function(e,t,n,i){return Gne(this._pickShaderDependencies,this._planarExtents,n,e,t,void 0,i,this._projectionExtentDefines)};var Tne=new h,Sne=new he,Cne={high:0,low:0};function Gne(e,t,n,i,o,r,s,a){let c=i.slice();if(a.eastMostYhighDefine===\"\"){let d=Sne;d.longitude=P.PI,d.latitude=0,d.height=0;let u=s.project(d,Tne),m=Yn.encode(u.x,Cne);a.eastMostYhighDefine=`EAST_MOST_X_HIGH ${m.high.toFixed(`${m.high}`.length+1)}`,a.eastMostYlowDefine=`EAST_MOST_X_LOW ${m.low.toFixed(`${m.low}`.length+1)}`;let p=Sne;p.longitude=-P.PI,p.latitude=0,p.height=0;let b=s.project(p,Tne);m=Yn.encode(b.x,Cne),a.westMostYhighDefine=`WEST_MOST_X_HIGH ${m.high.toFixed(`${m.high}`.length+1)}`,a.westMostYlowDefine=`WEST_MOST_X_LOW ${m.low.toFixed(`${m.low}`.length+1)}`}return n&&(c.push(a.eastMostYhighDefine),c.push(a.eastMostYlowDefine),c.push(a.westMostYhighDefine),c.push(a.westMostYlowDefine)),l(r)&&r instanceof ln&&c.push(\"PER_INSTANCE_COLOR\"),e.requiresTextureCoordinates&&(c.push(\"TEXTURE_COORDINATES\"),t||n||c.push(\"SPHERICAL\"),n&&c.push(\"COLUMBUS_VIEW_2D\")),new Ue({defines:c,sources:[o]})}function xO(){this._requiresEC=!1,this._requiresWC=!1,this._requiresNormalEC=!1,this._requiresTextureCoordinates=!1,this._usesNormalEC=!1,this._usesPositionToEyeEC=!1,this._usesTangentToEyeMat=!1,this._usesSt=!1}Object.defineProperties(xO.prototype,{requiresEC:{get:function(){return this._requiresEC},set:function(e){this._requiresEC=e||this._requiresEC}},requiresWC:{get:function(){return this._requiresWC},set:function(e){this._requiresWC=e||this._requiresWC,this.requiresEC=this._requiresWC}},requiresNormalEC:{get:function(){return this._requiresNormalEC},set:function(e){this._requiresNormalEC=e||this._requiresNormalEC,this.requiresEC=this._requiresNormalEC}},requiresTextureCoordinates:{get:function(){return this._requiresTextureCoordinates},set:function(e){this._requiresTextureCoordinates=e||this._requiresTextureCoordinates,this.requiresWC=this._requiresTextureCoordinates}},normalEC:{set:function(e){this.requiresNormalEC=e,this._usesNormalEC=e},get:function(){return this._usesNormalEC}},tangentToEyeMatrix:{set:function(e){this.requiresWC=e,this.requiresNormalEC=e,this._usesTangentToEyeMat=e},get:function(){return this._usesTangentToEyeMat}},positionToEyeEC:{set:function(e){this.requiresEC=e,this._usesPositionToEyeEC=e},get:function(){return this._usesPositionToEyeEC}},st:{set:function(e){this.requiresTextureCoordinates=e,this._usesSt=e},get:function(){return this._usesSt}}});function Vne(e,t,n){return Math.abs((t.y-e.y)*n.x-(t.x-e.x)*n.y+t.x*e.y-t.y*e.x)/D.distance(t,e)}var XWe=[new D,new D,new D,new D];function Ene(e,t){let n=XWe,i=D.unpack(t,0,n[0]),o=D.unpack(t,2,n[1]),r=D.unpack(t,4,n[2]);e.uMaxVmax=new nc({componentDatatype:Q.FLOAT,componentsPerAttribute:4,normalize:!1,value:[o.x,o.y,r.x,r.y]});let s=1/Vne(i,o,r),a=1/Vne(i,r,o);e.uvMinAndExtents=new nc({componentDatatype:Q.FLOAT,componentsPerAttribute:4,normalize:!1,value:[i.x,i.y,s,a]})}var Xne=new he,Ine=new h,IWe=new h,WWe=new h,Z5={high:0,low:0};function Wne(e,t,n){let i=Xne;i.height=0,i.longitude=e.west,i.latitude=e.south;let o=t.project(i,Ine);i.latitude=e.north;let r=t.project(i,IWe);i.longitude=e.east,i.latitude=e.south;let s=t.project(i,WWe),a=[0,0,0,0],c=[0,0,0,0],d=Yn.encode(o.x,Z5);a[0]=d.high,c[0]=d.low,d=Yn.encode(o.y,Z5),a[1]=d.high,c[1]=d.low,d=Yn.encode(r.y,Z5),a[2]=d.high,c[2]=d.low,d=Yn.encode(s.x,Z5),a[3]=d.high,c[3]=d.low,n.planes2D_HIGH=new nc({componentDatatype:Q.FLOAT,componentsPerAttribute:4,normalize:!1,value:a}),n.planes2D_LOW=new nc({componentDatatype:Q.FLOAT,componentsPerAttribute:4,normalize:!1,value:c})}var PWe=new M,vWe=new M,Lne=new h,wWe=new he,FWe=[new he,new he,new he,new he,new he,new he,new he,new he];function AWe(e,t,n,i,o,r){let s=le.center(e,wWe);s.height=n;let a=he.toCartesian(s,t,Lne),c=Wt.eastNorthUpToFixedFrame(a,t,PWe),d=M.inverse(c,vWe),u=e.west,m=e.east,p=e.north,b=e.south,f=FWe;f[0].latitude=b,f[0].longitude=u,f[1].latitude=p,f[1].longitude=u,f[2].latitude=p,f[2].longitude=m,f[3].latitude=b,f[3].longitude=m;let x=(u+m)*.5,_=(p+b)*.5;f[4].latitude=b,f[4].longitude=x,f[5].latitude=p,f[5].longitude=x,f[6].latitude=_,f[6].longitude=u,f[7].latitude=_,f[7].longitude=m;let C=Number.POSITIVE_INFINITY,V=Number.NEGATIVE_INFINITY,L=Number.POSITIVE_INFINITY,R=Number.NEGATIVE_INFINITY;for(let W=0;W<8;W++){f[W].height=n;let F=he.toCartesian(f[W],t,Lne);M.multiplyByPoint(d,F,F),F.z=0,C=Math.min(C,F.x),V=Math.max(V,F.x),L=Math.min(L,F.y),R=Math.max(R,F.y)}let G=i;G.x=C,G.y=L,G.z=0,M.multiplyByPoint(c,G,G);let X=o;X.x=V,X.y=L,X.z=0,M.multiplyByPoint(c,X,X),h.subtract(X,G,o);let v=r;v.x=C,v.y=R,v.z=0,M.multiplyByPoint(c,v,v),h.subtract(v,G,r)}var MWe=new h,NWe=new h,kWe=new Yn;uu.getPlanarTextureCoordinateAttributes=function(e,t,n,i,o){let r=Ine,s=MWe,a=NWe;AWe(e,n,g(o,0),r,s,a);let c={};Ene(c,t);let d=Yn.fromCartesian(r,kWe);return c.southWest_HIGH=new nc({componentDatatype:Q.FLOAT,componentsPerAttribute:3,normalize:!1,value:h.pack(d.high,[0,0,0])}),c.southWest_LOW=new nc({componentDatatype:Q.FLOAT,componentsPerAttribute:3,normalize:!1,value:h.pack(d.low,[0,0,0])}),c.eastward=new nc({componentDatatype:Q.FLOAT,componentsPerAttribute:3,normalize:!1,value:h.pack(s,[0,0,0])}),c.northward=new nc({componentDatatype:Q.FLOAT,componentsPerAttribute:3,normalize:!1,value:h.pack(a,[0,0,0])}),Wne(e,i,c),c};var UWe=new h;function Zne(e,t,n,i){let o=Xne;o.latitude=e,o.longitude=t,o.height=0;let r=he.toCartesian(o,n,UWe),s=Math.sqrt(r.x*r.x+r.y*r.y),a=P.fastApproximateAtan2(s,r.z),c=P.fastApproximateAtan2(r.x,r.y);return i.x=a,i.y=c,i}var Rne=new D;uu.getSphericalExtentGeometryInstanceAttributes=function(e,t,n,i){let o=Zne(e.south,e.west,n,Rne),r=o.x,s=o.y,a=Zne(e.north,e.east,n,Rne),c=a.x,d=a.y,u=0;s>d&&(u=P.PI-s,s=-P.PI,d+=u),r-=P.EPSILON5,s-=P.EPSILON5,c+=P.EPSILON5,d+=P.EPSILON5;let m=1/(d-s),p=1/(c-r),b={sphericalExtents:new nc({componentDatatype:Q.FLOAT,componentsPerAttribute:4,normalize:!1,value:[r,s,p,m]}),longitudeRotation:new nc({componentDatatype:Q.FLOAT,componentsPerAttribute:1,normalize:!1,value:[u]})};return Ene(b,t),Wne(e,i,b),b};uu.hasAttributesForTextureCoordinatePlanes=function(e){return l(e.southWest_HIGH)&&l(e.southWest_LOW)&&l(e.northward)&&l(e.eastward)&&l(e.planes2D_HIGH)&&l(e.planes2D_LOW)&&l(e.uMaxVmax)&&l(e.uvMinAndExtents)};uu.hasAttributesForSphericalExtents=function(e){return l(e.sphericalExtents)&&l(e.longitudeRotation)&&l(e.planes2D_HIGH)&&l(e.planes2D_LOW)&&l(e.uMaxVmax)&&l(e.uvMinAndExtents)};function DWe(e){return Math.max(e.width,e.height)>uu.MAX_WIDTH_FOR_PLANAR_EXTENTS}uu.shouldUseSphericalCoordinates=function(e){return DWe(e)};uu.MAX_WIDTH_FOR_PLANAR_EXTENTS=P.toRadians(1);var ld=uu;var IJt=T(S(),1);var VJt=T(S(),1);var BWe={NEVER:ne.NEVER,LESS:ne.LESS,EQUAL:ne.EQUAL,LESS_OR_EQUAL:ne.LEQUAL,GREATER:ne.GREATER,NOT_EQUAL:ne.NOTEQUAL,GREATER_OR_EQUAL:ne.GEQUAL,ALWAYS:ne.ALWAYS},vn=Object.freeze(BWe);var RJt=T(S(),1);var YWe={ZERO:ne.ZERO,KEEP:ne.KEEP,REPLACE:ne.REPLACE,INCREMENT:ne.INCR,DECREMENT:ne.DECR,INVERT:ne.INVERT,INCREMENT_WRAP:ne.INCR_WRAP,DECREMENT_WRAP:ne.DECR_WRAP},dt=Object.freeze(YWe);var R5={CESIUM_3D_TILE_MASK:128,SKIP_LOD_MASK:112,SKIP_LOD_BIT_SHIFT:4,CLASSIFICATION_MASK:15};R5.setCesium3DTileBit=function(){return{enabled:!0,frontFunction:vn.ALWAYS,frontOperation:{fail:dt.KEEP,zFail:dt.KEEP,zPass:dt.REPLACE},backFunction:vn.ALWAYS,backOperation:{fail:dt.KEEP,zFail:dt.KEEP,zPass:dt.REPLACE},reference:R5.CESIUM_3D_TILE_MASK,mask:R5.CESIUM_3D_TILE_MASK}};var Mt=Object.freeze(R5);function xx(e){e=g(e,g.EMPTY_OBJECT);let t=e.geometryInstances;this.geometryInstances=t,this.show=g(e.show,!0),this.classificationType=g(e.classificationType,Un.BOTH),this.debugShowBoundingVolume=g(e.debugShowBoundingVolume,!1),this.debugShowShadowVolume=g(e.debugShowShadowVolume,!1),this._debugShowShadowVolume=!1,this._extruded=g(e._extruded,!1),this._uniformMap=e._uniformMap,this._sp=void 0,this._spStencil=void 0,this._spPick=void 0,this._spColor=void 0,this._spPick2D=void 0,this._spColor2D=void 0,this._rsStencilDepthPass=void 0,this._rsStencilDepthPass3DTiles=void 0,this._rsColorPass=void 0,this._rsPickPass=void 0,this._commandsIgnoreShow=[],this._ready=!1,this._primitive=void 0,this._pickPrimitive=e._pickPrimitive,this._hasSphericalExtentsAttribute=!1,this._hasPlanarExtentsAttributes=!1,this._hasPerColorAttribute=!1,this.appearance=e.appearance,this._createBoundingVolumeFunction=e._createBoundingVolumeFunction,this._updateAndQueueCommandsFunction=e._updateAndQueueCommandsFunction,this._usePickOffsets=!1,this._primitiveOptions={geometryInstances:void 0,appearance:void 0,vertexCacheOptimize:g(e.vertexCacheOptimize,!1),interleave:g(e.interleave,!1),releaseGeometryInstances:g(e.releaseGeometryInstances,!0),allowPicking:g(e.allowPicking,!0),asynchronous:g(e.asynchronous,!0),compressVertices:g(e.compressVertices,!0),_createBoundingVolumeFunction:void 0,_createRenderStatesFunction:void 0,_createShaderProgramFunction:void 0,_createCommandsFunction:void 0,_updateAndQueueCommandsFunction:void 0,_createPickOffsets:!0}}Object.defineProperties(xx.prototype,{vertexCacheOptimize:{get:function(){return this._primitiveOptions.vertexCacheOptimize}},interleave:{get:function(){return this._primitiveOptions.interleave}},releaseGeometryInstances:{get:function(){return this._primitiveOptions.releaseGeometryInstances}},allowPicking:{get:function(){return this._primitiveOptions.allowPicking}},asynchronous:{get:function(){return this._primitiveOptions.asynchronous}},compressVertices:{get:function(){return this._primitiveOptions.compressVertices}},ready:{get:function(){return this._ready}},_needs2DShader:{get:function(){return this._hasPlanarExtentsAttributes||this._hasSphericalExtentsAttribute}}});xx.isSupported=function(e){return e.context.stencilBuffer};function qS(e,t){let n=t?vn.EQUAL:vn.ALWAYS;return{colorMask:{red:!1,green:!1,blue:!1,alpha:!1},stencilTest:{enabled:e,frontFunction:n,frontOperation:{fail:dt.KEEP,zFail:dt.DECREMENT_WRAP,zPass:dt.KEEP},backFunction:n,backOperation:{fail:dt.KEEP,zFail:dt.INCREMENT_WRAP,zPass:dt.KEEP},reference:Mt.CESIUM_3D_TILE_MASK,mask:Mt.CESIUM_3D_TILE_MASK},stencilMask:Mt.CLASSIFICATION_MASK,depthTest:{enabled:!0,func:tc.LESS_OR_EQUAL},depthMask:!1}}function TO(e){return{stencilTest:{enabled:e,frontFunction:vn.NOT_EQUAL,frontOperation:{fail:dt.ZERO,zFail:dt.ZERO,zPass:dt.ZERO},backFunction:vn.NOT_EQUAL,backOperation:{fail:dt.ZERO,zFail:dt.ZERO,zPass:dt.ZERO},reference:0,mask:Mt.CLASSIFICATION_MASK},stencilMask:Mt.CLASSIFICATION_MASK,depthTest:{enabled:!1},depthMask:!1,blending:un.PRE_MULTIPLIED_ALPHA_BLEND}}var OWe={stencilTest:{enabled:!0,frontFunction:vn.NOT_EQUAL,frontOperation:{fail:dt.ZERO,zFail:dt.ZERO,zPass:dt.ZERO},backFunction:vn.NOT_EQUAL,backOperation:{fail:dt.ZERO,zFail:dt.ZERO,zPass:dt.ZERO},reference:0,mask:Mt.CLASSIFICATION_MASK},stencilMask:Mt.CLASSIFICATION_MASK,depthTest:{enabled:!1},depthMask:!1};function zWe(e,t,n,i){if(l(e._rsStencilDepthPass))return;let o=!e.debugShowShadowVolume;e._rsStencilDepthPass=Ne.fromCache(qS(o,!1)),e._rsStencilDepthPass3DTiles=Ne.fromCache(qS(o,!0)),e._rsColorPass=Ne.fromCache(TO(o,!1)),e._rsPickPass=Ne.fromCache(OWe)}function HWe(e,t){if(!e.compressVertices)return t;if(t.search(/in\\s+vec3\\s+extrudeDirection;/g)!==-1){let n=\"compressedAttributes\",i=`in vec2 ${n};`,o=`vec3 extrudeDirection; `,r=` extrudeDirection = czm_octDecode(${n}, 65535.0); `,s=t;s=s.replace(/in\\s+vec3\\s+extrudeDirection;/g,\"\"),s=Ue.replaceMain(s,\"czm_non_compressed_main\");let a=`void main() { ${r} czm_non_compressed_main(); }`;return[i,o,s,a].join(` `)}}function KWe(e,t){let n=t.context,i=e._primitive,o=GE;o=e._primitive._batchTable.getVertexShaderCallback()(o),o=Rn._appendDistanceDisplayConditionToShader(i,o),o=Rn._modifyShaderPosition(e,o,t.scene3DOnly),o=Rn._updateColorAttribute(i,o);let r=e._hasPlanarExtentsAttributes,s=r||e._hasSphericalExtentsAttribute;e._extruded&&(o=HWe(i,o));let a=e._extruded?\"EXTRUDED_GEOMETRY\":\"\",c=new Ue({defines:[a],sources:[o]}),d=new Ue({sources:[wb]}),u=e._primitive._attributeLocations,m=new ld(s,r,e.appearance);if(e._spStencil=Ht.replaceCache({context:n,shaderProgram:e._spStencil,vertexShaderSource:c,fragmentShaderSource:d,attributeLocations:u}),e._primitive.allowPicking){let f=Ue.createPickVertexShaderSource(o);f=Rn._appendShowToShader(i,f),f=Rn._updatePickColorAttribute(f);let x=m.createPickFragmentShader(!1),_=m.createPickVertexShader([a],f,!1,t.mapProjection);if(e._spPick=Ht.replaceCache({context:n,shaderProgram:e._spPick,vertexShaderSource:_,fragmentShaderSource:x,attributeLocations:u}),s){let C=n.shaderCache.getDerivedShaderProgram(e._spPick,\"2dPick\");if(!l(C)){let V=m.createPickFragmentShader(!0),L=m.createPickVertexShader([a],f,!0,t.mapProjection);C=n.shaderCache.createDerivedShaderProgram(e._spPick,\"2dPick\",{vertexShaderSource:L,fragmentShaderSource:V,attributeLocations:u})}e._spPick2D=C}}else e._spPick=Ht.fromCache({context:n,vertexShaderSource:c,fragmentShaderSource:d,attributeLocations:u});o=Rn._appendShowToShader(i,o),c=new Ue({defines:[a],sources:[o]}),e._sp=Ht.replaceCache({context:n,shaderProgram:e._sp,vertexShaderSource:c,fragmentShaderSource:d,attributeLocations:u});let p=m.createFragmentShader(!1),b=m.createVertexShader([a],o,!1,t.mapProjection);if(e._spColor=Ht.replaceCache({context:n,shaderProgram:e._spColor,vertexShaderSource:b,fragmentShaderSource:p,attributeLocations:u}),s){let f=n.shaderCache.getDerivedShaderProgram(e._spColor,\"2dColor\");if(!l(f)){let x=m.createFragmentShader(!0),_=m.createVertexShader([a],o,!0,t.mapProjection);f=n.shaderCache.createDerivedShaderProgram(e._spColor,\"2dColor\",{vertexShaderSource:_,fragmentShaderSource:x,attributeLocations:u})}e._spColor2D=f}}function JWe(e,t){let n=e._primitive,i=n._va.length*2;t.length=i;let o,r,s,a=0,c=n._batchTable.getUniformMapCallback()(e._uniformMap),d=e._needs2DShader;for(o=0;o<i;o+=2){let b=n._va[a++];r=t[o],l(r)||(r=t[o]=new je({owner:e,primitiveType:n._primitiveType})),r.vertexArray=b,r.renderState=e._rsStencilDepthPass,r.shaderProgram=e._sp,r.uniformMap=c,r.pass=Ze.TERRAIN_CLASSIFICATION,s=je.shallowClone(r,r.derivedCommands.tileset),s.renderState=e._rsStencilDepthPass3DTiles,s.pass=Ze.CESIUM_3D_TILE_CLASSIFICATION,r.derivedCommands.tileset=s,r=t[o+1],l(r)||(r=t[o+1]=new je({owner:e,primitiveType:n._primitiveType})),r.vertexArray=b,r.renderState=e._rsColorPass,r.shaderProgram=e._spColor,r.pass=Ze.TERRAIN_CLASSIFICATION;let x=e.appearance.material;if(l(x)&&(c=Ct(c,x._uniforms)),r.uniformMap=c,s=je.shallowClone(r,r.derivedCommands.tileset),s.pass=Ze.CESIUM_3D_TILE_CLASSIFICATION,r.derivedCommands.tileset=s,d){let _=je.shallowClone(r,r.derivedCommands.appearance2D);_.shaderProgram=e._spColor2D,r.derivedCommands.appearance2D=_,_=je.shallowClone(s,s.derivedCommands.appearance2D),_.shaderProgram=e._spColor2D,s.derivedCommands.appearance2D=_}}let u=e._commandsIgnoreShow,m=e._spStencil,p=0;i=u.length=i/2;for(let b=0;b<i;++b){let f=u[b]=je.shallowClone(t[p],u[b]);f.shaderProgram=m,f.pass=Ze.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW,p+=2}}function QWe(e,t){let n=e._usePickOffsets,i=e._primitive,o=i._va.length*2,r,s=0,a;n&&(r=i._pickOffsets,o=r.length*2),t.length=o;let c,d,u,m=0,p=i._batchTable.getUniformMapCallback()(e._uniformMap),b=e._needs2DShader;for(c=0;c<o;c+=2){let f=i._va[m++];if(n&&(a=r[s++],f=i._va[a.index]),d=t[c],l(d)||(d=t[c]=new je({owner:e,primitiveType:i._primitiveType,pickOnly:!0})),d.vertexArray=f,d.renderState=e._rsStencilDepthPass,d.shaderProgram=e._sp,d.uniformMap=p,d.pass=Ze.TERRAIN_CLASSIFICATION,n&&(d.offset=a.offset,d.count=a.count),u=je.shallowClone(d,d.derivedCommands.tileset),u.renderState=e._rsStencilDepthPass3DTiles,u.pass=Ze.CESIUM_3D_TILE_CLASSIFICATION,d.derivedCommands.tileset=u,d=t[c+1],l(d)||(d=t[c+1]=new je({owner:e,primitiveType:i._primitiveType,pickOnly:!0})),d.vertexArray=f,d.renderState=e._rsPickPass,d.shaderProgram=e._spPick,d.uniformMap=p,d.pass=Ze.TERRAIN_CLASSIFICATION,n&&(d.offset=a.offset,d.count=a.count),u=je.shallowClone(d,d.derivedCommands.tileset),u.pass=Ze.CESIUM_3D_TILE_CLASSIFICATION,d.derivedCommands.tileset=u,b){let x=je.shallowClone(d,d.derivedCommands.pick2D);x.shaderProgram=e._spPick2D,d.derivedCommands.pick2D=x,x=je.shallowClone(u,u.derivedCommands.pick2D),x.shaderProgram=e._spPick2D,u.derivedCommands.pick2D=x}}}function jWe(e,t,n,i,o,r,s){JWe(e,r),QWe(e,s)}function Pne(e,t){return Math.floor(e%t/2)}function _O(e,t,n,i,o,r){e.modelMatrix=n,e.boundingVolume=o,e.cull=i,e.debugShowBoundingVolume=r,t.commandList.push(e)}function vne(e,t,n,i,o){e.modelMatrix=n,e.boundingVolume=o,e.cull=i,t.commandList.push(e)}function qWe(e,t,n,i,o,r,s,a){let c=e._primitive;Rn._updateBoundingVolumes(c,t,o);let d;t.mode===ie.SCENE3D?d=c._boundingSphereWC:t.mode===ie.COLUMBUS_VIEW?d=c._boundingSphereCV:t.mode===ie.SCENE2D&&l(c._boundingSphere2D)?d=c._boundingSphere2D:l(c._boundingSphereMorph)&&(d=c._boundingSphereMorph);let u=e.classificationType,m=u!==Un.CESIUM_3D_TILE,p=u!==Un.TERRAIN,b=t.passes,f,x,_;if(b.render){let C=n.length;for(f=0;f<C;++f)x=d[Pne(f,C)],m&&(_=n[f],_O(_,t,o,r,x,s)),p&&(_=n[f].derivedCommands.tileset,_O(_,t,o,r,x,s));if(t.invertClassification){let V=e._commandsIgnoreShow,L=V.length;for(f=0;f<L;++f)x=d[f],_=V[f],_O(_,t,o,r,x,s)}}if(b.pick){let C=i.length,V=c._pickOffsets;for(f=0;f<C;++f){let L=V[Pne(f,C)];x=d[L.index],m&&(_=i[f],vne(_,t,o,r,x)),p&&(_=i[f].derivedCommands.tileset,vne(_,t,o,r,x))}}}xx.prototype.update=function(e){if(!l(this._primitive)&&!l(this.geometryInstances))return;let t=this.appearance;l(t)&&l(t.material)&&t.material.update(e.context);let n=this,i=this._primitiveOptions;if(!l(this._primitive)){let o=Array.isArray(this.geometryInstances)?this.geometryInstances:[this.geometryInstances],r=o.length,s,a,c,d=!1,u=!0,m,p=!1,b=!1;for(r>0&&(c=o[0].attributes,p=ld.hasAttributesForSphericalExtents(c),b=ld.hasAttributesForTextureCoordinatePlanes(c),m=c.color),s=0;s<r;s++){a=o[s];let x=a.attributes.color;l(x)&&(d=!0),u=u&&l(x)&&Ot.equals(m,x)}if(!u&&!p&&!b)throw new fe(\"All GeometryInstances must have the same color attribute except via GroundPrimitives\");d&&!l(t)&&(t=new ln({flat:!0}),this.appearance=t),this._usePickOffsets=!p&&!b,this._hasSphericalExtentsAttribute=p,this._hasPlanarExtentsAttributes=b,this._hasPerColorAttribute=d;let f=new Array(r);for(s=0;s<r;++s)a=o[s],f[s]=new"
}