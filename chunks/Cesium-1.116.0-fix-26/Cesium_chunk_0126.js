{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 126,
    "total_chunks": 194,
    "chunk_size": 6794,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.726Z"
  },
  "content": "ellipsoidNormal = geodeticSurfaceNormal; #else vec3 ellipsoidNormal = normalize(position3DWC); #endif #if defined(EXAGGERATION) && defined(GEODETIC_SURFACE_NORMALS) float exaggeration = u_verticalExaggerationAndRelativeHeight.x; float relativeHeight = u_verticalExaggerationAndRelativeHeight.y; float newHeight = (height - relativeHeight) * exaggeration + relativeHeight; // stop from going through center of earth float minRadius = min(min(czm_ellipsoidRadii.x, czm_ellipsoidRadii.y), czm_ellipsoidRadii.z); newHeight = max(newHeight, -minRadius); vec3 offset = ellipsoidNormal * (newHeight - height); position += offset; position3DWC += offset; height = newHeight; #endif gl_Position = getPosition(position, height, textureCoordinates); v_positionEC = (u_modifiedModelView * vec4(position, 1.0)).xyz; v_positionMC = position3DWC; // position in model coordinates v_textureCoordinates = vec3(textureCoordinates, webMercatorT); #if defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL) vec3 normalMC = czm_octDecode(encodedNormal); #if defined(EXAGGERATION) && defined(GEODETIC_SURFACE_NORMALS) vec3 projection = dot(normalMC, ellipsoidNormal) * ellipsoidNormal; vec3 rejection = normalMC - projection; normalMC = normalize(projection + rejection * exaggeration); #endif v_normalMC = normalMC; v_normalEC = czm_normal3D * v_normalMC; #endif #if defined(FOG) || (defined(GROUND_ATMOSPHERE) && !defined(PER_FRAGMENT_GROUND_ATMOSPHERE)) bool dynamicLighting = false; #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING)) dynamicLighting = true; #endif #if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN) vec3 atmosphereLightDirection = czm_sunDirectionWC; #else vec3 atmosphereLightDirection = czm_lightDirectionWC; #endif vec3 lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(position3DWC)); computeAtmosphereScattering( position3DWC, lightDirection, v_atmosphereRayleighColor, v_atmosphereMieColor, v_atmosphereOpacity ); #endif #if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) v_distance = length((czm_modelView3D * vec4(position3DWC, 1.0)).xyz); #endif #ifdef APPLY_MATERIAL float northPoleZ = czm_ellipsoidRadii.z; vec3 northPolePositionMC = vec3(0.0, 0.0, northPoleZ); vec3 vectorEastMC = normalize(cross(northPolePositionMC - v_positionMC, ellipsoidNormal)); float dotProd = abs(dot(ellipsoidNormal, v_normalMC)); v_slope = acos(dotProd); vec3 normalRejected = ellipsoidNormal * dotProd; vec3 normalProjected = v_normalMC - normalRejected; vec3 aspectVector = normalize(normalProjected); v_aspect = acos(dot(aspectVector, vectorEastMC)); float determ = dot(cross(vectorEastMC, aspectVector), ellipsoidNormal); v_aspect = czm_branchFreeTernary(determ < 0.0, 2.0 * czm_pi - v_aspect, v_aspect); v_height = height; #endif } `;var gbi=T(S(),1),H0=`uniform vec3 u_radiiAndDynamicAtmosphereColor; uniform float u_atmosphereLightIntensity; uniform float u_atmosphereRayleighScaleHeight; uniform float u_atmosphereMieScaleHeight; uniform float u_atmosphereMieAnisotropy; uniform vec3 u_atmosphereRayleighCoefficient; uniform vec3 u_atmosphereMieCoefficient; const float ATMOSPHERE_THICKNESS = 111e3; // The thickness of the atmosphere in meters. const int PRIMARY_STEPS_MAX = 16; // Maximum number of times the ray from the camera to the world position (primary ray) is sampled. const int LIGHT_STEPS_MAX = 4; // Maximum number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray. /** * This function computes the colors contributed by Rayliegh and Mie scattering on a given ray, as well as * the transmittance value for the ray. * * @param {czm_ray} primaryRay The ray from the camera to the position. * @param {float} primaryRayLength The length of the primary ray. * @param {vec3} lightDirection The direction of the light to calculate the scattering from. * @param {vec3} rayleighColor The variable the Rayleigh scattering will be written to. * @param {vec3} mieColor The variable the Mie scattering will be written to. * @param {float} opacity The variable the transmittance will be written to. * @glslFunction */ void computeScattering( czm_ray primaryRay, float primaryRayLength, vec3 lightDirection, float atmosphereInnerRadius, out vec3 rayleighColor, out vec3 mieColor, out float opacity ) { // Initialize the default scattering amounts to 0. rayleighColor = vec3(0.0); mieColor = vec3(0.0); opacity = 0.0; float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS; vec3 origin = vec3(0.0); // Calculate intersection from the camera to the outer ring of the atmosphere. czm_raySegment primaryRayAtmosphereIntersect = czm_raySphereIntersectionInterval(primaryRay, origin, atmosphereOuterRadius); // Return empty colors if no intersection with the atmosphere geometry. if (primaryRayAtmosphereIntersect == czm_emptyRaySegment) { return; } // To deal with smaller values of PRIMARY_STEPS (e.g. 4) // we implement a split strategy: sky or horizon. // For performance reasons, instead of a if/else branch // a soft choice is implemented through a weight 0.0 <= w_stop_gt_lprl <= 1.0 float x = 1e-7 * primaryRayAtmosphereIntersect.stop / length(primaryRayLength); // Value close to 0.0: close to the horizon // Value close to 1.0: above in the sky float w_stop_gt_lprl = 0.5 * (1.0 + czm_approximateTanh(x)); // The ray should start from the first intersection with the outer atmopshere, or from the camera position, if it is inside the atmosphere. float start_0 = primaryRayAtmosphereIntersect.start; primaryRayAtmosphereIntersect.start = max(primaryRayAtmosphereIntersect.start, 0.0); // The ray should end at the exit from the atmosphere or at the distance to the vertex, whichever is smaller. primaryRayAtmosphereIntersect.stop = min(primaryRayAtmosphereIntersect.stop, length(primaryRayLength)); // For the number of ray steps, distinguish inside or outside atmosphere (outer space) // (1) from outer space we have to use more ray steps to get a realistic rendering // (2) within atmosphere we need fewer steps for faster rendering float x_o_a = start_0 - ATMOSPHERE_THICKNESS; // ATMOSPHERE_THICKNESS used as an ad-hoc constant, no precise meaning here, only the order of magnitude matters float w_inside_atmosphere = 1.0 - 0.5 * (1.0 + czm_approximateTanh(x_o_a)); int PRIMARY_STEPS = PRIMARY_STEPS_MAX - int(w_inside_atmosphere * 12.0); // Number of times the ray from the camera to the world position (primary ray) is sampled. int LIGHT_STEPS = LIGHT_STEPS_MAX - int(w_inside_atmosphere * 2.0); // Number of times the light is sampled from the light source's intersection with the atmosphere to"
}