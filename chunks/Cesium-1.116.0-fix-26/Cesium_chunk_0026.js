{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 26,
    "total_chunks": 194,
    "chunk_size": 5900,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.661Z"
  },
  "content": "* When GL_EXT_frag_depth is not available, which is the case on some mobile * devices, we must attempt to fix this only in the vertex shader. * The approach is to clamp the z value to the far plane, which closes the * shadow volume but also distorts the geometry, so there can still be artifacts * on frustum seams. * * @name czm_depthClamp * @glslFunction * * @param {vec4} coords The vertex in clip coordinates. * @returns {vec4} The modified vertex. * * @example * gl_Position = czm_depthClamp(czm_modelViewProjection * vec4(position, 1.0)); * * @see czm_writeDepthClamp */ vec4 czm_depthClamp(vec4 coords) { #ifndef LOG_DEPTH #if __VERSION__ == 300 || defined(GL_EXT_frag_depth) v_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w; coords.z = 0.0; #else coords.z = min(coords.z, coords.w); #endif #endif return coords; } `;var WPt=T(S(),1),CR=`/** * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid's east-north-up coordinate system * to eye coordinates. In east-north-up coordinates, x points east, y points north, and z points along the * surface normal. East-north-up can be used as an ellipsoid's tangent space for operations such as bump mapping. * <br /><br /> * The ellipsoid is assumed to be centered at the model coordinate's origin. * * @name czm_eastNorthUpToEyeCoordinates * @glslFunction * * @param {vec3} positionMC The position on the ellipsoid in model coordinates. * @param {vec3} normalEC The normalized ellipsoid surface normal, at <code>positionMC</code>, in eye coordinates. * * @returns {mat3} A 3x3 rotation matrix that transforms vectors from the east-north-up coordinate system to eye coordinates. * * @example * // Transform a vector defined in the east-north-up coordinate * // system, (0, 0, 1) which is the surface normal, to eye * // coordinates. * mat3 m = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC); * vec3 normalEC = m * vec3(0.0, 0.0, 1.0); */ mat3 czm_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC) { vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0)); // normalized surface tangent in model coordinates vec3 tangentEC = normalize(czm_normal3D * tangentMC); // normalized surface tangent in eye coordinates vec3 bitangentEC = normalize(cross(normalEC, tangentEC)); // normalized surface bitangent in eye coordinates return mat3( tangentEC.x, tangentEC.y, tangentEC.z, bitangentEC.x, bitangentEC.y, bitangentEC.z, normalEC.x, normalEC.y, normalEC.z); } `;var vPt=T(S(),1),VR=`/** * DOC_TBA * * @name czm_ellipsoidContainsPoint * @glslFunction * */ bool czm_ellipsoidContainsPoint(vec3 ellipsoid_inverseRadii, vec3 point) { vec3 scaled = ellipsoid_inverseRadii * (czm_inverseModelView * vec4(point, 1.0)).xyz; return (dot(scaled, scaled) <= 1.0); } `;var FPt=T(S(),1),LR=`/** * DOC_TBA * * @name czm_ellipsoidWgs84TextureCoordinates * @glslFunction */ vec2 czm_ellipsoidWgs84TextureCoordinates(vec3 normal) { return vec2(atan(normal.y, normal.x) * czm_oneOverTwoPi + 0.5, asin(normal.z) * czm_oneOverPi + 0.5); } `;var MPt=T(S(),1),ZR=`/** * Compares <code>left</code> and <code>right</code> componentwise. Returns <code>true</code> * if they are within <code>epsilon</code> and <code>false</code> otherwise. The inputs * <code>left</code> and <code>right</code> can be <code>float</code>s, <code>vec2</code>s, * <code>vec3</code>s, or <code>vec4</code>s. * * @name czm_equalsEpsilon * @glslFunction * * @param {} left The first vector. * @param {} right The second vector. * @param {float} epsilon The epsilon to use for equality testing. * @returns {bool} <code>true</code> if the components are within <code>epsilon</code> and <code>false</code> otherwise. * * @example * // GLSL declarations * bool czm_equalsEpsilon(float left, float right, float epsilon); * bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon); * bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon); * bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon); */ bool czm_equalsEpsilon(vec4 left, vec4 right, float epsilon) { return all(lessThanEqual(abs(left - right), vec4(epsilon))); } bool czm_equalsEpsilon(vec3 left, vec3 right, float epsilon) { return all(lessThanEqual(abs(left - right), vec3(epsilon))); } bool czm_equalsEpsilon(vec2 left, vec2 right, float epsilon) { return all(lessThanEqual(abs(left - right), vec2(epsilon))); } bool czm_equalsEpsilon(float left, float right, float epsilon) { return (abs(left - right) <= epsilon); } `;var kPt=T(S(),1),RR=`/** * DOC_TBA * * @name czm_eyeOffset * @glslFunction * * @param {vec4} positionEC DOC_TBA. * @param {vec3} eyeOffset DOC_TBA. * * @returns {vec4} DOC_TBA. */ vec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset) { // This equation is approximate in x and y. vec4 p = positionEC; vec4 zEyeOffset = normalize(p) * eyeOffset.z; p.xy += eyeOffset.xy + zEyeOffset.xy; p.z += zEyeOffset.z; return p; } `;var DPt=T(S(),1),GR=`/** * Transforms a position from eye to window coordinates. The transformation * from eye to clip coordinates is done using {@link czm_projection}. * The transform from normalized device coordinates to window coordinates is * done using {@link czm_viewportTransformation}, which assumes a depth range * of <code>near = 0</code> and <code>far = 1</code>. * <br /><br /> * This transform is useful when there is a need to manipulate window coordinates * in a vertex shader as done by {@link BillboardCollection}. * * @name czm_eyeToWindowCoordinates * @glslFunction * * @param {vec4} position The position in eye coordinates to transform. * * @returns {vec4} The transformed position in window coordinates. * * @see czm_modelToWindowCoordinates * @see czm_projection * @see czm_viewportTransformation * @see BillboardCollection * * @example * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC); */ vec4 czm_eyeToWindowCoordinates(vec4 positionEC) { vec4 q = czm_projection * positionEC; // clip coordinates"
}