{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 41,
    "total_chunks": 194,
    "chunk_size": 10055,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.669Z"
  },
  "content": "#if defined(LOG_DEPTH) || defined(LOG_DEPTH_READ_ONLY) float near = czm_currentFrustum.x; float far = czm_currentFrustum.y; float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne; float depthFromNear = pow(2.0, log2Depth) - 1.0; float depthFromCamera = depthFromNear + near; vec4 screenCoord = vec4(screenCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0); vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord); eyeCoordinate.w = 1.0 / depthFromCamera; // Better precision return eyeCoordinate; #else vec4 screenCoord = vec4(screenCoordinateXY, depthOrLogDepth, 1.0); vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord); #endif return eyeCoordinate; } /** * Transforms a position given as window x/y and a depth or a log depth from window to eye coordinates. * This function produces more accurate results for window positions with log depth than * conventionally unpacking the log depth using czm_reverseLogDepth and using the standard version * of czm_windowToEyeCoordinates. * * @name czm_windowToEyeCoordinates * @glslFunction * * @param {vec2} fragmentCoordinateXY The XY position in window coordinates to transform. * @param {float} depthOrLogDepth A depth or log depth for the fragment. * * @see czm_modelToWindowCoordinates * @see czm_eyeToWindowCoordinates * @see czm_inverseProjection * @see czm_viewport * @see czm_viewportTransformation * * @returns {vec4} The transformed position in eye coordinates. */ vec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth) { vec2 screenCoordXY = (fragmentCoordinateXY.xy - czm_viewport.xy) / czm_viewport.zw; return czm_screenToEyeCoordinates(screenCoordXY, depthOrLogDepth); } `;var Ywt=T(S(),1),EG=`// emulated noperspective #if !defined(LOG_DEPTH) in float v_WindowZ; #endif /** * Emulates GL_DEPTH_CLAMP. Clamps a fragment to the near and far plane * by writing the fragment's depth. See czm_depthClamp for more details. * * @name czm_writeDepthClamp * @glslFunction * * @example * out_FragColor = color; * czm_writeDepthClamp(); * * @see czm_depthClamp */ void czm_writeDepthClamp() { #if (!defined(LOG_DEPTH) && (__VERSION__ == 300 || defined(GL_EXT_frag_depth))) gl_FragDepth = clamp(v_WindowZ * gl_FragCoord.w, 0.0, 1.0); #endif } `;var zwt=T(S(),1),XG=`#ifdef LOG_DEPTH in float v_depthFromNearPlusOne; #ifdef POLYGON_OFFSET uniform vec2 u_polygonOffset; #endif #endif /** * Writes the fragment depth to the logarithmic depth buffer. * <p> * Use this when the vertex shader does not call {@link czm_vertexlogDepth}, for example, when * ray-casting geometry using a full screen quad. * </p> * @name czm_writeLogDepth * @glslFunction * * @param {float} depth The depth coordinate, where 1.0 is on the near plane and * depth increases in eye-space units from there * * @example * czm_writeLogDepth((czm_projection * v_positionEyeCoordinates).w + 1.0); */ void czm_writeLogDepth(float depth) { #if (defined(LOG_DEPTH) && (__VERSION__ == 300 || defined(GL_EXT_frag_depth))) // Discard the vertex if it's not between the near and far planes. // We allow a bit of epsilon on the near plane comparison because a 1.0 // from the vertex shader (indicating the vertex should be _on_ the near // plane) will not necessarily come here as exactly 1.0. if (depth <= 0.9999999 || depth > czm_farDepthFromNearPlusOne) { discard; } #ifdef POLYGON_OFFSET // Polygon offset: m * factor + r * units float factor = u_polygonOffset[0]; float units = u_polygonOffset[1]; #if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives)) // This factor doesn't work in IE 10 if (factor != 0.0) { // m = sqrt(dZdX^2 + dZdY^2); float x = dFdx(depth); float y = dFdy(depth); float m = sqrt(x * x + y * y); // Apply the factor before computing the log depth. depth += m * factor; } #endif #endif gl_FragDepth = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne; #ifdef POLYGON_OFFSET // Apply the units after the log depth. gl_FragDepth += czm_epsilon7 * units; #endif #endif } /** * Writes the fragment depth to the logarithmic depth buffer. * <p> * Use this when the vertex shader calls {@link czm_vertexlogDepth}. * </p> * * @name czm_writeLogDepth * @glslFunction */ void czm_writeLogDepth() { #ifdef LOG_DEPTH czm_writeLogDepth(v_depthFromNearPlusOne); #endif } `;var Kwt=T(S(),1),IG=`/** * Transforms a value for non-perspective interpolation by multiplying * it by w, the value used in the perspective divide. This function is * intended to be called in a vertex shader to compute the value of a * \\`varying\\` that should not be subject to perspective interpolation. * For example, screen-space texture coordinates. The fragment shader * must call {@link czm_readNonPerspective} to retrieve the final * non-perspective value. * * @name czm_writeNonPerspective * @glslFunction * * @param {float|vec2|vec3|vec4} value The value to be interpolated without accounting for perspective. * @param {float} w The perspective divide value. Usually this is the computed \\`gl_Position.w\\`. * @returns {float|vec2|vec3|vec4} The transformed value, intended to be stored in a \\`varying\\` and read in the * fragment shader with {@link czm_readNonPerspective}. */ float czm_writeNonPerspective(float value, float w) { return value * w; } vec2 czm_writeNonPerspective(vec2 value, float w) { return value * w; } vec3 czm_writeNonPerspective(vec3 value, float w) { return value * w; } vec4 czm_writeNonPerspective(vec4 value, float w) { return value * w; } `;var ix={czm_degreesPerRadian:iZ,czm_depthRange:oZ,czm_epsilon1:rZ,czm_epsilon2:sZ,czm_epsilon3:aZ,czm_epsilon4:cZ,czm_epsilon5:lZ,czm_epsilon6:dZ,czm_epsilon7:uZ,czm_infinity:mZ,czm_oneOverPi:hZ,czm_oneOverTwoPi:fZ,czm_passCesium3DTile:pZ,czm_passCesium3DTileClassification:bZ,czm_passCesium3DTileClassificationIgnoreShow:yZ,czm_passClassification:gZ,czm_passCompute:xZ,czm_passEnvironment:_Z,czm_passGlobe:TZ,czm_passOpaque:SZ,czm_passOverlay:CZ,czm_passTerrainClassification:VZ,czm_passTranslucent:LZ,czm_passVoxels:ZZ,czm_pi:RZ,czm_piOverFour:GZ,czm_piOverSix:EZ,czm_piOverThree:XZ,czm_piOverTwo:IZ,czm_radiansPerDegree:WZ,czm_sceneMode2D:PZ,czm_sceneMode3D:vZ,czm_sceneModeColumbusView:wZ,czm_sceneModeMorphing:FZ,czm_solarRadius:AZ,czm_threePiOver2:MZ,czm_twoPi:NZ,czm_webMercatorMaxLatitude:kZ,czm_depthRangeStruct:UZ,czm_material:DZ,czm_materialInput:BZ,czm_modelMaterial:YZ,czm_modelVertexOutput:OZ,czm_pbrParameters:zZ,czm_ray:HZ,czm_raySegment:KZ,czm_shadowParameters:JZ,czm_HSBToRGB:QZ,czm_HSLToRGB:jZ,czm_RGBToHSB:qZ,czm_RGBToHSL:$Z,czm_RGBToXYZ:eR,czm_XYZToRGB:tR,czm_acesTonemapping:nR,czm_alphaWeight:iR,czm_antialias:oR,czm_applyHSBShift:rR,czm_approximateSphericalCoordinates:sR,czm_approximateTanh:aR,czm_backFacing:cR,czm_branchFreeTernary:lR,czm_cascadeColor:dR,czm_cascadeDistance:uR,czm_cascadeMatrix:mR,czm_cascadeWeights:hR,czm_columbusViewMorph:fR,czm_computeAtmosphereColor:pR,czm_computeGroundAtmosphereScattering:bR,czm_computePosition:yR,czm_computeScattering:gR,czm_cosineAndSine:xR,czm_decompressTextureCoordinates:_R,czm_defaultPbrMaterial:TR,czm_depthClamp:SR,czm_eastNorthUpToEyeCoordinates:CR,czm_ellipsoidContainsPoint:VR,czm_ellipsoidWgs84TextureCoordinates:LR,czm_equalsEpsilon:ZR,czm_eyeOffset:RR,czm_eyeToWindowCoordinates:GR,czm_fastApproximateAtan:ER,czm_fog:XR,czm_gammaCorrect:IR,czm_geodeticSurfaceNormal:WR,czm_getDefaultMaterial:PR,czm_getDynamicAtmosphereLightDirection:vR,czm_getLambertDiffuse:wR,czm_getSpecular:FR,czm_getWaterNoise:AR,czm_hue:MR,czm_inverseGamma:NR,czm_isEmpty:kR,czm_isFull:UR,czm_latitudeToWebMercatorFraction:DR,czm_lineDistance:BR,czm_linearToSrgb:YR,czm_luminance:OR,czm_metersPerPixel:zR,czm_modelToWindowCoordinates:HR,czm_multiplyWithColorBalance:KR,czm_nearFarScalar:JR,czm_octDecode:QR,czm_packDepth:jR,czm_pbrLighting:qR,czm_pbrMetallicRoughnessMaterial:$R,czm_pbrSpecularGlossinessMaterial:eG,czm_phong:tG,czm_planeDistance:nG,czm_pointAlongRay:iG,czm_rayEllipsoidIntersectionInterval:oG,czm_raySphereIntersectionInterval:rG,czm_readDepth:sG,czm_readNonPerspective:aG,czm_reverseLogDepth:cG,czm_round:lG,czm_sampleOctahedralProjection:dG,czm_saturation:uG,czm_shadowDepthCompare:mG,czm_shadowVisibility:hG,czm_signNotZero:fG,czm_sphericalHarmonics:pG,czm_srgbToLinear:bG,czm_tangentToEyeSpaceMatrix:yG,czm_textureCube:gG,czm_transformPlane:xG,czm_translateRelativeToEye:_G,czm_translucentPhong:TG,czm_transpose:SG,czm_unpackDepth:CG,czm_unpackFloat:VG,czm_unpackUint:LG,czm_valueTransform:ZG,czm_vertexLogDepth:RG,czm_windowToEyeCoordinates:GG,czm_writeDepthClamp:EG,czm_writeLogDepth:XG,czm_writeNonPerspective:IG};var RAt=T(S(),1);function cZe(e,t){let n=e;return n=n.replaceAll(\"version 300 es\",\"\"),n=n.replaceAll(/(texture\\()/g,\"texture2D(\"),t?(n=n.replaceAll(/\\n\\s*(in)\\s+(vec\\d|mat\\d|float)/g,` varying $2`),/out_FragData_(\\d+)/.test(n)&&(n=`#extension GL_EXT_draw_buffers : enable ${n}`,n=n.replaceAll(/layout\\s+\\(location\\s*=\\s*\\d+\\)\\s*out\\s+vec4\\s+out_FragData_\\d+;/g,\"\"),n=n.replaceAll(/out_FragData_(\\d+)/g,\"gl_FragData[$1]\")),n=n.replaceAll(/layout\\s+\\(location\\s*=\\s*0\\)\\s*out\\s+vec4\\s+out_FragColor;/g,\"\"),n=n.replaceAll(/out_FragColor/g,\"gl_FragColor\"),n=n.replaceAll(/out_FragColor\\[(\\d+)\\]/g,\"gl_FragColor[$1]\"),/gl_FragDepth/.test(n)&&(n=`#extension GL_EXT_frag_depth : enable ${n}`,n=n.replaceAll(/gl_FragDepth/g,\"gl_FragDepthEXT\")),n=`#ifdef GL_OES_standard_derivatives #extension GL_OES_standard_derivatives : enable #endif ${n}`):(n=n.replaceAll(/(in)\\s+(vec\\d|mat\\d|float)/g,\"attribute $2\"),n=n.replaceAll(/(out)\\s+(vec\\d|mat\\d|float)\\s+([\\w]+);/g,\"varying $2 $3;\")),n=`#version 100 ${n}`,n}var WG=cZe;function lee(e){return e=e.replace(/\\/\\/.*/g,\"\"),e.replace(/\\/\\*\\*[\\s\\S]*?\\*\\//gm,function(t){let n=t.match(/\\n/gm).length,i=\"\";for(let o=0;o<n;++o)i+=` `;return i})}function dee(e,t,n){let i;for(let o=0;o<n.length;++o)n[o].name===e&&(i=n[o]);return l(i)||(t=lee(t),i={name:e,glslSource:t,dependsOn:[],requiredBy:[],evaluated:!1},n.push(i)),i}function uee(e,t){if(e.evaluated)return;e.evaluated=!0;let n=e.glslSource.match(/\\bczm_[a-zA-Z0-9_]*/g);l(n)&&n!==null&&(n=n.filter(function(i,o){return"
}