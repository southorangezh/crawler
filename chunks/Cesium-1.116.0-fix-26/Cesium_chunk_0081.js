{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 81,
    "total_chunks": 194,
    "chunk_size": 9684,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.694Z"
  },
  "content": "$ke(e){let t=je.shallowClone(e),n=Oe(e.renderState,!0);n.cull.enabled=!0,n.cull.face=mi.FRONT,n.colorMask={red:!1,green:!1,blue:!1,alpha:!1},n.polygonOffset={enabled:!0,factor:5,units:5};let i=Oe(t.uniformMap),o=new D(5,5);return i.u_polygonOffset=function(){return o},t.renderState=Ne.fromCache(n),t.uniformMap=i,t.castShadows=!1,t.receiveShadows=!1,t}function eUe(e){let t=je.shallowClone(e),n=Oe(e.renderState,!0),{stencilTest:i}=n;return i.enabled=!0,i.mask=Mt.SKIP_LOD_MASK,i.reference=Mt.CESIUM_3D_TILE_MASK,i.frontFunction=vn.GREATER_OR_EQUAL,i.frontOperation.zPass=dt.REPLACE,i.backFunction=vn.GREATER_OR_EQUAL,i.backOperation.zPass=dt.REPLACE,n.stencilMask=Mt.CESIUM_3D_TILE_MASK|Mt.SKIP_LOD_MASK,t.renderState=Ne.fromCache(n),t}var TI=uN;function tUe(e,t){let n=e.shaderBuilder;n.addVertexLines(gI),n.addFragmentLines(yI);let i=nUe(e),o=new ti({context:t.context,indexBuffer:i,attributes:e.attributes}),r=e.model;r._pipelineResources.push(o);let s=n.buildShaderProgram(t.context);r._pipelineResources.push(s);let a=e.alphaOptions.pass,c=r.sceneGraph,d=t.mode===ie.SCENE3D,u,m;if(!d&&!t.scene3DOnly&&r._projectTo2D)u=M.multiplyTransformation(c._computedModelMatrix,e.runtimeNode.computedTransform,new M),m=e.runtimePrimitive.boundingSphere2D;else{let V=d?c._computedModelMatrix:c._computedModelMatrix2D;u=M.multiplyTransformation(V,e.runtimeNode.computedTransform,new M),m=ce.transform(e.boundingSphere,u,e.boundingSphere)}let p=Oe(Ne.fromCache(e.renderStateOptions),!0);p.cull.face=qt.getCullFace(u,e.primitiveType),p=Ne.fromCache(p);let b=l(r.classificationType),f=b?!1:_n.castShadows(r.shadows),x=b?!1:_n.receiveShadows(r.shadows),_=b?void 0:e.pickId,C=new je({boundingVolume:m,modelMatrix:u,uniformMap:e.uniformMap,renderState:p,vertexArray:o,shaderProgram:s,cull:r.cull,pass:a,count:e.count,owner:r,pickId:_,instanceCount:e.instanceCount,primitiveType:e.primitiveType,debugShowBoundingVolume:r.debugShowBoundingVolume,castShadows:f,receiveShadows:x});return b?new _I({primitiveRenderResources:e,command:C}):new TI({primitiveRenderResources:e,command:C})}function nUe(e){let t=e.wireframeIndexBuffer;if(l(t))return t;let n=e.indices;if(l(n))return n.buffer}var SI=tUe;var $xn=T(S(),1);var zre={name:\"TilesetPipelineStage\"};zre.process=function(e,t,n){if(t.hasSkipLevelOfDetail(n)){e.shaderBuilder.addDefine(\"POLYGON_OFFSET\",void 0,Ce.FRAGMENT);let r={u_polygonOffset:function(){return D.ZERO}};e.uniformMap=Ct(r,e.uniformMap),e.hasSkipLevelOfDetail=!0}let i=e.renderStateOptions;i.stencilTest=Mt.setCesium3DTileBit(),i.stencilMask=Mt.CESIUM_3D_TILE_MASK};var CI=zre;var d_n=T(S(),1);var t_n=T(S(),1),VI=`// robust iterative solution without trig functions // https://github.com/0xfaded/ellipse_demo/issues/1 // https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse // // This version uses only a single iteration for best performance. For fog // rendering, the difference is negligible. vec2 nearestPointOnEllipseFast(vec2 pos, vec2 radii) { vec2 p = abs(pos); vec2 inverseRadii = 1.0 / radii; vec2 evoluteScale = (radii.x * radii.x - radii.y * radii.y) * vec2(1.0, -1.0) * inverseRadii; // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t)) // but store the cos and sin of t in a vec2 for efficiency. // Initial guess: t = cos(pi/4) vec2 tTrigs = vec2(0.70710678118); vec2 v = radii * tTrigs; // Find the evolute of the ellipse (center of curvature) at v. vec2 evolute = evoluteScale * tTrigs * tTrigs * tTrigs; // Find the (approximate) intersection of p - evolute with the ellipsoid. vec2 q = normalize(p - evolute) * length(v - evolute); // Update the estimate of t. tTrigs = (q + evolute) * inverseRadii; tTrigs = normalize(clamp(tTrigs, 0.0, 1.0)); v = radii * tTrigs; return v * sign(pos); } vec3 computeEllipsoidPositionWC(vec3 positionMC) { // Get the world-space position and project onto a meridian plane of // the ellipsoid vec3 positionWC = (czm_model * vec4(positionMC, 1.0)).xyz; vec2 positionEllipse = vec2(length(positionWC.xy), positionWC.z); vec2 nearestPoint = nearestPointOnEllipseFast(positionEllipse, czm_ellipsoidRadii.xz); // Reconstruct a 3D point in world space return vec3(nearestPoint.x * normalize(positionWC.xy), nearestPoint.y); } void applyFog(inout vec4 color, vec4 groundAtmosphereColor, vec3 lightDirection, float distanceToCamera) { vec3 fogColor = groundAtmosphereColor.rgb; // If there is dynamic lighting, apply that to the fog. const float NONE = 0.0; if (czm_atmosphereDynamicLighting != NONE) { float darken = clamp(dot(normalize(czm_viewerPositionWC), lightDirection), czm_fogMinimumBrightness, 1.0); fogColor *= darken; } // Tonemap if HDR rendering is disabled #ifndef HDR fogColor.rgb = czm_acesTonemapping(fogColor.rgb); fogColor.rgb = czm_inverseGamma(fogColor.rgb); #endif // Matches the constant in GlobeFS.glsl. This makes the fog falloff // more gradual. const float fogModifier = 0.15; vec3 withFog = czm_fog(distanceToCamera, color.rgb, fogColor, fogModifier); color = vec4(withFog, color.a); } void atmosphereStage(inout vec4 color, in ProcessedAttributes attributes) { vec3 rayleighColor; vec3 mieColor; float opacity; vec3 positionWC; vec3 lightDirection; // When the camera is in space, compute the position per-fragment for // more accurate ground atmosphere. All other cases will use // // The if condition will be added in https://github.com/CesiumGS/cesium/issues/11717 if (false) { positionWC = computeEllipsoidPositionWC(attributes.positionMC); lightDirection = czm_getDynamicAtmosphereLightDirection(positionWC, czm_atmosphereDynamicLighting); // The fog color is derived from the ground atmosphere color czm_computeGroundAtmosphereScattering( positionWC, lightDirection, rayleighColor, mieColor, opacity ); } else { positionWC = attributes.positionWC; lightDirection = czm_getDynamicAtmosphereLightDirection(positionWC, czm_atmosphereDynamicLighting); rayleighColor = v_atmosphereRayleighColor; mieColor = v_atmosphereMieColor; opacity = v_atmosphereOpacity; } //color correct rayleigh and mie colors const bool ignoreBlackPixels = true; rayleighColor = czm_applyHSBShift(rayleighColor, czm_atmosphereHsbShift, ignoreBlackPixels); mieColor = czm_applyHSBShift(mieColor, czm_atmosphereHsbShift, ignoreBlackPixels); vec4 groundAtmosphereColor = czm_computeAtmosphereColor(positionWC, lightDirection, rayleighColor, mieColor, opacity); if (u_isInFog) { float distanceToCamera = length(attributes.positionEC); applyFog(color, groundAtmosphereColor, lightDirection, distanceToCamera); } else { // Ground atmosphere } } `;var i_n=T(S(),1),LI=`void atmosphereStage(ProcessedAttributes attributes) { vec3 lightDirection = czm_getDynamicAtmosphereLightDirection(v_positionWC, czm_atmosphereDynamicLighting); czm_computeGroundAtmosphereScattering( // This assumes the geometry stage came before this. v_positionWC, lightDirection, v_atmosphereRayleighColor, v_atmosphereMieColor, v_atmosphereOpacity ); } `;var Hre={name:\"AtmospherePipelineStage\"};Hre.process=function(e,t,n){let i=e.shaderBuilder;i.addDefine(\"HAS_ATMOSPHERE\",void 0,Ce.BOTH),i.addDefine(\"COMPUTE_POSITION_WC_ATMOSPHERE\",void 0,Ce.BOTH),i.addVarying(\"vec3\",\"v_atmosphereRayleighColor\"),i.addVarying(\"vec3\",\"v_atmosphereMieColor\"),i.addVarying(\"float\",\"v_atmosphereOpacity\"),i.addVertexLines([LI]),i.addFragmentLines([VI]),i.addUniform(\"bool\",\"u_isInFog\",Ce.FRAGMENT),e.uniformMap.u_isInFog=function(){let o=h.distance(n.camera.positionWC,t.boundingSphere.center);return P.fog(o,n.fog.density)>P.EPSILON3}};var ZI=Hre;var x_n=T(S(),1);var m_n=T(S(),1),RI=`vec3 proceduralIBL( vec3 positionEC, vec3 normalEC, vec3 lightDirectionEC, vec3 lightColorHdr, czm_pbrParameters pbrParameters ) { vec3 v = -positionEC; vec3 positionWC = vec3(czm_inverseView * vec4(positionEC, 1.0)); vec3 vWC = -normalize(positionWC); vec3 l = normalize(lightDirectionEC); vec3 n = normalEC; vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n))); float NdotL = clamp(dot(n, l), 0.001, 1.0); float NdotV = abs(dot(n, v)) + 0.001; // Figure out if the reflection vector hits the ellipsoid float vertexRadius = length(positionWC); float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius); float reflectionDotNadir = dot(r, normalize(positionWC)); // Flipping the X vector is a cheap way to get the inverse of czm_temeToPseudoFixed, since that's a rotation about Z. r.x = -r.x; r = -normalize(czm_temeToPseudoFixed * r); r.x = -r.x; vec3 diffuseColor = pbrParameters.diffuseColor; float roughness = pbrParameters.roughness; vec3 specularColor = pbrParameters.f0; float inverseRoughness = 1.04 - roughness; inverseRoughness *= inverseRoughness; vec3 sceneSkyBox = czm_textureCube(czm_environmentMap, r).rgb * inverseRoughness; float atmosphereHeight = 0.05; float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir); float blendRegionOffset = roughness * -1.0; float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999); float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999); float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999); float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir); vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight); vec3 nadirColor = belowHorizonColor * 0.5; vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5); vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75); vec3 zenithColor = mix(blueSkyColor,"
}