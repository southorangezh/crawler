{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 32,
    "total_chunks": 194,
    "chunk_size": 5480,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.664Z"
  },
  "content": "et al 2014: http://jcgt.org/published/0003/02/01/ * * @name czm_octDecode * @param {vec2} encoded The oct-encoded, unit-length vector * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits. * @returns {vec3} The decoded and normalized vector */ vec3 czm_octDecode(vec2 encoded, float range) { if (encoded.x == 0.0 && encoded.y == 0.0) { return vec3(0.0, 0.0, 0.0); } encoded = encoded / range * 2.0 - 1.0; vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y)); if (v.z < 0.0) { v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy); } return normalize(v); } /** * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector. * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\", * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/ * * @name czm_octDecode * @param {vec2} encoded The oct-encoded, unit-length vector * @returns {vec3} The decoded and normalized vector */ vec3 czm_octDecode(vec2 encoded) { return czm_octDecode(encoded, 255.0); } /** * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector. * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\", * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/ * * @name czm_octDecode * @param {float} encoded The oct-encoded, unit-length vector * @returns {vec3} The decoded and normalized vector */ vec3 czm_octDecode(float encoded) { float temp = encoded / 256.0; float x = floor(temp); float y = (temp - x) * 256.0; return czm_octDecode(vec2(x, y)); } /** * Decodes three unit-length vectors in 'oct' encoding packed into two floating-point numbers to normalized 3-component Cartesian vectors. * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\", * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/ * * @name czm_octDecode * @param {vec2} encoded The packed oct-encoded, unit-length vectors. * @param {vec3} vector1 One decoded and normalized vector. * @param {vec3} vector2 One decoded and normalized vector. * @param {vec3} vector3 One decoded and normalized vector. */ void czm_octDecode(vec2 encoded, out vec3 vector1, out vec3 vector2, out vec3 vector3) { float temp = encoded.x / 65536.0; float x = floor(temp); float encodedFloat1 = (temp - x) * 65536.0; temp = encoded.y / 65536.0; float y = floor(temp); float encodedFloat2 = (temp - y) * 65536.0; vector1 = czm_octDecode(encodedFloat1); vector2 = czm_octDecode(encodedFloat2); vector3 = czm_octDecode(vec2(x, y)); } `;var vvt=T(S(),1),jR=`/** * Packs a depth value into a vec3 that can be represented by unsigned bytes. * * @name czm_packDepth * @glslFunction * * @param {float} depth The floating-point depth. * @returns {vec3} The packed depth. */ vec4 czm_packDepth(float depth) { // See Aras Pranckevi\\u010Dius' post Encoding Floats to RGBA // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/ vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth; enc = fract(enc); enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0); return enc; } `;var Fvt=T(S(),1),qR=`vec3 lambertianDiffuse(vec3 diffuseColor) { return diffuseColor / czm_pi; } vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) { return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0); } float smithVisibilityG1(float NdotV, float roughness) { // this is the k value for direct lighting. // for image based lighting it will be roughness^2 / 2 float k = (roughness + 1.0) * (roughness + 1.0) / 8.0; return NdotV / (NdotV * (1.0 - k) + k); } float smithVisibilityGGX(float roughness, float NdotL, float NdotV) { return ( smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness) ); } float GGX(float roughness, float NdotH) { float roughnessSquared = roughness * roughness; float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0; return roughnessSquared / (czm_pi * f * f); } /** * Compute the diffuse and specular contributions using physically based * rendering. This function only handles direct lighting. * <p> * This function only handles the lighting calculations. Metallic/roughness * and specular/glossy must be handled separately. See {@czm_pbrMetallicRoughnessMaterial}, {@czm_pbrSpecularGlossinessMaterial} and {@czm_defaultPbrMaterial} * </p> * * @name czm_pbrlighting * @glslFunction * * @param {vec3} positionEC The position of the fragment in eye coordinates * @param {vec3} normalEC The surface normal in eye coordinates * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates. * @param {vec3} lightColorHdr radiance of the light source. This is a HDR value. * @param {czm_pbrParameters} The computed PBR parameters. * @return {vec3} The computed HDR color * * @example * czm_pbrParameters pbrParameters = czm_pbrMetallicRoughnessMaterial( * baseColor, * metallic, * roughness * ); * vec3 color = czm_pbrlighting( * positionEC, * normalEC, * lightDirectionEC, * lightColorHdr, * pbrParameters); */ vec3 czm_pbrLighting( vec3 positionEC, vec3 normalEC, vec3 lightDirectionEC, vec3 lightColorHdr, czm_pbrParameters pbrParameters ) { vec3 v = -normalize(positionEC); vec3 l = normalize(lightDirectionEC); vec3 h = normalize(v + l); vec3 n = normalEC; float NdotL = clamp(dot(n, l), 0.001, 1.0); float NdotV = abs(dot(n, v)) +"
}