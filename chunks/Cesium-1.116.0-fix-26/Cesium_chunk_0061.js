{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 61,
    "total_chunks": 194,
    "chunk_size": 6167,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.682Z"
  },
  "content": "`;var H4t=T(S(),1),OE=`in vec3 position3DHigh; in vec3 position3DLow; in vec3 prevPosition3DHigh; in vec3 prevPosition3DLow; in vec3 nextPosition3DHigh; in vec3 nextPosition3DLow; in vec2 expandAndWidth; in vec4 color; in vec2 st; in float batchId; out vec4 v_color; // @uranus change \\u65B0\\u589E\\u53D8\\u91CF\\u7528\\u6765\\u8BA1\\u7B97\\u8FB9\\u7F18\\u6297\\u952F\\u9F7F out float v_aa_width; out float v_aa_out; out vec2 v_st; void main() { // @uranus change: \\u8BA1\\u7B97\\u5916\\u6269\\u53D8\\u91CF v_aa_out = 1.0 / czm_pixelRatio; // \\u7EBF\\u6BB5\\u9876\\u70B9\\u5916\\u6269\\u4E24\\u4E2A\\u50CF\\u7D20 float width_out = v_aa_out * 2.0; // @uranus change end float expandDir = expandAndWidth.x; // @uranus change \\u5BBD\\u5EA6\\u5916\\u6269 float width = abs(expandAndWidth.y) + 0.5 + width_out; bool usePrev = expandAndWidth.y < 0.0; vec4 p = czm_computePosition(); vec4 prev = czm_computePrevPosition(); vec4 next = czm_computeNextPosition(); float angle; vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle); gl_Position = czm_viewportOrthographic * positionWC; v_color = color; // @uranus change: \\u8BA1\\u7B97\\u5916\\u6269\\u53D8\\u91CF v_aa_width = width; v_st.s = st.s; v_st.t = czm_writeNonPerspective(st.t, gl_Position.w); // @uranus change end } `;var J4t=T(S(),1),dd=`void clipLineSegmentToNearPlane( vec3 p0, vec3 p1, out vec4 positionWC, out bool clipped, out bool culledByNearPlane, out vec4 clippedPositionEC) { culledByNearPlane = false; clipped = false; vec3 p0ToP1 = p1 - p0; float magnitude = length(p0ToP1); vec3 direction = normalize(p0ToP1); // Distance that p0 is behind the near plane. Negative means p0 is // in front of the near plane. float endPoint0Distance = czm_currentFrustum.x + p0.z; // Camera looks down -Z. // When moving a point along +Z: LESS VISIBLE // * Points in front of the camera move closer to the camera. // * Points behind the camrea move farther away from the camera. // When moving a point along -Z: MORE VISIBLE // * Points in front of the camera move farther away from the camera. // * Points behind the camera move closer to the camera. // Positive denominator: -Z, becoming more visible // Negative denominator: +Z, becoming less visible // Nearly zero: parallel to near plane float denominator = -direction.z; if (endPoint0Distance > 0.0 && abs(denominator) < czm_epsilon7) { // p0 is behind the near plane and the line to p1 is nearly parallel to // the near plane, so cull the segment completely. culledByNearPlane = true; } else if (endPoint0Distance > 0.0) { // p0 is behind the near plane, and the line to p1 is moving distinctly // toward or away from it. // t = (-plane distance - dot(plane normal, ray origin)) / dot(plane normal, ray direction) float t = endPoint0Distance / denominator; if (t < 0.0 || t > magnitude) { // Near plane intersection is not between the two points. // We already confirmed p0 is behind the naer plane, so now // we know the entire segment is behind it. culledByNearPlane = true; } else { // Segment crosses the near plane, update p0 to lie exactly on it. p0 = p0 + t * direction; // Numerical noise might put us a bit on the wrong side of the near plane. // Don't let that happen. p0.z = min(p0.z, -czm_currentFrustum.x); clipped = true; } } clippedPositionEC = vec4(p0, 1.0); positionWC = czm_eyeToWindowCoordinates(clippedPositionEC); } vec4 getPolylineWindowCoordinatesEC(vec4 positionEC, vec4 prevEC, vec4 nextEC, float expandDirection, float width, bool usePrevious, out float angle) { // expandDirection +1 is to the _left_ when looking from positionEC toward nextEC. #ifdef POLYLINE_DASH // Compute the window coordinates of the points. vec4 positionWindow = czm_eyeToWindowCoordinates(positionEC); vec4 previousWindow = czm_eyeToWindowCoordinates(prevEC); vec4 nextWindow = czm_eyeToWindowCoordinates(nextEC); // Determine the relative screen space direction of the line. vec2 lineDir; if (usePrevious) { lineDir = normalize(positionWindow.xy - previousWindow.xy); } else { lineDir = normalize(nextWindow.xy - positionWindow.xy); } angle = atan(lineDir.x, lineDir.y) - 1.570796327; // precomputed atan(1,0) // Quantize the angle so it doesn't change rapidly between segments. angle = floor(angle / czm_piOverFour + 0.5) * czm_piOverFour; #endif vec4 clippedPrevWC, clippedPrevEC; bool prevSegmentClipped, prevSegmentCulled; clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC); vec4 clippedNextWC, clippedNextEC; bool nextSegmentClipped, nextSegmentCulled; clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC); bool segmentClipped, segmentCulled; vec4 clippedPositionWC, clippedPositionEC; clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, clippedPositionWC, segmentClipped, segmentCulled, clippedPositionEC); if (segmentCulled) { return vec4(0.0, 0.0, 0.0, 1.0); } vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy); vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy); // If a segment was culled, we can't use the corresponding direction // computed above. We should never see both of these be true without // \\`segmentCulled\\` above also being true. if (prevSegmentCulled) { directionToPrevWC = -directionToNextWC; } else if (nextSegmentCulled) { directionToNextWC = -directionToPrevWC; } vec2 thisSegmentForwardWC, otherSegmentForwardWC; if (usePrevious) { thisSegmentForwardWC = -directionToPrevWC; otherSegmentForwardWC = directionToNextWC; } else { thisSegmentForwardWC = directionToNextWC; otherSegmentForwardWC = -directionToPrevWC; } vec2 thisSegmentLeftWC = vec2(-thisSegmentForwardWC.y, thisSegmentForwardWC.x); vec2 leftWC = thisSegmentLeftWC; float expandWidth = width * 0.5; // When lines are split at the anti-meridian, the position may be at the // same location as the next or previous position, and we need to handle // that to avoid producing NaNs. if (!czm_equalsEpsilon(prevEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1) && !czm_equalsEpsilon(nextEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1)) {"
}