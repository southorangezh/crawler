{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 31,
    "total_chunks": 194,
    "chunk_size": 5599,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.663Z"
  },
  "content": "= czm_viewport.w; float pixelWidth; float pixelHeight; float top = czm_frustumPlanes.x; float bottom = czm_frustumPlanes.y; float left = czm_frustumPlanes.z; float right = czm_frustumPlanes.w; if (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0) { float frustumWidth = right - left; float frustumHeight = top - bottom; pixelWidth = frustumWidth / width; pixelHeight = frustumHeight / height; } else { float distanceToPixel = -positionEC.z; float inverseNear = 1.0 / czm_currentFrustum.x; float tanTheta = top * inverseNear; pixelHeight = 2.0 * distanceToPixel * tanTheta / height; tanTheta = right * inverseNear; pixelWidth = 2.0 * distanceToPixel * tanTheta / width; } return max(pixelWidth, pixelHeight) * pixelRatio; } /** * Computes the size of a pixel in meters at a distance from the eye. * <p> * Use this version when scaling by pixel ratio. * </p> * @name czm_metersPerPixel * @glslFunction * * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates. * * @returns {float} The meters per pixel at positionEC. */ float czm_metersPerPixel(vec4 positionEC) { return czm_metersPerPixel(positionEC, czm_pixelRatio); } `;var Zvt=T(S(),1),HR=`/** * Transforms a position from model to window coordinates. The transformation * from model to clip coordinates is done using {@link czm_modelViewProjection}. * The transform from normalized device coordinates to window coordinates is * done using {@link czm_viewportTransformation}, which assumes a depth range * of <code>near = 0</code> and <code>far = 1</code>. * <br /><br /> * This transform is useful when there is a need to manipulate window coordinates * in a vertex shader as done by {@link BillboardCollection}. * <br /><br /> * This function should not be confused with {@link czm_viewportOrthographic}, * which is an orthographic projection matrix that transforms from window * coordinates to clip coordinates. * * @name czm_modelToWindowCoordinates * @glslFunction * * @param {vec4} position The position in model coordinates to transform. * * @returns {vec4} The transformed position in window coordinates. * * @see czm_eyeToWindowCoordinates * @see czm_modelViewProjection * @see czm_viewportTransformation * @see czm_viewportOrthographic * @see BillboardCollection * * @example * vec4 positionWC = czm_modelToWindowCoordinates(positionMC); */ vec4 czm_modelToWindowCoordinates(vec4 position) { vec4 q = czm_modelViewProjection * position; // clip coordinates q.xyz /= q.w; // normalized device coordinates q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates return q; } `;var Gvt=T(S(),1),KR=`/** * DOC_TBA * * @name czm_multiplyWithColorBalance * @glslFunction */ vec3 czm_multiplyWithColorBalance(vec3 left, vec3 right) { // Algorithm from Chapter 10 of Graphics Shaders. const vec3 W = vec3(0.2125, 0.7154, 0.0721); vec3 target = left * right; float leftLuminance = dot(left, W); float rightLuminance = dot(right, W); float targetLuminance = dot(target, W); return ((leftLuminance + rightLuminance) / (2.0 * targetLuminance)) * target; } `;var Xvt=T(S(),1),JR=`/** * Computes a value that scales with distance. The scaling is clamped at the near and * far distances, and does not extrapolate. This function works with the * {@link NearFarScalar} JavaScript class. * * @name czm_nearFarScalar * @glslFunction * * @param {vec4} nearFarScalar A vector with 4 components: Near distance (x), Near value (y), Far distance (z), Far value (w). * @param {float} cameraDistSq The square of the current distance from the camera. * * @returns {float} The value at this distance. */ float czm_nearFarScalar(vec4 nearFarScalar, float cameraDistSq) { float valueAtMin = nearFarScalar.y; float valueAtMax = nearFarScalar.w; float nearDistanceSq = nearFarScalar.x * nearFarScalar.x; float farDistanceSq = nearFarScalar.z * nearFarScalar.z; float t = (cameraDistSq - nearDistanceSq) / (farDistanceSq - nearDistanceSq); t = pow(clamp(t, 0.0, 1.0), 0.2); return mix(valueAtMin, valueAtMax, t); } `;var Wvt=T(S(),1),QR=` /** * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector. * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\", * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/ * * @name czm_octDecode * @param {vec2} encoded The oct-encoded, unit-length vector * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits. * @returns {vec3} The decoded and normalized vector */ vec3 czm_octDecode(vec2 encoded, float range) { if (encoded.x == 0.0 && encoded.y == 0.0) { return vec3(0.0, 0.0, 0.0); } encoded = encoded / range * 2.0 - 1.0; vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y)); if (v.z < 0.0) { v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy); } return normalize(v); } /** * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector. * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\", * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/ * * @name czm_octDecode * @param {vec2} encoded The oct-encoded, unit-length vector * @returns {vec3} The decoded and normalized vector */ vec3 czm_octDecode(vec2 encoded) { return czm_octDecode(encoded, 255.0); } /** * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector. * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit"
}