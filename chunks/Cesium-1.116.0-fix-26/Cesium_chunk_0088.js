{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 88,
    "total_chunks": 194,
    "chunk_size": 22140,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.697Z"
  },
  "content": "u_emissiveTextureTransform); #endif vec3 emissive = czm_srgbToLinear(texture(u_emissiveTexture, emissiveTexCoords).rgb); #ifdef HAS_EMISSIVE_FACTOR emissive *= u_emissiveFactor; #endif material.emissive = emissive; #elif defined(HAS_EMISSIVE_FACTOR) material.emissive = u_emissiveFactor; #endif #if defined(LIGHTING_PBR) && defined(USE_SPECULAR_GLOSSINESS) #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE vec2 specularGlossinessTexCoords = TEXCOORD_SPECULAR_GLOSSINESS; #ifdef HAS_SPECULAR_GLOSSINESS_TEXTURE_TRANSFORM specularGlossinessTexCoords = computeTextureTransform(specularGlossinessTexCoords, u_specularGlossinessTextureTransform); #endif vec4 specularGlossiness = czm_srgbToLinear(texture(u_specularGlossinessTexture, specularGlossinessTexCoords)); vec3 specular = specularGlossiness.rgb; float glossiness = specularGlossiness.a; #ifdef HAS_SPECULAR_FACTOR specular *= u_specularFactor; #endif #ifdef HAS_GLOSSINESS_FACTOR glossiness *= u_glossinessFactor; #endif #else #ifdef HAS_SPECULAR_FACTOR vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0)); #else vec3 specular = vec3(1.0); #endif #ifdef HAS_GLOSSINESS_FACTOR float glossiness = clamp(u_glossinessFactor, 0.0, 1.0); #else float glossiness = 1.0; #endif #endif #ifdef HAS_DIFFUSE_TEXTURE vec2 diffuseTexCoords = TEXCOORD_DIFFUSE; #ifdef HAS_DIFFUSE_TEXTURE_TRANSFORM diffuseTexCoords = computeTextureTransform(diffuseTexCoords, u_diffuseTextureTransform); #endif vec4 diffuse = czm_srgbToLinear(texture(u_diffuseTexture, diffuseTexCoords)); #ifdef HAS_DIFFUSE_FACTOR diffuse *= u_diffuseFactor; #endif #elif defined(HAS_DIFFUSE_FACTOR) vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0)); #else vec4 diffuse = vec4(1.0); #endif czm_pbrParameters parameters = czm_pbrSpecularGlossinessMaterial( diffuse.rgb, specular, glossiness ); material.diffuse = parameters.diffuseColor; // the specular glossiness extension's alpha overrides anything set // by the base material. material.alpha = diffuse.a; material.specular = parameters.f0; material.roughness = parameters.roughness; #elif defined(LIGHTING_PBR) #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE vec2 metallicRoughnessTexCoords = TEXCOORD_METALLIC_ROUGHNESS; #ifdef HAS_METALLIC_ROUGHNESS_TEXTURE_TRANSFORM metallicRoughnessTexCoords = computeTextureTransform(metallicRoughnessTexCoords, u_metallicRoughnessTextureTransform); #endif vec3 metallicRoughness = texture(u_metallicRoughnessTexture, metallicRoughnessTexCoords).rgb; float metalness = clamp(metallicRoughness.b, 0.0, 1.0); float roughness = clamp(metallicRoughness.g, 0.04, 1.0); #ifdef HAS_METALLIC_FACTOR metalness *= u_metallicFactor; #endif #ifdef HAS_ROUGHNESS_FACTOR roughness *= u_roughnessFactor; #endif #else #ifdef HAS_METALLIC_FACTOR float metalness = clamp(u_metallicFactor, 0.0, 1.0); #else float metalness = 1.0; #endif #ifdef HAS_ROUGHNESS_FACTOR float roughness = clamp(u_roughnessFactor, 0.04, 1.0); #else float roughness = 1.0; #endif #endif czm_pbrParameters parameters = czm_pbrMetallicRoughnessMaterial( material.diffuse, metalness, roughness ); material.diffuse = parameters.diffuseColor; material.specular = parameters.f0; material.roughness = parameters.roughness; #endif } `;var RDe=Nt.Material,Kz=Nt.MetallicRoughness,Jz=Nt.SpecularGlossiness,Zse={name:\"MaterialPipelineStage\",_processTexture:py,_processTextureTransform:Rse};Zse.process=function(e,t,n){let i=t.material,o=e.model,r=l(o.classificationType),s=r,a=e.uniformMap,c=e.shaderBuilder,d=n.context.defaultTexture,u=n.context.defaultNormalTexture,m=n.context.defaultEmissiveTexture;GDe(i,a,c,d,u,m,s),l(i.specularGlossiness)?EDe(i,a,c,d,s):XDe(i,a,c,d,s);let p=qt.getAttributeBySemantic(t,St.NORMAL),b=e.lightingOptions;i.unlit||!p||r?b.lightingModel=lf.UNLIT:b.lightingModel=lf.PBR;let f=o.backFaceCulling&&!i.doubleSided;e.renderStateOptions.cull.enabled=f;let x=e.alphaOptions;i.alphaMode===af.BLEND?x.pass=Ze.TRANSLUCENT:i.alphaMode===af.MASK&&(x.alphaCutoff=i.alphaCutoff),c.addFragmentLines(dW),i.doubleSided&&c.addDefine(\"HAS_DOUBLE_SIDED_MATERIAL\",void 0,Ce.BOTH)};function Rse(e,t,n,i,o){let r=`HAS_${o}_TEXTURE_TRANSFORM`;e.addDefine(r,void 0,Ce.FRAGMENT);let s=`${i}Transform`;e.addUniform(\"mat3\",s,Ce.FRAGMENT),t[s]=function(){return n.transform}}function py(e,t,n,i,o,r){e.addUniform(\"sampler2D\",i,Ce.FRAGMENT),t[i]=function(){return g(n.texture,r)};let s=`HAS_${o}_TEXTURE`;e.addDefine(s,void 0,Ce.FRAGMENT);let c=`v_texCoord_${n.texCoord}`,d=`TEXCOORD_${o}`;e.addDefine(d,c,Ce.FRAGMENT);let u=n.transform;l(u)&&!$.equals(u,$.IDENTITY)&&Rse(e,t,n,i,o)}function GDe(e,t,n,i,o,r,s){let a=e.emissiveFactor;if(l(a)&&!h.equals(a,RDe.DEFAULT_EMISSIVE_FACTOR)){n.addUniform(\"vec3\",\"u_emissiveFactor\",Ce.FRAGMENT),t.u_emissiveFactor=function(){return e.emissiveFactor},n.addDefine(\"HAS_EMISSIVE_FACTOR\",void 0,Ce.FRAGMENT);let u=e.emissiveTexture;l(u)&&!s&&py(n,t,u,\"u_emissiveTexture\",\"EMISSIVE\",r)}let c=e.normalTexture;l(c)&&!s&&py(n,t,c,\"u_normalTexture\",\"NORMAL\",o);let d=e.occlusionTexture;l(d)&&!s&&py(n,t,d,\"u_occlusionTexture\",\"OCCLUSION\",i)}function EDe(e,t,n,i,o){let r=e.specularGlossiness;n.addDefine(\"USE_SPECULAR_GLOSSINESS\",void 0,Ce.FRAGMENT);let s=r.diffuseTexture;l(s)&&!o&&py(n,t,s,\"u_diffuseTexture\",\"DIFFUSE\",i);let a=r.diffuseFactor;l(a)&&!se.equals(a,Jz.DEFAULT_DIFFUSE_FACTOR)&&(n.addUniform(\"vec4\",\"u_diffuseFactor\",Ce.FRAGMENT),t.u_diffuseFactor=function(){return r.diffuseFactor},n.addDefine(\"HAS_DIFFUSE_FACTOR\",void 0,Ce.FRAGMENT));let c=r.specularGlossinessTexture;l(c)&&!o&&py(n,t,c,\"u_specularGlossinessTexture\",\"SPECULAR_GLOSSINESS\",i);let d=r.specularFactor;l(d)&&!h.equals(d,Jz.DEFAULT_SPECULAR_FACTOR)&&(n.addUniform(\"vec3\",\"u_specularFactor\",Ce.FRAGMENT),t.u_specularFactor=function(){return r.specularFactor},n.addDefine(\"HAS_SPECULAR_FACTOR\",void 0,Ce.FRAGMENT));let u=r.glossinessFactor;l(u)&&u!==Jz.DEFAULT_GLOSSINESS_FACTOR&&(n.addUniform(\"float\",\"u_glossinessFactor\",Ce.FRAGMENT),t.u_glossinessFactor=function(){return r.glossinessFactor},n.addDefine(\"HAS_GLOSSINESS_FACTOR\",void 0,Ce.FRAGMENT))}function XDe(e,t,n,i,o){let r=e.metallicRoughness;n.addDefine(\"USE_METALLIC_ROUGHNESS\",void 0,Ce.FRAGMENT);let s=r.baseColorTexture;l(s)&&!o&&py(n,t,s,\"u_baseColorTexture\",\"BASE_COLOR\",i);let a=r.baseColorFactor;l(a)&&!se.equals(a,Kz.DEFAULT_BASE_COLOR_FACTOR)&&(n.addUniform(\"vec4\",\"u_baseColorFactor\",Ce.FRAGMENT),t.u_baseColorFactor=function(){return r.baseColorFactor},n.addDefine(\"HAS_BASE_COLOR_FACTOR\",void 0,Ce.FRAGMENT));let c=r.metallicRoughnessTexture;l(c)&&!o&&py(n,t,c,\"u_metallicRoughnessTexture\",\"METALLIC_ROUGHNESS\",i);let d=r.metallicFactor;l(d)&&d!==Kz.DEFAULT_METALLIC_FACTOR&&(n.addUniform(\"float\",\"u_metallicFactor\",Ce.FRAGMENT),t.u_metallicFactor=function(){return r.metallicFactor},n.addDefine(\"HAS_METALLIC_FACTOR\",void 0,Ce.FRAGMENT));let u=r.roughnessFactor;l(u)&&u!==Kz.DEFAULT_ROUGHNESS_FACTOR&&(n.addUniform(\"float\",\"u_roughnessFactor\",Ce.FRAGMENT),t.u_roughnessFactor=function(){return r.roughnessFactor},n.addDefine(\"HAS_ROUGHNESS_FACTOR\",void 0,Ce.FRAGMENT))}var uW=Zse;var D1n=T(S(),1);var v1n=T(S(),1),mW=`void morphTargetsStage(inout ProcessedAttributes attributes) { vec3 positionMC = attributes.positionMC; attributes.positionMC = getMorphedPosition(positionMC); #ifdef HAS_NORMALS vec3 normalMC = attributes.normalMC; attributes.normalMC = getMorphedNormal(normalMC); #endif #ifdef HAS_TANGENTS vec3 tangentMC = attributes.tangentMC; attributes.tangentMC = getMorphedTangent(tangentMC); #endif }`;var Wa={name:\"MorphTargetsPipelineStage\",FUNCTION_ID_GET_MORPHED_POSITION:\"getMorphedPosition\",FUNCTION_SIGNATURE_GET_MORPHED_POSITION:\"vec3 getMorphedPosition(in vec3 position)\",FUNCTION_ID_GET_MORPHED_NORMAL:\"getMorphedNormal\",FUNCTION_SIGNATURE_GET_MORPHED_NORMAL:\"vec3 getMorphedNormal(in vec3 normal)\",FUNCTION_ID_GET_MORPHED_TANGENT:\"getMorphedTangent\",FUNCTION_SIGNATURE_GET_MORPHED_TANGENT:\"vec3 getMorphedTangent(in vec3 tangent)\"};Wa.process=function(e,t){let n=e.shaderBuilder;n.addDefine(\"HAS_MORPH_TARGETS\",void 0,Ce.VERTEX),FDe(n);let i=t.morphTargets.length;for(let a=0;a<i;a++){let c=t.morphTargets[a].attributes,d=c.length;for(let u=0;u<d;u++){let m=c[u],p=m.semantic;p!==St.POSITION&&p!==St.NORMAL&&p!==St.TANGENT||(WDe(e,m,e.attributeIndex,a),e.attributeIndex++)}}ADe(n);let r=e.runtimeNode.morphWeights.length;n.addUniform(\"float\",`u_morphWeights[${r}]`,Ce.VERTEX),n.addVertexLines(mW);let s={u_morphWeights:function(){return e.runtimeNode.morphWeights}};e.uniformMap=Ct(s,e.uniformMap)};var IDe={attributeString:void 0,functionId:void 0};function WDe(e,t,n,i){let o=e.shaderBuilder;PDe(e,t,n);let r=vDe(t,IDe);wDe(o,r,i)}function PDe(e,t,n){let i={index:n,value:l(t.buffer)?void 0:t.constant,vertexBuffer:t.buffer,componentsPerAttribute:tn.getNumberOfComponents(t.type),componentDatatype:t.componentDatatype,offsetInBytes:t.byteOffset,strideInBytes:t.byteStride,normalize:t.normalized};e.attributes.push(i)}function vDe(e,t){switch(e.semantic){case St.POSITION:t.attributeString=\"Position\",t.functionId=Wa.FUNCTION_ID_GET_MORPHED_POSITION;break;case St.NORMAL:t.attributeString=\"Normal\",t.functionId=Wa.FUNCTION_ID_GET_MORPHED_NORMAL;break;case St.TANGENT:t.attributeString=\"Tangent\",t.functionId=Wa.FUNCTION_ID_GET_MORPHED_TANGENT;break;default:break}return t}function wDe(e,t,n){let i=t.attributeString,o=`a_target${i}_${n}`,r=`morphed${i} += u_morphWeights[${n}] * a_target${i}_${n};`;e.addAttribute(\"vec3\",o),e.addFunctionLines(t.functionId,[r])}function FDe(e){e.addFunction(Wa.FUNCTION_ID_GET_MORPHED_POSITION,Wa.FUNCTION_SIGNATURE_GET_MORPHED_POSITION,Ce.VERTEX),e.addFunctionLines(Wa.FUNCTION_ID_GET_MORPHED_POSITION,[\"vec3 morphedPosition = position;\"]),e.addFunction(Wa.FUNCTION_ID_GET_MORPHED_NORMAL,Wa.FUNCTION_SIGNATURE_GET_MORPHED_NORMAL,Ce.VERTEX),e.addFunctionLines(Wa.FUNCTION_ID_GET_MORPHED_NORMAL,[\"vec3 morphedNormal = normal;\"]),e.addFunction(Wa.FUNCTION_ID_GET_MORPHED_TANGENT,Wa.FUNCTION_SIGNATURE_GET_MORPHED_TANGENT,Ce.VERTEX),e.addFunctionLines(Wa.FUNCTION_ID_GET_MORPHED_TANGENT,[\"vec3 morphedTangent = tangent;\"])}function ADe(e){e.addFunctionLines(Wa.FUNCTION_ID_GET_MORPHED_POSITION,[\"return morphedPosition;\"]),e.addFunctionLines(Wa.FUNCTION_ID_GET_MORPHED_NORMAL,[\"return morphedNormal;\"]),e.addFunctionLines(Wa.FUNCTION_ID_GET_MORPHED_TANGENT,[\"return morphedTangent;\"])}var hW=Wa;var $1n=T(S(),1);var Gse={name:\"PickingPipelineStage\"};Gse.process=function(e,t,n){let i=n.context,o=e.runtimeNode,r=e.shaderBuilder,s=e.model,a=o.node.instances;if(e.hasPropertyTable)MDe(e,t,a,i);else if(l(a))NDe(e,i);else{let c=Ese(e),d=i.createPickId(c);s._pipelineResources.push(d),s._pickIds.push(d),r.addUniform(\"vec4\",\"czm_pickColor\",Ce.FRAGMENT);let u=e.uniformMap;u.czm_pickColor=function(){return d.color},e.pickId=\"czm_pickColor\"}};function Ese(e,t){let n=e.model;if(l(n.pickObject))return n.pickObject;let i={model:n,node:e.runtimeNode,primitive:e.runtimePrimitive},o;if(rr.is3DTiles(n.type)){let r=n.content;o={content:r,primitive:r.tileset,detail:i}}else o={primitive:n,detail:i};return o.id=n.id,l(t)&&(o.instanceId=t),o}function MDe(e,t,n){let i=e.model,o,r,s=i.featureIdLabel,a=i.instanceFeatureIdLabel;l(i.featureTableId)?o=i.featureTableId:l(n)?(r=qt.getFeatureIdsByLabel(n.featureIds,a),o=r.propertyTableId):(r=qt.getFeatureIdsByLabel(t.featureIds,s),o=r.propertyTableId);let c=i.featureTables[o];e.shaderBuilder.addUniform(\"sampler2D\",\"model_pickTexture\",Ce.FRAGMENT);let u=c.batchTexture;e.uniformMap.model_pickTexture=function(){return g(u.pickTexture,u.defaultTexture)},e.pickId=\"((selectedFeature.id < int(model_featuresLength)) ? texture(model_pickTexture, selectedFeature.st) : vec4(0.0))\"}function NDe(e,t){let n=e.instanceCount,i=new Array(n),o=new Uint8Array(n*4),r=e.model,s=r._pipelineResources;for(let m=0;m<n;m++){let p=Ese(e,m),b=t.createPickId(p);s.push(b),i[m]=b;let f=b.color;o[m*4+0]=O.floatToByte(f.red),o[m*4+1]=O.floatToByte(f.green),o[m*4+2]=O.floatToByte(f.blue),o[m*4+3]=O.floatToByte(f.alpha)}r._pickIds=i;let a=pt.createVertexBuffer({context:t,typedArray:o,usage:Me.STATIC_DRAW});a.vertexArrayDestroyable=!1,r.statistics.addBuffer(a,!1),s.push(a);let d={index:e.attributeIndex++,vertexBuffer:a,componentsPerAttribute:4,componentDatatype:Q.UNSIGNED_BYTE,normalize:!0,offsetInBytes:0,strideInBytes:0,instanceDivisor:1};e.attributes.push(d);let u=e.shaderBuilder;u.addDefine(\"USE_PICKING\",void 0,Ce.BOTH),u.addAttribute(\"vec4\",\"a_pickColor\"),u.addVarying(\"vec4\",\"v_pickColor\"),e.pickId=\"v_pickColor\"}var fW=Gse;var SVn=T(S(),1);var tVn=T(S(),1),kDe={ADD:0,REPLACE:1},vo=Object.freeze(kDe);var iVn=T(S(),1),pW=`float getPointSizeFromAttenuation(vec3 positionEC) { // Variables are packed into a single vector to minimize gl.uniformXXX() calls float pointSize = model_pointCloudParameters.x; float geometricError = model_pointCloudParameters.y; float depthMultiplier = model_pointCloudParameters.z; float depth = -positionEC.z; float minimumPointSize = model_pointCloudParameters1; return round(clamp((geometricError / depth) * depthMultiplier, minimumPointSize, pointSize)); } #ifdef HAS_POINT_CLOUD_SHOW_STYLE float pointCloudShowStylingStage(in ProcessedAttributes attributes, in Metadata metadata) { float tiles3d_tileset_time = model_pointCloudParameters.w; return float(getShowFromStyle(attributes, metadata, tiles3d_tileset_time)); } #endif #ifdef HAS_POINT_CLOUD_COLOR_STYLE vec4 pointCloudColorStylingStage(in ProcessedAttributes attributes, in Metadata metadata) { float tiles3d_tileset_time = model_pointCloudParameters.w; return getColorFromStyle(attributes, metadata, tiles3d_tileset_time); } #endif #ifdef HAS_POINT_CLOUD_POINT_SIZE_STYLE float pointCloudPointSizeStylingStage(in ProcessedAttributes attributes, in Metadata metadata) { float tiles3d_tileset_time = model_pointCloudParameters.w; return float(getPointSizeFromStyle(attributes, metadata, tiles3d_tileset_time)); } #elif defined(HAS_POINT_CLOUD_ATTENUATION) float pointCloudPointSizeStylingStage(in ProcessedAttributes attributes, in Metadata metadata) { return getPointSizeFromAttenuation(v_positionEC); } #endif #ifdef HAS_POINT_CLOUD_BACK_FACE_CULLING float pointCloudBackFaceCullingStage() { #if defined(HAS_NORMALS) && !defined(HAS_DOUBLE_SIDED_MATERIAL) // This needs to be computed in eye coordinates so we can't use attributes.normalMC return step(-v_normalEC.z, 0.0); #else return 1.0; #endif } #endif `;var UDe=new se,Ise={name:\"PointCloudStylingPipelineStage\"};Ise.process=function(e,t,n){let i=e.shaderBuilder,o=e.model,r=o.style,s=o.structuralMetadata,a=l(s)?s.propertyAttributes:void 0,c=l(o.featureTableId)&&o.featureTables[o.featureTableId].featuresLength>0,d=!l(a)&&c;if(l(r)&&!d){let x=ODe(a),_=zDe(r,x);HDe(i,_);let V=KDe(_).indexOf(\"normalMC\")>=0,L=qt.getAttributeBySemantic(t,St.NORMAL);if(V&&!L)throw new ue(\"Style references the NORMAL semantic but the point cloud does not have normals\");i.addDefine(\"COMPUTE_POSITION_WC_STYLE\",void 0,Ce.VERTEX),_.styleTranslucent&&(e.alphaOptions.pass=Ze.TRANSLUCENT)}let u=o.pointCloudShading;u.attenuation&&i.addDefine(\"HAS_POINT_CLOUD_ATTENUATION\",void 0,Ce.VERTEX),u.backFaceCulling&&i.addDefine(\"HAS_POINT_CLOUD_BACK_FACE_CULLING\",void 0,Ce.VERTEX);let m,p,b;rr.is3DTiles(o.type)&&(p=!0,m=o.content,b=m.tile.refine===vo.ADD),i.addUniform(\"vec4\",\"model_pointCloudParameters\",Ce.VERTEX),i.addVertexLines(pW);let f=e.uniformMap;f.model_pointCloudParameters=function(){let x=UDe,_=1;p&&(_=b?5:m.tileset.memoryAdjustedScreenSpaceError),x.x=g(u.maximumAttenuation,_),x.x*=n.pixelRatio;let C=DDe(e,t,u,m);x.y=C*u.geometricErrorScale;let V=n.context,L=n.camera.frustum,R;return n.mode===ie.SCENE2D||L instanceof rn?R=Number.POSITIVE_INFINITY:R=V.drawingBufferHeight/n.camera.frustum.sseDenominator,x.z=R,p&&(x.w=m.tileset.timeSinceLoad),x},i.addUniform(\"float\",\"model_pointCloudParameters1\",Ce.VERTEX),f.model_pointCloudParameters1=function(){let _=g(u.minimumPointSize,1);return _*=n.pixelRatio,_}};var Xse=new h;function DDe(e,t,n,i){if(!n.ignoreGeometricError&&l(i)){let u=i.tile.geometricError;if(u>0)return u}if(l(n.baseResolution))return n.baseResolution;let o=qt.getAttributeBySemantic(t,St.POSITION),r=o.count,s=e.runtimeNode.transform,a=h.subtract(o.max,o.min,Xse);a=M.multiplyByPointAsVector(s,a,Xse);let c=a.x*a.y*a.z;return P.cbrt(c/r)}var BDe={colorStyleFunction:void 0,showStyleFunction:void 0,pointSizeStyleFunction:void 0,styleTranslucent:!1},YDe={POSITION:\"attributes.positionMC\",POSITION_ABSOLUTE:\"v_positionWC\",COLOR:\"attributes.color_0\",NORMAL:\"attributes.normalMC\"};function ODe(e){let t=Oe(YDe);if(!l(e))return t;for(let n=0;n<e.length;n++){let o=e[n].properties;for(let r in o)o.hasOwnProperty(r)&&(t[r]=`metadata.${r}`)}return t}var Qz=\"ProcessedAttributes attributes, Metadata metadata, float tiles3d_tileset_time\";function zDe(e,t){let n=BDe,i={translucent:!1};return n.colorStyleFunction=e.getColorShaderFunction(`getColorFromStyle(${Qz})`,t,i),n.showStyleFunction=e.getShowShaderFunction(`getShowFromStyle(${Qz})`,t,i),n.pointSizeStyleFunction=e.getPointSizeShaderFunction(`getPointSizeFromStyle(${Qz})`,t,i),n.styleTranslucent=l(n.colorStyleFunction)&&i.translucent,n}function HDe(e,t){let n=t.colorStyleFunction;l(n)&&(e.addDefine(\"HAS_POINT_CLOUD_COLOR_STYLE\",void 0,Ce.BOTH),e.addVertexLines(n),e.addVarying(\"vec4\",\"v_pointCloudColor\"));let i=t.showStyleFunction;l(i)&&(e.addDefine(\"HAS_POINT_CLOUD_SHOW_STYLE\",void 0,Ce.VERTEX),e.addVertexLines(i));let o=t.pointSizeStyleFunction;l(o)&&(e.addDefine(\"HAS_POINT_CLOUD_POINT_SIZE_STYLE\",void 0,Ce.VERTEX),e.addVertexLines(o))}function jz(e,t){let n=/attributes\\.(\\w+)/g,i=n.exec(e);for(;i!==null;){let o=i[1];t.indexOf(o)===-1&&t.push(o),i=n.exec(e)}}function KDe(e){let t=e.colorStyleFunction,n=e.showStyleFunction,i=e.pointSizeStyleFunction,o=[];return l(t)&&jz(t,o),l(n)&&jz(n,o),l(i)&&jz(i,o),o}var bW=Ise;var PVn=T(S(),1);var VVn=T(S(),1),yW=`void primitiveOutlineStage() { v_outlineCoordinates = a_outlineCoordinates; } `;var ZVn=T(S(),1),gW=`void primitiveOutlineStage(inout czm_modelMaterial material) { if (!model_showOutline) { return; } float outlineX = texture(model_outlineTexture, vec2(v_outlineCoordinates.x, 0.5)).r; float outlineY = texture(model_outlineTexture, vec2(v_outlineCoordinates.y, 0.5)).r; float outlineZ = texture(model_outlineTexture, vec2(v_outlineCoordinates.z, 0.5)).r; float outlineness = max(outlineX, max(outlineY, outlineZ)); material.diffuse = mix(material.diffuse, model_outlineColor.rgb, model_outlineColor.a * outlineness); } `;var Wse={name:\"PrimitiveOutlinePipelineStage\"};Wse.process=function(e,t,n){let i=e.shaderBuilder,o=e.uniformMap;i.addDefine(\"HAS_PRIMITIVE_OUTLINE\",void 0,Ce.BOTH),i.addAttribute(\"vec3\",\"a_outlineCoordinates\"),i.addVarying(\"vec3\",\"v_outlineCoordinates\");let r=t.outlineCoordinates,s={index:e.attributeIndex++,vertexBuffer:r.buffer,componentsPerAttribute:tn.getNumberOfComponents(r.type),componentDatatype:r.componentDatatype,offsetInBytes:r.byteOffset,strideInBytes:r.byteStride,normalize:r.normalized};e.attributes.push(s),i.addUniform(\"sampler2D\",\"model_outlineTexture\",Ce.FRAGMENT);let a=s_.createTexture(n.context);o.model_outlineTexture=function(){return a};let c=e.model;i.addUniform(\"vec4\",\"model_outlineColor\",Ce.FRAGMENT),o.model_outlineColor=function(){return c.outlineColor},i.addUniform(\"bool\",\"model_showOutline\",Ce.FRAGMENT),o.model_showOutline=function(){return c.showOutline},i.addVertexLines(yW),i.addFragmentLines(gW)};var xW=Wse;var NVn=T(S(),1);var Pse={name:\"PrimitiveStatisticsPipelineStage\",_countGeometry:vse,_count2DPositions:wse,_countMorphTargetAttributes:Fse,_countMaterialTextures:Ase,_countFeatureIdTextures:Mse,_countBinaryMetadata:Nse};Pse.process=function(e,t,n){let i=e.model,o=i.statistics;vse(o,t),wse(o,e.runtimePrimitive),Fse(o,t),Ase(o,t.material),Mse(o,t.featureIds),Nse(o,i)};function vse(e,t){let n=l(t.indices)?t.indices.count:qt.getAttributeBySemantic(t,\"POSITION\").count,i=t.primitiveType;i===we.POINTS?e.pointsLength+=n:we.isTriangles(i)&&(e.trianglesLength+=JDe(i,n));let o=t.attributes,r=o.length;for(let c=0;c<r;c++){let d=o[c];if(l(d.buffer)){let u=l(d.typedArray);e.addBuffer(d.buffer,u)}}let s=t.outlineCoordinates;l(s)&&l(s.buffer)&&e.addBuffer(s.buffer,!1);let a=t.indices;if(l(a)&&l(a.buffer)){let c=l(a.typedArray);e.addBuffer(a.buffer,c)}}function JDe(e,t){switch(e){case we.TRIANGLES:return t/3;case we.TRIANGLE_STRIP:case we.TRIANGLE_FAN:return Math.max(t-2,0);default:return 0}}function wse(e,t){let n=t.positionBuffer2D;l(n)&&e.addBuffer(n,!0)}function Fse(e,t){let n=t.morphTargets;if(!l(n))return;let i=!1,o=n.length;for(let r=0;r<o;r++){let s=n[r].attributes,a=s.length;for(let c=0;c<a;c++){let d=s[c];l(d.buffer)&&e.addBuffer(d.buffer,i)}}}function Ase(e,t){let n=QDe(t),i=n.length;for(let o=0;o<i;o++){let r=n[o];l(r)&&l(r.texture)&&e.addTexture(r.texture)}}function QDe(e){let t=e.metallicRoughness,n=[e.emissiveTexture,e.normalTexture,e.occlusionTexture,t.baseColorTexture,t.metallicRoughnessTexture],i=e.specularGlossiness;return l(i)&&(n.push(i.diffuseTexture),n.push(i.specularGlossinessTexture)),n}function Mse(e,t){let n=t.length;for(let i=0;i<n;i++){let o=t[i];if(o instanceof Nt.FeatureIdTexture){let r=o.textureReader;l(r.texture)&&e.addTexture(r.texture)}}}function Nse(e,t){let n=t.structuralMetadata;l(n)&&(jDe(e,n),e.propertyTablesByteLength+=n.propertyTablesByteLength);let i=t.featureTables;if(!l(i))return;let o=i.length;for(let r=0;r<o;r++){let s=i[r];e.addBatchTexture(s.batchTexture)}}function jDe(e,t){let n=t.propertyTextures;if(!l(n))return;let i=n.length;for(let o=0;o<i;o++){let s=n[o].properties;for(let a in s)if(s.hasOwnProperty(a)){let d=s[a].textureReader;l(d.texture)&&e.addTexture(d.texture)}}}var _W=Pse;var eLn=T(S(),1);var qDe=new M,$De=new M,kse={name:\"SceneMode2DPipelineStage\"};kse.process=function(e,t,n){let i=qt.getAttributeBySemantic(t,St.POSITION),o=e.shaderBuilder,r=e.model,s=r.sceneGraph.computedModelMatrix,a=e.runtimeNode.computedTransform,c=M.multiplyTransformation(s,a,qDe),d=n3e(e,c,n),u=e.runtimePrimitive;u.boundingSphere2D=d;let m=e.runtimeNode.node.instances;if(l(m))return;if(l(i.typedArray)){let x=r3e(i,c,d,n);u.positionBuffer2D=x,r._modelResources.push(x),i.typedArray=void 0}o.addDefine(\"USE_2D_POSITIONS\",void"
}