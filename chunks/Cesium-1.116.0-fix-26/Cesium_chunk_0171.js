{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 171,
    "total_chunks": 194,
    "chunk_size": 20411,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.752Z"
  },
  "content": "he;ci.prototype.updateHeight=function(e,t,n){let i=()=>{he.clone(e,m8);let b=this.getHeight(e,n);l(b)&&(m8.height=b,t(m8))},o=n===Je.CLAMP_TO_TERRAIN||n===Je.RELATIVE_TO_TERRAIN,r=n===Je.CLAMP_TO_3D_TILE||n===Je.RELATIVE_TO_3D_TILE,s;!r&&l(this.globe)&&(s=this.globe._surface.updateHeight(e,i));let a={},c=this.globe?.ellipsoid,d=b=>{if(o||b.isDestroyed()||!b.isCesium3DTileset)return;let f=b.updateHeight(e,i,c);a[b.id]=f};if(!o){let b=this.primitives.length;for(let f=0;f<b;++f){let x=this.primitives.get(f);d(x)}}let u=this.primitives.primitiveAdded.addEventListener(d),m=this.primitives.primitiveRemoved.addEventListener(b=>{b.isDestroyed()||!b.isCesium3DTileset||(l(a[b.id])&&a[b.id](),delete a[b.id])});return()=>{s=s&&s(),Object.values(a).forEach(b=>b()),a={},u(),m()}};function Bbt(e){let t=e.camera,n=e._mode,i=e._screenSpaceCameraController,o=t.positionCartographic;if(!l(o))return!1;if(!i.onMap()&&o.height<0)return!0;if(n===ie.SCENE2D||n===ie.MORPHING)return!1;let r=e._globeHeight;return l(r)&&o.height<r}ci.prototype.initializeFrame=function(){if(this._shaderFrameCount++===120&&(this._shaderFrameCount=0,this._context.shaderCache.destroyReleasedShaderPrograms(),this._context.textureCache.destroyReleasedTextures()),this._tweens.update(),this.disableGetTilesetHeight&&l(this._removeUpdateHeightCallback)&&(this._globeHeightDirty=!0),this._globeHeightDirty&&(l(this._removeUpdateHeightCallback)&&(this._removeUpdateHeightCallback(),this._removeUpdateHeightCallback=void 0),this._globeHeight=Dbt(this),this._globeHeightDirty=!1,!this.disableGetTilesetHeight)){let e=this.camera.positionCartographic;this._removeUpdateHeightCallback=this.updateHeight(e,t=>{this.isDestroyed()||(this._globeHeight=t.height)})}this._cameraUnderground=Bbt(this),this._globeTranslucencyState.update(this),this._screenSpaceCameraController.update(),l(this._deviceOrientationCameraController)&&this._deviceOrientationCameraController.update(),this.camera.update(this._mode),this.camera._updateCameraChanged()};function Ybt(e,t){if(e.debugShowFramesPerSecond){if(!l(e._performanceDisplay)){let n=document.createElement(\"div\");n.className=\"cesium-performanceDisplay-defaultContainer\",e._canvas.parentNode.appendChild(n);let o=new tb({container:n});e._performanceDisplay=o,e._performanceContainer=n}e._performanceDisplay.throttled=e.requestRenderMode,e._performanceDisplay.update(t)}else l(e._performanceDisplay)&&(e._performanceDisplay=e._performanceDisplay&&e._performanceDisplay.destroy(),e._performanceContainer.parentNode.removeChild(e._performanceContainer))}function Obt(e){e._jobScheduler.resetBudgets();let t=e._frameState;e.primitives.prePassesUpdate(t),l(e.globe)&&e.globe.update(t),e._picking.update(),t.creditDisplay.update()}function zbt(e){let t=e._frameState;e.primitives.postPassesUpdate(t),Ja.update()}var Hbt=new O;function Kbt(e){let t=e._frameState,n=e.context,i=n.uniformState,o=e._defaultView;e._view=o,e.updateFrameState(),t.passes.render=!0,t.passes.postProcess=e.postProcessStages.hasSelected,t.tilesetPassState=ybt;let r=g(e.backgroundColor,O.BLACK);e._hdr&&(r=O.clone(r,Hbt),r.red=Math.pow(r.red,e.gamma),r.green=Math.pow(r.green,e.gamma),r.blue=Math.pow(r.blue,e.gamma)),t.backgroundColor=r,t.atmosphere=e.atmosphere,e.fog.update(t),i.update(t);let s=e.shadowMap;l(s)&&s.enabled&&(!l(e.light)||e.light instanceof yp?h.negate(i.sunDirectionWC,e._shadowMapCamera.direction):h.clone(e.light.direction,e._shadowMapCamera.direction),t.shadowMaps.push(s)),e._computeCommandList.length=0,e._overlayCommandList.length=0;let a=o.viewport;a.x=0,a.y=0,a.width=n.drawingBufferWidth,a.height=n.drawingBufferHeight;let c=o.passState;c.framebuffer=void 0,c.blendingEnabled=void 0,c.scissorTest=void 0,c.viewport=ze.clone(a,c.viewport),l(e.globe)&&e.globe.beginFrame(t),e.updateEnvironment(),e.updateAndExecuteCommands(c,r),e.resolveFramebuffers(c,()=>{Zbt(e,c)}),c.framebuffer=void 0,l(e.globe)&&(e.globe.endFrame(t),e.globe.tilesLoaded||(e._renderRequested=!0)),n.endFrame()}function zT(e,t){try{t(e)}catch(n){if(e._renderError.raiseEvent(e,n),e.rethrowRenderErrors)throw n}}function Jbt(e){return e._picking.updateMostDetailedRayPicks(e)}ci.prototype.render=function(e){this._preUpdate.raiseEvent(this,e);let t=this._frameState;t.newFrame=!1,l(e)||(e=te.now());let n=this._view.checkForCameraUpdates(this);n&&(this._globeHeightDirty=!0);let i=!this.requestRenderMode||this._renderRequested||n||this._logDepthBufferDirty||this._hdrDirty||this.mode===ie.MORPHING;if(!i&&l(this.maximumRenderTimeChange)&&l(this._lastRenderTime)){let o=Math.abs(te.secondsDifference(this._lastRenderTime,e));i=i||o>this.maximumRenderTimeChange}if(i){this._lastRenderTime=te.clone(e,this._lastRenderTime),this._renderRequested=!1,this._logDepthBufferDirty=!1,this._hdrDirty=!1;let o=P.incrementWrap(t.frameNumber,15e6,1);aTe(this,o,e),t.newFrame=!0}zT(this,Obt),this.primitives.show&&(zT(this,Jbt),zT(this,Qbt),zT(this,jbt),i||zT(this,qbt)),this._postUpdate.raiseEvent(this,e),i&&(this._preRender.raiseEvent(this,e),t.creditDisplay.beginFrame(),zT(this,Kbt)),Ybt(this,i),zT(this,zbt),Ubt(this),i&&(this._postRender.raiseEvent(this,e),t.creditDisplay.endFrame())};ci.prototype.forceRender=function(e){this._renderRequested=!0,this.render(e)};ci.prototype.requestRender=function(){this._renderRequested=!0};ci.prototype.clampLineWidth=function(e){return Math.max(Yt.minimumAliasedLineWidth,Math.min(e,Yt.maximumAliasedLineWidth))};ci.prototype.pick=function(e,t,n){return this._picking.pick(this,e,t,n)};ci.prototype.pickVoxel=function(e,t,n){let i=this.pick(e,t,n);if(!l(i))return;let o=i.primitive;if(!(o instanceof Zg))return;let r=this._picking.pickVoxelCoordinate(this,e,t,n),s=255*r[0]+r[1],a=o._traversal.findKeyframeNode(s);if(!l(a))return;let c=255*r[2]+r[3];return YF.fromKeyframeNode(o,s,c,a)};ci.prototype.pickPositionWorldCoordinates=function(e,t){return this._picking.pickPositionWorldCoordinates(this,e,t)};ci.prototype.pickPosition=function(e,t){return this._picking.pickPosition(this,e,t)};ci.prototype.pickPositionNearest=function(e,t=10,n=10,i){return this.render(),this._picking.pickPositionNearest(this,e,t,n,i)};ci.prototype.drillPick=function(e,t,n,i){return this._picking.drillPick(this,e,t,n,i)};function Qbt(e){let t=e._frameState;c8.camera=t.camera,c8.cullingVolume=t.cullingVolume,e.primitives.updateForPass(t,c8)}function jbt(e){let t=e._frameState;if(!t.camera.canPreloadFlight())return;l8.camera=e.preloadFlightCamera,l8.cullingVolume=e.preloadFlightCullingVolume,e.primitives.updateForPass(t,l8)}function qbt(e){e.primitives.updateForPass(e._frameState,gbt)}ci.prototype.pickFromRay=function(e,t,n){return this._picking.pickFromRay(this,e,t,n)};ci.prototype.drillPickFromRay=function(e,t,n,i){return this._picking.drillPickFromRay(this,e,t,n,i)};ci.prototype.pickFromRayMostDetailed=function(e,t,n){return this._picking.pickFromRayMostDetailed(this,e,t,n)};ci.prototype.drillPickFromRayMostDetailed=function(e,t,n,i){return this._picking.drillPickFromRayMostDetailed(this,e,t,n,i)};ci.prototype.sampleHeight=function(e,t,n){return this._picking.sampleHeight(this,e,t,n)};ci.prototype.clampToHeight=function(e,t,n,i){return this._picking.clampToHeight(this,e,t,n,i)};ci.prototype.sampleHeightMostDetailed=function(e,t,n){return this._picking.sampleHeightMostDetailed(this,e,t,n)};ci.prototype.clampToHeightMostDetailed=function(e,t,n){return this._picking.clampToHeightMostDetailed(this,e,t,n)};ci.prototype.cartesianToCanvasCoordinates=function(e,t){return Zi.wgs84ToWindowCoordinates(this,e,t)};ci.prototype.completeMorph=function(){this._transitioner.completeMorph()};ci.prototype.morphTo2D=function(e){let t,n=this.globe;l(n)?t=n.ellipsoid:t=this.mapProjection.ellipsoid,e=g(e,2),this._transitioner.morphTo2D(e,t)};ci.prototype.morphToColumbusView=function(e){let t,n=this.globe;l(n)?t=n.ellipsoid:t=this.mapProjection.ellipsoid,e=g(e,2),this._transitioner.morphToColumbusView(e,t)};ci.prototype.morphTo3D=function(e){let t,n=this.globe;l(n)?t=n.ellipsoid:t=this.mapProjection.ellipsoid,e=g(e,2),this._transitioner.morphTo3D(e,t)};function $bt(e,t){if(e._removeTerrainProviderReadyListener=e._removeTerrainProviderReadyListener&&e._removeTerrainProviderReadyListener(),t.ready){l(e.globe)&&(e.globe.terrainProvider=t.provider);return}e.globe.terrainProvider=void 0,e._removeTerrainProviderReadyListener=t.readyEvent.addEventListener(n=>{l(e)&&l(e.globe)&&(e.globe.terrainProvider=n),e._removeTerrainProviderReadyListener()})}ci.prototype.setTerrain=function(e){return $bt(this,e),e};ci.prototype.isDestroyed=function(){return!1};ci.prototype.destroy=function(){this._tweens.removeAll(),this._computeEngine=this._computeEngine&&this._computeEngine.destroy(),this._screenSpaceCameraController=this._screenSpaceCameraController&&this._screenSpaceCameraController.destroy(),this._deviceOrientationCameraController=this._deviceOrientationCameraController&&!this._deviceOrientationCameraController.isDestroyed()&&this._deviceOrientationCameraController.destroy(),this._primitives=this._primitives&&this._primitives.destroy(),this._groundPrimitives=this._groundPrimitives&&this._groundPrimitives.destroy(),this._globe=this._globe&&this._globe.destroy(),this._removeTerrainProviderReadyListener=this._removeTerrainProviderReadyListener&&this._removeTerrainProviderReadyListener(),this.skyBox=this.skyBox&&this.skyBox.destroy(),this.skyAtmosphere=this.skyAtmosphere&&this.skyAtmosphere.destroy(),this._debugSphere=this._debugSphere&&this._debugSphere.destroy(),this.sun=this.sun&&this.sun.destroy(),this._sunPostProcess=this._sunPostProcess&&this._sunPostProcess.destroy(),this._depthPlane=this._depthPlane&&this._depthPlane.destroy(),this._transitioner=this._transitioner&&this._transitioner.destroy(),this._debugFrustumPlanes=this._debugFrustumPlanes&&this._debugFrustumPlanes.destroy(),this._brdfLutGenerator=this._brdfLutGenerator&&this._brdfLutGenerator.destroy(),this._picking=this._picking&&this._picking.destroy(),this._defaultView=this._defaultView&&this._defaultView.destroy(),this._view=void 0,this._removeCreditContainer&&this._canvas.parentNode.removeChild(this._creditContainer),this.postProcessStages=this.postProcessStages&&this.postProcessStages.destroy(),this._context=this._context&&this._context.destroy(),this._frameState.creditDisplay=this._frameState.creditDisplay&&this._frameState.creditDisplay.destroy(),l(this._performanceDisplay)&&(this._performanceDisplay=this._performanceDisplay&&this._performanceDisplay.destroy(),this._performanceContainer.parentNode.removeChild(this._performanceContainer)),this._removeRequestListenerCallback(),this._removeTaskProcessorListenerCallback();for(let e=0;e<this._removeGlobeCallbacks.length;++e)this._removeGlobeCallbacks[e]();return this._removeGlobeCallbacks.length=0,l(this._removeUpdateHeightCallback)&&(this._removeUpdateHeightCallback(),this._removeUpdateHeightCallback=void 0),me(this)};var b9=ci;var lDi=T(S(),1);var PUi=T(S(),1),eL=`float interpolateByDistance(vec4 nearFarScalar, float distance) { float startDistance = nearFarScalar.x; float startValue = nearFarScalar.y; float endDistance = nearFarScalar.z; float endValue = nearFarScalar.w; float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0); return mix(startValue, endValue, t); } void computeAtmosphereScattering(vec3 positionWC, vec3 lightDirection, out vec3 rayleighColor, out vec3 mieColor, out float opacity, out float underTranslucentGlobe) { float ellipsoidRadiiDifference = czm_ellipsoidRadii.x - czm_ellipsoidRadii.z; // Adjustment to the atmosphere radius applied based on the camera height. float distanceAdjustMin = czm_ellipsoidRadii.x / 4.0; float distanceAdjustMax = czm_ellipsoidRadii.x; float distanceAdjustModifier = ellipsoidRadiiDifference / 2.0; float distanceAdjust = distanceAdjustModifier * clamp((czm_eyeHeight - distanceAdjustMin) / (distanceAdjustMax - distanceAdjustMin), 0.0, 1.0); // Since atmosphere scattering assumes the atmosphere is a spherical shell, we compute an inner radius of the atmosphere best fit // for the position on the ellipsoid. float radiusAdjust = (ellipsoidRadiiDifference / 4.0) + distanceAdjust; float atmosphereInnerRadius = (length(czm_viewerPositionWC) - czm_eyeHeight) - radiusAdjust; // Setup the primary ray: from the camera position to the vertex position. vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC; vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC); czm_ray primaryRay = czm_ray(czm_viewerPositionWC, cameraToPositionWCDirection); underTranslucentGlobe = 0.0; // Brighten the sky atmosphere under the Earth's atmosphere when translucency is enabled. #if defined(GLOBE_TRANSLUCENT) // Check for intersection with the inner radius of the atmopshere. czm_raySegment primaryRayEarthIntersect = czm_raySphereIntersectionInterval(primaryRay, vec3(0.0), atmosphereInnerRadius + radiusAdjust); if (primaryRayEarthIntersect.start > 0.0 && primaryRayEarthIntersect.stop > 0.0) { // Compute position on globe. vec3 direction = normalize(positionWC); czm_ray ellipsoidRay = czm_ray(positionWC, -direction); czm_raySegment ellipsoidIntersection = czm_rayEllipsoidIntersectionInterval(ellipsoidRay, vec3(0.0), czm_ellipsoidInverseRadii); vec3 onEarth = positionWC - (direction * ellipsoidIntersection.start); // Control the color using the camera angle. float angle = dot(normalize(czm_viewerPositionWC), normalize(onEarth)); // Control the opacity using the distance from Earth. opacity = interpolateByDistance(vec4(0.0, 1.0, czm_ellipsoidRadii.x, 0.0), length(czm_viewerPositionWC - onEarth)); vec3 horizonColor = vec3(0.1, 0.2, 0.3); vec3 nearColor = vec3(0.0); rayleighColor = mix(nearColor, horizonColor, exp(-angle) * opacity); // Set the traslucent flag to avoid alpha adjustment in computeFinalColor funciton. underTranslucentGlobe = 1.0; return; } #endif computeScattering( primaryRay, length(cameraToPositionWC), lightDirection, atmosphereInnerRadius, rayleighColor, mieColor, opacity ); // Alter the opacity based on how close the viewer is to the ground. // (0.0 = At edge of atmosphere, 1.0 = On ground) float cameraHeight = czm_eyeHeight + atmosphereInnerRadius; float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS; opacity = clamp((atmosphereOuterRadius - cameraHeight) / (atmosphereOuterRadius - atmosphereInnerRadius), 0.0, 1.0); // Alter alpha based on time of day (0.0 = night , 1.0 = day) float nightAlpha = (u_radiiAndDynamicAtmosphereColor.z != 0.0) ? clamp(dot(normalize(positionWC), lightDirection), 0.0, 1.0) : 1.0; opacity *= pow(nightAlpha, 0.5); } `;var wUi=T(S(),1),y9=`in vec3 v_outerPositionWC; uniform vec3 u_hsbShift; #ifndef PER_FRAGMENT_ATMOSPHERE in vec3 v_mieColor; in vec3 v_rayleighColor; in float v_opacity; in float v_translucent; #endif void main (void) { float lightEnum = u_radiiAndDynamicAtmosphereColor.z; vec3 lightDirection = czm_getDynamicAtmosphereLightDirection(v_outerPositionWC, lightEnum); vec3 mieColor; vec3 rayleighColor; float opacity; float translucent; #ifdef PER_FRAGMENT_ATMOSPHERE computeAtmosphereScattering( v_outerPositionWC, lightDirection, rayleighColor, mieColor, opacity, translucent ); #else mieColor = v_mieColor; rayleighColor = v_rayleighColor; opacity = v_opacity; translucent = v_translucent; #endif vec4 color = computeAtmosphereColor(v_outerPositionWC, lightDirection, rayleighColor, mieColor, opacity); #ifndef HDR color.rgb = czm_acesTonemapping(color.rgb); color.rgb = czm_inverseGamma(color.rgb); #endif #ifdef COLOR_CORRECT const bool ignoreBlackPixels = true; color.rgb = czm_applyHSBShift(color.rgb, u_hsbShift, ignoreBlackPixels); #endif // For the parts of the sky atmosphere that are not behind a translucent globe, // we mix in the default opacity so that the sky atmosphere still appears at distance. // This is needed because the opacity in the sky atmosphere is initially adjusted based // on the camera height. if (translucent == 0.0) { color.a = mix(color.b, 1.0, color.a) * smoothstep(0.0, 1.0, czm_morphTime); } out_FragColor = color; } `;var AUi=T(S(),1),g9=`in vec4 position; out vec3 v_outerPositionWC; #ifndef PER_FRAGMENT_ATMOSPHERE out vec3 v_mieColor; out vec3 v_rayleighColor; out float v_opacity; out float v_translucent; #endif void main(void) { vec4 positionWC = czm_model * position; float lightEnum = u_radiiAndDynamicAtmosphereColor.z; vec3 lightDirection = czm_getDynamicAtmosphereLightDirection(positionWC.xyz, lightEnum); #ifndef PER_FRAGMENT_ATMOSPHERE computeAtmosphereScattering( positionWC.xyz, lightDirection, v_rayleighColor, v_mieColor, v_opacity, v_translucent ); #endif v_outerPositionWC = positionWC.xyz; gl_Position = czm_modelViewProjection * position; } `;function tL(e){e=g(e,oe.WGS84),this.show=!0,this.perFragmentAtmosphere=!1,this._ellipsoid=e;let t=1.025,n=h.multiplyByScalar(e.radii,t,new h);this._scaleMatrix=M.fromScale(n),this._modelMatrix=new M,this._command=new je({owner:this,modelMatrix:this._modelMatrix}),this._spSkyFromSpace=void 0,this._spSkyFromAtmosphere=void 0,this._flags=void 0,this.atmosphereLightIntensity=50,this.atmosphereRayleighCoefficient=new h(55e-7,13e-6,284e-7),this.atmosphereMieCoefficient=new h(21e-6,21e-6,21e-6),this.atmosphereRayleighScaleHeight=1e4,this.atmosphereMieScaleHeight=3200,this.atmosphereMieAnisotropy=.9,this.hueShift=0,this.saturationShift=0,this.brightnessShift=0,this._hueSaturationBrightness=new h;let i=new h;i.x=e.maximumRadius*t,i.y=e.maximumRadius,i.z=0,this._radiiAndDynamicAtmosphereColor=i;let o=this;this._command.uniformMap={u_radiiAndDynamicAtmosphereColor:function(){return o._radiiAndDynamicAtmosphereColor},u_hsbShift:function(){return o._hueSaturationBrightness.x=o.hueShift,o._hueSaturationBrightness.y=o.saturationShift,o._hueSaturationBrightness.z=o.brightnessShift,o._hueSaturationBrightness},u_atmosphereLightIntensity:function(){return o.atmosphereLightIntensity},u_atmosphereRayleighCoefficient:function(){return o.atmosphereRayleighCoefficient},u_atmosphereMieCoefficient:function(){return o.atmosphereMieCoefficient},u_atmosphereRayleighScaleHeight:function(){return o.atmosphereRayleighScaleHeight},u_atmosphereMieScaleHeight:function(){return o.atmosphereMieScaleHeight},u_atmosphereMieAnisotropy:function(){return o.atmosphereMieAnisotropy}}}Object.defineProperties(tL.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}});tL.prototype.setDynamicLighting=function(e){this._radiiAndDynamicAtmosphereColor.z=e};var f8=new M;tL.prototype.update=function(e,t){if(!this.show)return;let n=e.mode;if(n!==ie.SCENE3D&&n!==ie.MORPHING||!e.passes.render)return;let i=M.fromRotationTranslation(e.context.uniformState.inverseViewRotation,h.ZERO,f8),o=M.multiplyTransformation(i,Ro.Y_UP_TO_Z_UP,f8),r=M.multiply(this._scaleMatrix,o,f8);M.clone(r,this._modelMatrix);let s=e.context,a=eyt(this),c=e.globeTranslucencyState.translucent,d=this.perFragmentAtmosphere||c||!l(t)||!t.show,u=this._command;if(!l(u.vertexArray)){let p=Ds.createGeometry(new Ds({radii:new h(1,1,1),slicePartitions:256,stackPartitions:256,vertexFormat:Pe.POSITION_ONLY}));u.vertexArray=ti.fromGeometry({context:s,geometry:p,attributeLocations:An.createAttributeLocations(p),bufferUsage:Me.STATIC_DRAW}),u.renderState=Ne.fromCache({cull:{enabled:!0,face:mi.FRONT},blending:un.ALPHA_BLEND,depthMask:!1})}let m=a|d<<2|c<<3;if(m!==this._flags){this._flags=m;let p=[];a&&p.push(\"COLOR_CORRECT\"),d&&p.push(\"PER_FRAGMENT_ATMOSPHERE\"),c&&p.push(\"GLOBE_TRANSLUCENT\");let b=new Ue({defines:p,sources:[H0,eL,g9]}),f=new Ue({defines:p,sources:[H0,eL,y9]});this._spSkyAtmosphere=Ht.fromCache({context:s,vertexShaderSource:b,fragmentShaderSource:f}),u.shaderProgram=this._spSkyAtmosphere}return u};function eyt(e){return!(P.equalsEpsilon(e.hueShift,0,P.EPSILON7)&&P.equalsEpsilon(e.saturationShift,0,P.EPSILON7)&&P.equalsEpsilon(e.brightnessShift,0,P.EPSILON7))}tL.prototype.isDestroyed=function(){return!1};tL.prototype.destroy=function(){let e=this._command;return e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),this._spSkyAtmosphere=this._spSkyAtmosphere&&this._spSkyAtmosphere.destroy(),me(this)};var x9=tL;var wDi=T(S(),1);var uDi=T(S(),1),_9=`uniform samplerCube u_cubeMap; in vec3 v_texCoord; void main() { vec4 color = czm_textureCube(u_cubeMap, normalize(v_texCoord)); out_FragColor = vec4(czm_gammaCorrect(color).rgb, czm_morphTime); } `;var hDi=T(S(),1),T9=`in vec3 position; out vec3 v_texCoord; void main() { vec3 p = czm_viewRotation * (czm_temeToPseudoFixed *"
}