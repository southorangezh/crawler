{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 86,
    "total_chunks": 194,
    "chunk_size": 19351,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.697Z"
  },
  "content": "p in u)if(u.hasOwnProperty(p)){let b=u[p];i.addUniform(b.type,p)}let m=s.varyings;for(let p in m)if(m.hasOwnProperty(p)){let b=m[p];i.addVarying(b,p)}e.uniformMap=Ct(e.uniformMap,s.uniformMap)};function qUe(e){let t={};for(let n=0;n<e.length;n++){let i=qt.getAttributeInfo(e[n]);t[i.variableName]=i}return t}var $Ue={position:\"vec3\",normal:\"vec3\",tangent:\"vec3\",bitangent:\"vec3\",texCoord:\"vec2\",color:\"vec4\",joints:\"ivec4\",weights:\"vec4\"},eDe={position:\"vec3(0.0)\",normal:\"vec3(0.0, 0.0, 1.0)\",tangent:\"vec3(1.0, 0.0, 0.0)\",bitangent:\"vec3(0.0, 1.0, 0.0)\",texCoord:\"vec2(0.0)\",color:\"vec4(1.0)\",joints:\"ivec4(0)\",weights:\"vec4(0.0)\"};function xse(e){let t=e.replace(/_[0-9]+$/,\"\");t=t.replace(/(MC|EC)$/,\"\");let n=$Ue[t],i=eDe[t];if(l(n))return{attributeField:[n,e],value:i}}function tDe(e,t){if(!l(e.vertexShaderText))return{enabled:!1};let n=e.usedVariablesVertex.attributeSet,i=_se(t,n,!1),o=Tse(t,n,!1),r,s=[],a=[];for(let c in i){if(!i.hasOwnProperty(c))continue;let u=[i[c].glslType,c];s.push(u),r=`vsInput.attributes.${c} = attributes.${c};`,a.push(r)}for(let c=0;c<o.length;c++){let d=o[c],u=xse(d);if(!l(u))return oa._oneTimeWarning(\"CustomShaderPipelineStage.incompatiblePrimitiveVS\",`Primitive is missing attribute ${d}, disabling custom vertex shader`),{enabled:!1};s.push(u.attributeField),r=`vsInput.attributes.${d} = ${u.value};`,a.push(r)}return{enabled:!0,attributeFields:s,initializationLines:a}}function nDe(e){let t=[],n=[],i=e.usedVariablesFragment.attributeSet;return i.hasOwnProperty(\"positionWC\")&&(t.push([\"vec3\",\"positionWC\"]),n.push(\"fsInput.attributes.positionWC = attributes.positionWC;\")),i.hasOwnProperty(\"positionEC\")&&(t.push([\"vec3\",\"positionEC\"]),n.push(\"fsInput.attributes.positionEC = attributes.positionEC;\")),{attributeFields:t,initializationLines:n}}function iDe(e,t){if(!l(e.fragmentShaderText))return{enabled:!1};let n=e.usedVariablesFragment.attributeSet,i=_se(t,n,!0),o=Tse(t,n,!0),r,s=[],a=[];for(let d in i){if(!i.hasOwnProperty(d))continue;let m=[i[d].glslType,d];s.push(m),r=`fsInput.attributes.${d} = attributes.${d};`,a.push(r)}for(let d=0;d<o.length;d++){let u=o[d],m=xse(u);if(!l(m))return oa._oneTimeWarning(\"CustomShaderPipelineStage.incompatiblePrimitiveFS\",`Primitive is missing attribute ${u}, disabling custom fragment shader.`),{enabled:!1};s.push(m.attributeField),r=`fsInput.attributes.${u} = ${m.value};`,a.push(r)}let c=nDe(e);return{enabled:!0,attributeFields:s.concat(c.attributeFields),initializationLines:c.initializationLines.concat(a)}}var oDe={positionWC:!0,positionEC:!0};function _se(e,t,n){let i={};for(let o in e){if(!e.hasOwnProperty(o))continue;let r=e[o],s=o;n&&o===\"normalMC\"?s=\"normalEC\":n&&o===\"tangentMC\"&&(s=\"tangentEC\",r.glslType=\"vec3\"),t.hasOwnProperty(s)&&(i[s]=r)}return i}function Tse(e,t,n){let i=[];for(let o in t){if(!t.hasOwnProperty(o)||oDe.hasOwnProperty(o))continue;let r=o;n&&o===\"normalEC\"?r=\"normalMC\":n&&o===\"tangentEC\"&&(r=\"tangentMC\"),e.hasOwnProperty(r)||i.push(o)}return i}function rDe(e,t){let n=qUe(t.attributes),i=tDe(e,n),o=iDe(e,n),s=e.usedVariablesFragment.attributeSet.hasOwnProperty(\"positionWC\")&&o.enabled;return{vertexLines:i,fragmentLines:o,customShaderEnabled:i.enabled||o.enabled,shouldComputePositionWC:s}}function sDe(e,t){let n=oa.STRUCT_ID_ATTRIBUTES_VS;e.addStruct(n,oa.STRUCT_NAME_ATTRIBUTES,Ce.VERTEX);let{attributeFields:i,initializationLines:o}=t;for(let s=0;s<i.length;s++){let[a,c]=i[s];e.addStructField(n,a,c)}n=oa.STRUCT_ID_VERTEX_INPUT,e.addStruct(n,oa.STRUCT_NAME_VERTEX_INPUT,Ce.VERTEX),e.addStructField(n,oa.STRUCT_NAME_ATTRIBUTES,\"attributes\"),e.addStructField(n,my.STRUCT_NAME_FEATURE_IDS,\"featureIds\"),e.addStructField(n,gu.STRUCT_NAME_METADATA,\"metadata\"),e.addStructField(n,gu.STRUCT_NAME_METADATA_CLASS,\"metadataClass\"),e.addStructField(n,gu.STRUCT_NAME_METADATA_STATISTICS,\"metadataStatistics\");let r=oa.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_VS;e.addFunction(r,oa.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_VS,Ce.VERTEX),e.addFunctionLines(r,o)}function aDe(e,t){let n=oa.STRUCT_ID_ATTRIBUTES_FS;e.addStruct(n,oa.STRUCT_NAME_ATTRIBUTES,Ce.FRAGMENT);let{attributeFields:i,initializationLines:o}=t;for(let s=0;s<i.length;s++){let[a,c]=i[s];e.addStructField(n,a,c)}n=oa.STRUCT_ID_FRAGMENT_INPUT,e.addStruct(n,oa.STRUCT_NAME_FRAGMENT_INPUT,Ce.FRAGMENT),e.addStructField(n,oa.STRUCT_NAME_ATTRIBUTES,\"attributes\"),e.addStructField(n,my.STRUCT_NAME_FEATURE_IDS,\"featureIds\"),e.addStructField(n,gu.STRUCT_NAME_METADATA,\"metadata\"),e.addStructField(n,gu.STRUCT_NAME_METADATA_CLASS,\"metadataClass\"),e.addStructField(n,gu.STRUCT_NAME_METADATA_STATISTICS,\"metadataStatistics\");let r=oa.FUNCTION_ID_INITIALIZE_INPUT_STRUCT_FS;e.addFunction(r,oa.FUNCTION_SIGNATURE_INITIALIZE_INPUT_STRUCT_FS,Ce.FRAGMENT),e.addFunctionLines(r,o)}var cDe=[];function lDe(e,t,n){let{vertexLines:i,fragmentLines:o}=n,r=cDe;i.enabled&&(sDe(e,i),r.length=0,r.push(\"#line 0\",t.vertexShaderText,JI),e.addVertexLines(r)),o.enabled&&(aDe(e,o),r.length=0,r.push(\"#line 0\",t.fragmentShaderText,QI),e.addFragmentLines(r))}var tW=oa;var ICn=T(S(),1);var nW={name:\"DequantizationPipelineStage\",FUNCTION_ID_DEQUANTIZATION_STAGE_VS:\"dequantizationStage\",FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS:\"void dequantizationStage(inout ProcessedAttributes attributes)\"};nW.process=function(e,t,n){let i=e.shaderBuilder,o=e.model,r=l(o.classificationType);i.addDefine(\"USE_DEQUANTIZATION\",void 0,Ce.VERTEX),i.addFunction(nW.FUNCTION_ID_DEQUANTIZATION_STAGE_VS,nW.FUNCTION_SIGNATURE_DEQUANTIZATION_STAGE_VS,Ce.VERTEX);let s=t.attributes;for(let a=0;a<s.length;a++){let c=s[a],d=c.quantization;if(!l(d))continue;let u=c.semantic===St.POSITION,m=c.semantic===St.TEXCOORD;if(r&&!u&&!m)continue;let p=qt.getAttributeInfo(c);uDe(i,p),dDe(e,p)}};function dDe(e,t){let n=e.shaderBuilder,i=e.uniformMap,o=t.variableName,r=t.attribute.quantization;if(r.octEncoded){let s=`model_normalizationRange_${o}`;n.addUniform(\"float\",s,Ce.VERTEX),i[s]=function(){return r.normalizationRange}}else{let s=`model_quantizedVolumeOffset_${o}`,a=`model_quantizedVolumeStepSize_${o}`,c=t.glslType;n.addUniform(c,s,Ce.VERTEX),n.addUniform(c,a,Ce.VERTEX);let d=r.quantizedVolumeOffset,u=r.quantizedVolumeStepSize;/^color_\\d+$/.test(o)&&(d=Sse(d,0),u=Sse(u,1)),i[s]=function(){return d},i[a]=function(){return u}}}function Sse(e,t){return e instanceof se?e:new se(e.x,e.y,e.z,t)}function uDe(e,t){let n=t.variableName,i=t.attribute.quantization,o;i.octEncoded?o=mDe(n,i):o=hDe(n),e.addFunctionLines(nW.FUNCTION_ID_DEQUANTIZATION_STAGE_VS,[o])}function mDe(e,t){let n=`attributes.${e}`,i=`a_quantized_${e}`,o=`model_normalizationRange_${e}`,r=t.octEncodedZXY?\".zxy\":\".xyz\";return`${n} = czm_octDecode(${i}, ${o})${r};`}function hDe(e){let t=`attributes.${e}`,n=`a_quantized_${e}`,i=`model_quantizedVolumeOffset_${e}`,o=`model_quantizedVolumeStepSize_${e}`;return`${t} = ${i} + ${n} * ${o};`}var iW=nW;var r1n=T(S(),1);var PCn=T(S(),1),oW=`void geometryStage(out ProcessedAttributes attributes) { attributes.positionMC = v_positionMC; attributes.positionEC = v_positionEC; #if defined(COMPUTE_POSITION_WC_CUSTOM_SHADER) || defined(COMPUTE_POSITION_WC_STYLE) || defined(COMPUTE_POSITION_WC_ATMOSPHERE) attributes.positionWC = v_positionWC; #endif #ifdef HAS_NORMALS // renormalize after interpolation attributes.normalEC = normalize(v_normalEC); #endif #ifdef HAS_TANGENTS attributes.tangentEC = normalize(v_tangentEC); #endif #ifdef HAS_BITANGENTS attributes.bitangentEC = normalize(v_bitangentEC); #endif // Everything else is dynamically generated in GeometryPipelineStage setDynamicVaryings(attributes); } `;var wCn=T(S(),1),rW=`vec4 geometryStage(inout ProcessedAttributes attributes, mat4 modelView, mat3 normal) { vec4 computedPosition; // Compute positions in different coordinate systems vec3 positionMC = attributes.positionMC; v_positionMC = positionMC; v_positionEC = (modelView * vec4(positionMC, 1.0)).xyz; #if defined(USE_2D_POSITIONS) || defined(USE_2D_INSTANCING) vec3 position2D = attributes.position2D; vec3 positionEC = (u_modelView2D * vec4(position2D, 1.0)).xyz; computedPosition = czm_projection * vec4(positionEC, 1.0); #else computedPosition = czm_projection * vec4(v_positionEC, 1.0); #endif // Sometimes the custom shader and/or style needs this #if defined(COMPUTE_POSITION_WC_CUSTOM_SHADER) || defined(COMPUTE_POSITION_WC_STYLE) || defined(COMPUTE_POSITION_WC_ATMOSPHERE) // Note that this is a 32-bit position which may result in jitter on small // scales. v_positionWC = (czm_model * vec4(positionMC, 1.0)).xyz; #endif #ifdef HAS_NORMALS v_normalEC = normalize(normal * attributes.normalMC); #endif #ifdef HAS_TANGENTS v_tangentEC = normalize(normal * attributes.tangentMC); #endif #ifdef HAS_BITANGENTS v_bitangentEC = normalize(normal * attributes.bitangentMC); #endif // All other varyings need to be dynamically generated in // GeometryPipelineStage setDynamicVaryings(attributes); return computedPosition; } `;var OCn=T(S(),1);var ACn=T(S(),1),MC=`vec2 computeSt(float featureId) { float stepX = model_textureStep.x; float centerX = model_textureStep.y; #ifdef MULTILINE_BATCH_TEXTURE float stepY = model_textureStep.z; float centerY = model_textureStep.w; float xId = mod(featureId, model_textureDimensions.x); float yId = floor(featureId / model_textureDimensions.x); return vec2(centerX + (xId * stepX), centerY + (yId * stepY)); #else return vec2(centerX + (featureId * stepX), 0.5); #endif } void selectedFeatureIdStage(out SelectedFeature feature, FeatureIds featureIds) { int featureId = featureIds.SELECTED_FEATURE_ID; if (featureId < model_featuresLength) { vec2 featureSt = computeSt(float(featureId)); feature.id = featureId; feature.st = featureSt; feature.color = texture(model_batchTexture, featureSt); } // Floating point comparisons can be unreliable in GLSL, so we // increment the feature ID to make sure it's always greater // then the model_featuresLength - a condition we check for in the // pick ID, to avoid sampling the pick texture if the feature ID is // greater than the number of features. else { feature.id = model_featuresLength + 1; feature.st = vec2(0.0); feature.color = vec4(1.0); } #ifdef HAS_NULL_FEATURE_ID if (featureId == model_nullFeatureId) { feature.id = featureId; feature.st = vec2(0.0); feature.color = vec4(1.0); } #endif } `;var sW={name:\"SelectedFeatureIdPipelineStage\",STRUCT_ID_SELECTED_FEATURE:\"SelectedFeature\",STRUCT_NAME_SELECTED_FEATURE:\"SelectedFeature\",FUNCTION_ID_FEATURE_VARYINGS_VS:\"updateFeatureStructVS\",FUNCTION_ID_FEATURE_VARYINGS_FS:\"updateFeatureStructFS\",FUNCTION_SIGNATURE_UPDATE_FEATURE:\"void updateFeatureStruct(inout SelectedFeature feature)\"};sW.process=function(e,t,n){let i=e.shaderBuilder;e.hasPropertyTable=!0;let o=e.model,r=e.runtimeNode.node,s=fDe(o,r,t),a=s.shaderDestination;i.addDefine(\"HAS_SELECTED_FEATURE_ID\",void 0,a),i.addDefine(\"SELECTED_FEATURE_ID\",s.variableName,a),i.addDefine(s.featureIdDefine,void 0,a),pDe(i);let c=s.featureIds.nullFeatureId,d=e.uniformMap;l(c)&&(i.addDefine(\"HAS_NULL_FEATURE_ID\",void 0,a),i.addUniform(\"int\",\"model_nullFeatureId\",a),d.model_nullFeatureId=function(){return c}),s.shaderDestination===Ce.BOTH&&i.addVertexLines(MC),i.addFragmentLines(MC)};function Cse(e){return e instanceof Nt.FeatureIdTexture?\"HAS_SELECTED_FEATURE_ID_TEXTURE\":\"HAS_SELECTED_FEATURE_ID_ATTRIBUTE\"}function Vse(e){return e instanceof Nt.FeatureIdTexture?Ce.FRAGMENT:Ce.BOTH}function fDe(e,t,n){let i,o;return l(t.instances)&&(o=qt.getFeatureIdsByLabel(t.instances.featureIds,e.instanceFeatureIdLabel),l(o))?(i=g(o.label,o.positionalLabel),{featureIds:o,variableName:i,shaderDestination:Vse(o),featureIdDefine:Cse(o)}):(o=qt.getFeatureIdsByLabel(n.featureIds,e.featureIdLabel),i=g(o.label,o.positionalLabel),{featureIds:o,variableName:i,shaderDestination:Vse(o),featureIdDefine:Cse(o)})}function pDe(e){e.addStructField(sW.STRUCT_ID_SELECTED_FEATURE,\"int\",\"id\"),e.addStructField(sW.STRUCT_ID_SELECTED_FEATURE,\"vec2\",\"st\"),e.addStructField(sW.STRUCT_ID_SELECTED_FEATURE,\"vec4\",\"color\")}var fy=sW;var Ms={name:\"GeometryPipelineStage\",STRUCT_ID_PROCESSED_ATTRIBUTES_VS:\"ProcessedAttributesVS\",STRUCT_ID_PROCESSED_ATTRIBUTES_FS:\"ProcessedAttributesFS\",STRUCT_NAME_PROCESSED_ATTRIBUTES:\"ProcessedAttributes\",FUNCTION_ID_INITIALIZE_ATTRIBUTES:\"initializeAttributes\",FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES:\"void initializeAttributes(out ProcessedAttributes attributes)\",FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS:\"setDynamicVaryingsVS\",FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS:\"setDynamicVaryingsFS\",FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS:\"void setDynamicVaryings(inout ProcessedAttributes attributes)\"};Ms.process=function(e,t,n){let i=e.shaderBuilder,o=e.model;i.addStruct(Ms.STRUCT_ID_PROCESSED_ATTRIBUTES_VS,\"ProcessedAttributes\",Ce.VERTEX),i.addStruct(Ms.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\"ProcessedAttributes\",Ce.FRAGMENT),i.addStruct(fy.STRUCT_ID_SELECTED_FEATURE,fy.STRUCT_NAME_SELECTED_FEATURE,Ce.BOTH),i.addFunction(Ms.FUNCTION_ID_INITIALIZE_ATTRIBUTES,Ms.FUNCTION_SIGNATURE_INITIALIZE_ATTRIBUTES,Ce.VERTEX),i.addVarying(\"vec3\",\"v_positionWC\"),i.addVarying(\"vec3\",\"v_positionEC\"),i.addStructField(Ms.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\"vec3\",\"positionWC\"),i.addStructField(Ms.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\"vec3\",\"positionEC\"),i.addFunction(Ms.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS,Ms.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS,Ce.VERTEX),i.addFunction(Ms.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS,Ms.FUNCTION_SIGNATURE_SET_DYNAMIC_VARYINGS,Ce.FRAGMENT),o.type===rr.TILE_PNTS&&i.addDefine(\"HAS_SRGB_COLOR\",void 0,Ce.FRAGMENT);let s=n.mode!==ie.SCENE3D&&!n.scene3DOnly&&o._projectTo2D,a=l(e.runtimeNode.node.instances),c=s&&!a,d=t.attributes.length;for(let u=0;u<d;u++){let m=t.attributes[u],p=tn.getAttributeLocationCount(m.type),b=m.semantic===St.POSITION,f;p>1?(f=e.attributeIndex,e.attributeIndex+=p):b&&!c?f=0:f=e.attributeIndex++,bDe(e,m,f,p,s,a)}LDe(i,t.attributes),t.primitiveType===we.POINTS&&i.addDefine(\"PRIMITIVE_TYPE_POINTS\"),i.addVertexLines(rW),i.addFragmentLines(oW)};function bDe(e,t,n,i,o,r){let s=e.shaderBuilder,a=qt.getAttributeInfo(t),c=o&&!r;i>1?xDe(e,t,n,i):gDe(e,t,n,c),TDe(s,a,c),_De(s,a),l(t.semantic)&&yDe(s,t),SDe(s,a,o),CDe(s,a,c),VDe(s,a)}function yDe(e,t){let n=t.semantic,i=t.setIndex;switch(n){case St.NORMAL:e.addDefine(\"HAS_NORMALS\");break;case St.TANGENT:e.addDefine(\"HAS_TANGENTS\");break;case St.FEATURE_ID:e.addDefine(`HAS${n}_${i}`);break;case St.TEXCOORD:case St.COLOR:e.addDefine(`HAS_${n}_${i}`)}}function gDe(e,t,n,i){let o=t.quantization,r,s;l(o)?(r=o.type,s=o.componentDatatype):(r=t.type,s=t.componentDatatype);let a=t.semantic,c=t.setIndex;a===St.FEATURE_ID&&c>=e.featureIdVertexAttributeSetIndex&&(e.featureIdVertexAttributeSetIndex=c+1);let d=a===St.POSITION,u=d?0:n,m=tn.getNumberOfComponents(r),p={index:u,value:l(t.buffer)?void 0:t.constant,vertexBuffer:t.buffer,count:t.count,componentsPerAttribute:m,componentDatatype:s,offsetInBytes:t.byteOffset,strideInBytes:t.byteStride,normalize:t.normalized};if(e.attributes.push(p),!d||!i)return;let b=e.runtimePrimitive.positionBuffer2D,f={index:n,vertexBuffer:b,count:t.count,componentsPerAttribute:m,componentDatatype:Q.FLOAT,offsetInBytes:0,strideInBytes:void 0,normalize:t.normalized};e.attributes.push(f)}function xDe(e,t,n,i){let o=t.quantization,r,s;l(o)?(r=o.type,s=o.componentDatatype):(r=t.type,s=t.componentDatatype);let a=t.normalized,d=tn.getNumberOfComponents(r)/i,u=Q.getSizeInBytes(s),m=d*u,p=t.byteStride;for(let b=0;b<i;b++){let f=t.byteOffset+b*m,x={index:n+b,vertexBuffer:t.buffer,componentsPerAttribute:d,componentDatatype:s,offsetInBytes:f,strideInBytes:p,normalize:a};e.attributes.push(x)}}function _De(e,t){let n=t.variableName,i=`v_${n}`,o;n===\"normalMC\"?(i=\"v_normalEC\",o=t.glslType):n===\"tangentMC\"?(o=\"vec3\",i=\"v_tangentEC\"):o=t.glslType,e.addVarying(o,i)}function TDe(e,t,n){let i=t.attribute.semantic,o=t.variableName,r,s;t.isQuantized?(r=`a_quantized_${o}`,s=t.quantizedGlslType):(r=`a_${o}`,s=t.glslType);let a=i===St.POSITION;a?e.setPositionAttribute(s,r):e.addAttribute(s,r),a&&n&&e.addAttribute(\"vec3\",\"a_position2D\")}function SDe(e,t,n){let i=Ms.STRUCT_ID_PROCESSED_ATTRIBUTES_VS,o=Ms.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,r=t.variableName;r===\"tangentMC\"?(e.addStructField(i,\"vec3\",\"tangentMC\"),e.addStructField(i,\"float\",\"tangentSignMC\"),e.addStructField(o,\"vec3\",\"tangentEC\")):r===\"normalMC\"?(e.addStructField(i,\"vec3\",\"normalMC\"),e.addStructField(o,\"vec3\",\"normalEC\")):(e.addStructField(i,t.glslType,r),e.addStructField(o,t.glslType,r)),r===\"positionMC\"&&n&&e.addStructField(i,\"vec3\",\"position2D\")}function CDe(e,t,n){let i=Ms.FUNCTION_ID_INITIALIZE_ATTRIBUTES,o=t.variableName;if(o===\"positionMC\"&&n&&e.addFunctionLines(i,[\"attributes.position2D = a_position2D;\"]),t.isQuantized)return;let s=[];o===\"tangentMC\"?(s.push(\"attributes.tangentMC = a_tangentMC.xyz;\"),s.push(\"attributes.tangentSignMC = a_tangentMC.w;\")):s.push(`attributes.${o} = a_${o};`),e.addFunctionLines(i,s)}function VDe(e,t){let n=t.attribute.semantic,i=t.attribute.setIndex;if(l(n)&&!l(i))return;let o=Ms.FUNCTION_ID_SET_DYNAMIC_VARYINGS_VS,r=t.variableName,s=`v_${r} = attributes.${r};`;e.addFunctionLines(o,[s]),o=Ms.FUNCTION_ID_SET_DYNAMIC_VARYINGS_FS,s=`attributes.${r} = v_${r};`,e.addFunctionLines(o,[s])}function LDe(e,t){let n=!1,i=!1;for(let o=0;o<t.length;o++){let r=t[o];r.semantic===St.NORMAL?n=!0:r.semantic===St.TANGENT&&(i=!0)}!n||!i||(e.addDefine(\"HAS_BITANGENTS\"),e.addVarying(\"vec3\",\"v_bitangentEC\"),e.addStructField(Ms.STRUCT_ID_PROCESSED_ATTRIBUTES_VS,\"vec3\",\"bitangentMC\"),e.addStructField(Ms.STRUCT_ID_PROCESSED_ATTRIBUTES_FS,\"vec3\",\"bitangentEC\"))}var aW=Ms;var p1n=T(S(),1);var a1n=T(S(),1),cW=`#ifdef LIGHTING_PBR vec3 computePbrLighting(czm_modelMaterial inputMaterial, ProcessedAttributes attributes) { czm_pbrParameters pbrParameters; pbrParameters.diffuseColor = inputMaterial.diffuse; pbrParameters.f0 = inputMaterial.specular; pbrParameters.roughness = inputMaterial.roughness; #ifdef USE_CUSTOM_LIGHT_COLOR vec3 lightColorHdr = model_lightColorHdr; #else vec3 lightColorHdr = czm_lightColorHdr; #endif vec3 color = inputMaterial.diffuse; #ifdef HAS_NORMALS color = czm_pbrLighting( attributes.positionEC, inputMaterial.normalEC, czm_lightDirectionEC, lightColorHdr, pbrParameters ); #ifdef USE_IBL_LIGHTING color += imageBasedLightingStage( attributes.positionEC, inputMaterial.normalEC, czm_lightDirectionEC, lightColorHdr, pbrParameters ); #endif #endif color *= inputMaterial.occlusion; color += inputMaterial.emissive; // In HDR mode, the frame buffer is in linear color space. The // post-processing stages (see PostProcessStageCollection) will handle // tonemapping. However, if HDR is not enabled, we must tonemap else large // values may be clamped to 1.0 #ifndef HDR color = czm_acesTonemapping(color); #endif return color; } #endif void lightingStage(inout czm_modelMaterial material, ProcessedAttributes attributes) { // Even though the lighting will only set the diffuse color, // pass all other properties so further stages have access to them. vec3 color = vec3(0.0); #ifdef LIGHTING_PBR color = computePbrLighting(material, attributes); #else // unlit color = material.diffuse; #endif #ifdef HAS_POINT_CLOUD_COLOR_STYLE // The colors resulting from point cloud styles are adjusted differently. color = czm_gammaCorrect(color); #elif !defined(HDR) // If HDR is not enabled, the frame buffer stores sRGB colors rather than // linear colors"
}