{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 25,
    "total_chunks": 194,
    "chunk_size": 5360,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.660Z"
  },
  "content": "= sense * 7.62939453125e-6; // 2^-17 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 7.6293945311019700e-6; // atan(2^-17) // Iteration 19 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 3.814697265625e-6; // 2^-18 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 3.8146972656064961e-6; // atan(2^-18) // Iteration 20 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 1.9073486328125e-6; // 2^-19 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 1.9073486328101870e-6; // atan(2^-19) // Iteration 21 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 9.5367431640625e-7; // 2^-20 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 9.5367431640596084e-7; // atan(2^-20) // Iteration 22 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 4.76837158203125e-7; // 2^-21 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 4.7683715820308884e-7; // atan(2^-21) // Iteration 23 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 2.384185791015625e-7; // 2^-22 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 2.3841857910155797e-7; // atan(2^-22) // Iteration 24 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 1.1920928955078125e-7; // 2^-23 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; // angle -= sense * 1.1920928955078068e-7; // atan(2^-23) return vector; } /** * Computes the cosine and sine of the provided angle using the CORDIC algorithm. * * @name czm_cosineAndSine * @glslFunction * * @param {float} angle The angle in radians. * * @returns {vec2} The resulting cosine of the angle (as the x coordinate) and sine of the angle (as the y coordinate). * * @example * vec2 v = czm_cosineAndSine(czm_piOverSix); * float cosine = v.x; * float sine = v.y; */ vec2 czm_cosineAndSine(float angle) { if (angle < -czm_piOverTwo || angle > czm_piOverTwo) { if (angle < 0.0) { return -cordic(angle + czm_pi); } else { return -cordic(angle - czm_pi); } } else { return cordic(angle); } } `;var ZPt=T(S(),1),_R=`/** * Decompresses texture coordinates that were packed into a single float. * * @name czm_decompressTextureCoordinates * @glslFunction * * @param {float} encoded The compressed texture coordinates. * @returns {vec2} The decompressed texture coordinates. */ vec2 czm_decompressTextureCoordinates(float encoded) { float temp = encoded / 4096.0; float xZeroTo4095 = floor(temp); float stx = xZeroTo4095 / 4095.0; float sty = (encoded - xZeroTo4095 * 4096.0) / 4095.0; return vec2(stx, sty); } `;var GPt=T(S(),1),TR=`/** * Get default parameters for physically based rendering. These defaults * describe a rough dielectric (non-metal) surface (e.g. rough plastic). * * @return {czm_pbrParameters} Default parameters for {@link czm_pbrLighting} */ czm_pbrParameters czm_defaultPbrMaterial() { czm_pbrParameters results; results.diffuseColor = vec3(1.0); results.roughness = 1.0; const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04); results.f0 = REFLECTANCE_DIELECTRIC; return results; } `;var XPt=T(S(),1),SR=`// emulated noperspective #if (__VERSION__ == 300 || defined(GL_EXT_frag_depth)) && !defined(LOG_DEPTH) out float v_WindowZ; #endif /** * Emulates GL_DEPTH_CLAMP, which is not available in WebGL 1 or 2. * GL_DEPTH_CLAMP clamps geometry that is outside the near and far planes, * capping the shadow volume. More information here: * https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_depth_clamp.txt. * * When GL_EXT_frag_depth is available we emulate GL_DEPTH_CLAMP by ensuring * no geometry gets clipped by setting the clip space z value to 0.0 and then * sending the unaltered screen space z value (using emulated noperspective * interpolation) to the frag shader where it is clamped to [0,1] and then * written with gl_FragDepth (see czm_writeDepthClamp). This technique is based on: * https://stackoverflow.com/questions/5960757/how-to-emulate-gl-depth-clamp-nv. * * When GL_EXT_frag_depth is not available, which is the case on some mobile * devices, we must attempt to fix this only in the vertex shader. * The approach is to clamp the z value to the far plane, which closes the * shadow volume but also distorts the geometry, so there can still be artifacts * on frustum seams. * * @name czm_depthClamp * @glslFunction * * @param {vec4} coords The vertex in clip coordinates. * @returns {vec4} The modified vertex. * * @example * gl_Position = czm_depthClamp(czm_modelViewProjection * vec4(position, 1.0)); * * @see czm_writeDepthClamp */ vec4 czm_depthClamp(vec4 coords) { #ifndef LOG_DEPTH #if __VERSION__ == 300 || defined(GL_EXT_frag_depth) v_WindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w; coords.z = 0.0; #else coords.z = min(coords.z, coords.w); #endif #endif return coords; } `;var WPt=T(S(),1),CR=`/** * Computes a 3x3 rotation matrix that transforms vectors from an ellipsoid's east-north-up coordinate system * to eye coordinates. In east-north-up coordinates, x points east, y points north, and z points along the * surface normal. East-north-up can be used as an ellipsoid's tangent space for operations such as bump mapping. * <br /><br /> * The ellipsoid is assumed to be centered at the"
}