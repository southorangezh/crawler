{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 60,
    "total_chunks": 194,
    "chunk_size": 7057,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.682Z"
  },
  "content": "endPlaneEC; endPlaneEC.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz; endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd); // Right plane v_rightPlaneEC.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz; v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart); v_texcoordNormalizationAndStartEcYZ.x = abs(endNormalAndTextureCoordinateNormalizationX.w); v_texcoordNormalizationAndStartEcYZ.y = rightNormalAndTextureCoordinateNormalizationY.w; #endif // COLUMBUS_VIEW_2D v_endEcAndStartEcX.xyz = ecEnd; v_endEcAndStartEcX.w = ecStart.x; v_texcoordNormalizationAndStartEcYZ.zw = ecStart.yz; #ifdef PER_INSTANCE_COLOR v_color = czm_batchTable_color(batchId); #endif // PER_INSTANCE_COLOR // Compute a normal along which to \"push\" the position out, extending the miter depending on view distance. // Position has already been \"pushed\" by unit length along miter normal, and miter normals are encoded in the planes. // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be. vec4 positionRelativeToEye = czm_computePosition(); // Check distance to the end plane and start plane, pick the plane that is closer vec4 positionEC = czm_modelViewRelativeToEye * positionRelativeToEye; // w = 1.0, see czm_computePosition float absStartPlaneDistance = abs(czm_planeDistance(startPlaneEC, positionEC.xyz)); float absEndPlaneDistance = abs(czm_planeDistance(endPlaneEC, positionEC.xyz)); vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlaneEC.xyz, endPlaneEC.xyz); vec3 upOrDown = normalize(cross(v_rightPlaneEC.xyz, planeDirection)); // Points \"up\" for start plane, \"down\" at end plane. vec3 normalEC = normalize(cross(planeDirection, upOrDown)); // In practice, the opposite seems to work too. // Extrude bottom vertices downward for far view distances, like for GroundPrimitives upOrDown = cross(forwardDirectionEC, normalEC); upOrDown = float(czm_sceneMode == czm_sceneMode3D) * upOrDown; upOrDown = float(v_texcoordNormalizationAndStartEcYZ.y > 1.0 || v_texcoordNormalizationAndStartEcYZ.y < 0.0) * upOrDown; upOrDown = min(GLOBE_MINIMUM_ALTITUDE, czm_geometricToleranceOverMeter * length(positionRelativeToEye.xyz)) * upOrDown; positionEC.xyz += upOrDown; v_texcoordNormalizationAndStartEcYZ.y = czm_branchFreeTernary(v_texcoordNormalizationAndStartEcYZ.y > 1.0, 0.0, abs(v_texcoordNormalizationAndStartEcYZ.y)); // @uranus change: \\u8BA1\\u7B97\\u5916\\u6269\\u53D8\\u91CF v_aa_out = 1.0 / czm_pixelRatio; // \\u7EBF\\u6BB5\\u9876\\u70B9\\u5916\\u6269\\u4E24\\u4E2A\\u50CF\\u7D20 float width_out = v_aa_out * 2.0; // @uranus change end // Determine distance along normalEC to push for a volume of appropriate width. // Make volumes about double pixel width for a conservative fit - in practice the // extra cost here is minimal compared to the loose volume heights. // // N = normalEC (guaranteed \"right-facing\") // R = rightEC // p = angle between N and R // w = distance to push along R if R == N // d = distance to push along N // // N R // { p| } * cos(p) = dot(N, R) = w / d // d | |w * d = w / dot(N, R) // { | } // o---------- polyline segment ----> // // @uranus change \\u5BBD\\u5EA6\\u5916\\u6269 float width = czm_batchTable_width(batchId) + width_out; #ifdef WIDTH_VARYING // @uranus change: \\u8BA1\\u7B97\\u5916\\u6269\\u53D8\\u91CF v_width = width - width_out; #endif // @uranus change: \\u8BA1\\u7B97\\u5916\\u6269\\u53D8\\u91CF v_aa_width = width; v_startPlaneNormalEcAndHalfWidth.xyz = startPlaneEC.xyz; v_startPlaneNormalEcAndHalfWidth.w = width * 0.5; v_endPlaneNormalEcAndBatchId.xyz = endPlaneEC.xyz; v_endPlaneNormalEcAndBatchId.w = batchId; width = width * max(0.0, czm_metersPerPixel(positionEC)); // width = distance to push along R width = width / dot(normalEC, v_rightPlaneEC.xyz); // width = distance to push along N // Determine if this vertex is on the \"left\" or \"right\" #ifdef COLUMBUS_VIEW_2D normalEC *= sign(texcoordNormalization2D.x); #else normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w); #endif positionEC.xyz += width * normalEC; gl_Position = czm_depthClamp(czm_projection * positionEC); #ifdef ANGLE_VARYING // Approximate relative screen space direction of the line. vec2 approxLineDirection = normalize(vec2(forwardDirectionEC.x, -forwardDirectionEC.y)); approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y); v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y); #endif } `;var ojt=T(S(),1);var O4t=T(S(),1),YE=`#ifdef VECTOR_TILE uniform vec4 u_highlightColor; #endif in vec2 v_st; in vec4 v_color; in float v_aa_width; in float v_aa_out; // @uranus change: \\u65B0\\u589E PolylineColorAppearanceFS \\u7528\\u6765\\u5B9E\\u73B0\\u7EBF\\u6BB5\\u8FB9\\u7F18\\u6297\\u952F\\u9F7F void main() { vec2 st = v_st; st.t = czm_readNonPerspective(st.t, gl_FragCoord.w); float width_out = v_aa_out * 2.0; // \\u8FB9\\u7F18\\u6297\\u952F\\u9F7F\\u989D\\u5916\\u589E\\u52A0\\u7684\\u5BBD\\u5EA6 float dist = (abs(st.t - 0.5)) * v_aa_width * 2.0; // t - 0.5 \\u8DDD\\u79BB\\u4E2D\\u5FC3\\u70B9\\u7684\\u4F4D\\u7F6E\\uFF08\\u4E24\\u500D\\u5316\\uFF09 float alpha = clamp((v_aa_width - dist - (1.0 / czm_pixelRatio)) / width_out, 0.0, 1.0); // \\u6297\\u952F\\u9F7F\\u586B\\u5145\\u900F\\u660E\\u5EA6 vec4 color = v_color; color.a *= alpha; out_FragColor = czm_gammaCorrect(color); } `;var H4t=T(S(),1),OE=`in vec3 position3DHigh; in vec3 position3DLow; in vec3 prevPosition3DHigh; in vec3 prevPosition3DLow; in vec3 nextPosition3DHigh; in vec3 nextPosition3DLow; in vec2 expandAndWidth; in vec4 color; in vec2 st; in float batchId; out vec4 v_color; // @uranus change \\u65B0\\u589E\\u53D8\\u91CF\\u7528\\u6765\\u8BA1\\u7B97\\u8FB9\\u7F18\\u6297\\u952F\\u9F7F out float v_aa_width; out float v_aa_out; out vec2 v_st; void main() { // @uranus change: \\u8BA1\\u7B97\\u5916\\u6269\\u53D8\\u91CF v_aa_out = 1.0 / czm_pixelRatio; // \\u7EBF\\u6BB5\\u9876\\u70B9\\u5916\\u6269\\u4E24\\u4E2A\\u50CF\\u7D20 float width_out = v_aa_out * 2.0; // @uranus change end float expandDir = expandAndWidth.x; // @uranus change \\u5BBD\\u5EA6\\u5916\\u6269 float width = abs(expandAndWidth.y) + 0.5 + width_out; bool usePrev = expandAndWidth.y < 0.0; vec4 p = czm_computePosition(); vec4 prev = czm_computePrevPosition(); vec4 next = czm_computeNextPosition(); float angle; vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle); gl_Position = czm_viewportOrthographic * positionWC; v_color = color; // @uranus change: \\u8BA1\\u7B97\\u5916\\u6269\\u53D8\\u91CF v_aa_width = width; v_st.s = st.s; v_st.t = czm_writeNonPerspective(st.t, gl_Position.w); // @uranus change end } `;var J4t=T(S(),1),dd=`void clipLineSegmentToNearPlane( vec3 p0, vec3 p1, out vec4 positionWC, out bool clipped, out bool culledByNearPlane, out vec4 clippedPositionEC) { culledByNearPlane = false; clipped = false; vec3 p0ToP1 = p1 - p0; float magnitude = length(p0ToP1); vec3 direction = normalize(p0ToP1); // Distance that p0 is behind the near plane. Negative means p0 is // in front"
}