{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 173,
    "total_chunks": 194,
    "chunk_size": 16578,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.753Z"
  },
  "content": "+ halfSize, -positionWC.z, 1.0); v_textureCoordinates = direction; } `;function R9(){this.show=!0,this._drawCommand=new je({primitiveType:we.TRIANGLES,boundingVolume:new ce,owner:this}),this._commands={drawCommand:this._drawCommand,computeCommand:void 0},this._boundingVolume=new ce,this._boundingVolume2D=new ce,this._texture=void 0,this._drawingBufferWidth=void 0,this._drawingBufferHeight=void 0,this._radiusTS=void 0,this._size=void 0,this.glowFactor=1,this._glowFactorDirty=!1,this._useHdr=void 0;let e=this;this._uniformMap={u_texture:function(){return e._texture},u_size:function(){return e._size}}}Object.defineProperties(R9.prototype,{glowFactor:{get:function(){return this._glowFactor},set:function(e){e=Math.max(e,0),this._glowFactor=e,this._glowFactorDirty=!0}}});var tyt=new D,nyt=new D,iyt=new se,Z9=new se;R9.prototype.update=function(e,t,n){if(!this.show)return;let i=e.mode;if(i===ie.SCENE2D||i===ie.MORPHING||!e.passes.render)return;let o=e.context,r=t.viewport.width,s=t.viewport.height;if(!l(this._texture)||r!==this._drawingBufferWidth||s!==this._drawingBufferHeight||this._glowFactorDirty||n!==this._useHdr){this._texture=this._texture&&this._texture.destroy(),this._drawingBufferWidth=r,this._drawingBufferHeight=s,this._glowFactorDirty=!1,this._useHdr=n;let R=Math.max(r,s);R=Math.pow(2,Math.ceil(Math.log(R)/Math.log(2))-2),R=Math.max(1,R);let G=n?o.halfFloatingPointTexture?Qe.HALF_FLOAT:Qe.FLOAT:Qe.UNSIGNED_BYTE;this._texture=new Ft({context:o,width:R,height:R,pixelFormat:at.RGBA,pixelDatatype:G}),this._glowLengthTS=this._glowFactor*5,this._radiusTS=1/(1+2*this._glowLengthTS)*.5;let X=this,v={u_radiusTS:function(){return X._radiusTS}};this._commands.computeCommand=new iu({fragmentShaderSource:V9,outputTexture:this._texture,uniformMap:v,persists:!1,owner:this,postExecute:function(){X._commands.computeCommand=void 0}})}let a=this._drawCommand;if(!l(a.vertexArray)){let R={direction:0},G=new Uint8Array(4*2);G[0]=0,G[1]=0,G[2]=255,G[3]=0,G[4]=255,G[5]=255,G[6]=0,G[7]=255;let X=pt.createVertexBuffer({context:o,typedArray:G,usage:Me.STATIC_DRAW}),v=[{index:R.direction,vertexBuffer:X,componentsPerAttribute:2,normalize:!0,componentDatatype:Q.UNSIGNED_BYTE}],W=pt.createIndexBuffer({context:o,typedArray:new Uint16Array([0,1,2,0,2,3]),usage:Me.STATIC_DRAW,indexDatatype:Ae.UNSIGNED_SHORT});a.vertexArray=new ti({context:o,attributes:v,indexBuffer:W}),a.shaderProgram=Ht.fromCache({context:o,vertexShaderSource:L9,fragmentShaderSource:C9,attributeLocations:R}),a.renderState=Ne.fromCache({blending:un.ALPHA_BLEND}),a.uniformMap=this._uniformMap}let c=o.uniformState.sunPositionWC,d=o.uniformState.sunPositionColumbusView,u=this._boundingVolume,m=this._boundingVolume2D;h.clone(c,u.center),m.center.x=d.z,m.center.y=d.x,m.center.z=d.y,u.radius=P.SOLAR_RADIUS+P.SOLAR_RADIUS*this._glowLengthTS,m.radius=u.radius,i===ie.SCENE3D?ce.clone(u,a.boundingVolume):i===ie.COLUMBUS_VIEW&&ce.clone(m,a.boundingVolume);let p=Zi.computeActualWgs84Position(e,c,Z9),b=h.magnitude(h.subtract(p,e.camera.position,Z9)),f=o.uniformState.projection,x=iyt;x.x=0,x.y=0,x.z=-b,x.w=1;let _=M.multiplyByVector(f,x,Z9),C=Zi.clipToGLWindowCoordinates(t.viewport,_,tyt);x.x=P.SOLAR_RADIUS;let V=M.multiplyByVector(f,x,Z9),L=Zi.clipToGLWindowCoordinates(t.viewport,V,nyt);return this._size=D.magnitude(D.subtract(L,C,Z9)),this._size=2*this._size*(1+2*this._glowLengthTS),this._size=Math.ceil(this._size),this._commands};R9.prototype.isDestroyed=function(){return!1};R9.prototype.destroy=function(){let e=this._drawCommand;return e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),e.shaderProgram=e.shaderProgram&&e.shaderProgram.destroy(),this._texture=this._texture&&this._texture.destroy(),me(this)};var G9=R9;function nL(e){return on(`Assets/Textures/SkyBox/tycho2t3_80_${e}.jpg`)}function oyt(e){e._renderLoopRunning=!0;let t=0;function n(i){if(!e.isDestroyed())if(e._useDefaultRenderLoop)try{let o=e._targetFrameRate;if(!l(o))e.resize(),e.render(),requestAnimationFrame(n);else{let r=1e3/o,s=i-t;s>r&&(e.resize(),e.render(),t=i-s%r),requestAnimationFrame(n)}}catch(o){e._useDefaultRenderLoop=!1,e._renderLoopRunning=!1,e._showRenderLoopErrors&&e.showErrorPanel(\"An error occurred while rendering. Rendering has stopped.\",void 0,o)}else e._renderLoopRunning=!1}requestAnimationFrame(n)}function bTe(e){let t=e._useBrowserRecommendedResolution?1:window.devicePixelRatio;return t*=e._resolutionScale,l(e._scene)&&(e._scene.pixelRatio=t),t}function yTe(e){let t=e._canvas,n=t.clientWidth,i=t.clientHeight,o=bTe(e);e._canvasClientWidth=n,e._canvasClientHeight=i,n*=o,i*=o,t.width=n,t.height=i,e._canRender=n!==0&&i!==0,e._lastDevicePixelRatio=window.devicePixelRatio}function gTe(e){let t=e._canvas,n=t.width,i=t.height;if(n!==0&&i!==0){let o=e._scene.camera.frustum;l(o.aspectRatio)?o.aspectRatio=n/i:(o.top=o.right*(i/n),o.bottom=-o.top)}}function KT(e,t){e=Xn(e),t=g(t,g.EMPTY_OBJECT);let n=document.createElement(\"div\");n.className=\"cesium-widget\",e.appendChild(n);let i=document.createElement(\"canvas\"),o=Ut.supportsImageRenderingPixelated();this._supportsImageRenderingPixelated=o,o&&(i.style.imageRendering=Ut.imageRenderingValue()),i.oncontextmenu=function(){return!1},i.onselectstart=function(){return!1};function r(){i!==i.ownerDocument.activeElement&&i.ownerDocument.activeElement.blur()}g(t.blurActiveElementOnCanvasFocus,!0)&&(i.addEventListener(\"mousedown\",r),i.addEventListener(\"pointerdown\",r)),n.appendChild(i);let a=document.createElement(\"div\");a.className=\"cesium-widget-credits\";let c=l(t.creditContainer)?Xn(t.creditContainer):n;c.appendChild(a);let d=l(t.creditViewport)?Xn(t.creditViewport):n,u=g(t.showRenderLoopErrors,!0),m=g(t.useBrowserRecommendedResolution,!0);this._element=n,this._container=e,this._canvas=i,this._canvasClientWidth=0,this._canvasClientHeight=0,this._lastDevicePixelRatio=0,this._creditViewport=d,this._creditContainer=c,this._innerCreditContainer=a,this._canRender=!1,this._renderLoopRunning=!1,this._showRenderLoopErrors=u,this._resolutionScale=1,this._useBrowserRecommendedResolution=m,this._forceResize=!1,this._clock=l(t.clock)?t.clock:new th,yTe(this);try{let p=new b9({canvas:i,contextOptions:t.contextOptions,creditContainer:a,creditViewport:d,mapProjection:t.mapProjection,orderIndependentTranslucency:t.orderIndependentTranslucency,scene3DOnly:g(t.scene3DOnly,!1),shadows:t.shadows,mapMode2D:t.mapMode2D,requestRenderMode:t.requestRenderMode,maximumRenderTimeChange:t.maximumRenderTimeChange,depthPlaneEllipsoidOffset:t.depthPlaneEllipsoidOffset,msaaSamples:t.msaaSamples});this._scene=p,p.camera.constrainedAxis=h.UNIT_Z,bTe(this),gTe(this);let b=g(p.mapProjection.ellipsoid,oe.WGS84),f=t.globe;l(f)||(f=new yw(b)),f!==!1&&(p.globe=f,p.globe.shadows=g(t.terrainShadows,_n.RECEIVE_ONLY));let x=t.skyBox;l(x)||(x=new S9({sources:{positiveX:nL(\"px\"),negativeX:nL(\"mx\"),positiveY:nL(\"py\"),negativeY:nL(\"my\"),positiveZ:nL(\"pz\"),negativeZ:nL(\"mz\")}})),x!==!1&&(p.skyBox=x,p.sun=new G9,p.moon=new Cw);let _=t.skyAtmosphere;l(_)||(_=new x9(b),_.show=t.globe!==!1&&f.show),_!==!1&&(p.skyAtmosphere=_);let C=t.baseLayer;t.globe!==!1&&C!==!1&&(l(C)||(C=ha.fromWorldImagery()),p.imageryLayers.add(C)),l(t.terrainProvider)&&t.globe!==!1&&(p.terrainProvider=t.terrainProvider),l(t.terrain)&&t.globe!==!1&&p.setTerrain(t.terrain),this._screenSpaceEventHandler=new Od(i),l(t.sceneMode)&&(t.sceneMode===ie.SCENE2D&&this._scene.morphTo2D(0),t.sceneMode===ie.COLUMBUS_VIEW&&this._scene.morphToColumbusView(0)),this._useDefaultRenderLoop=void 0,this.useDefaultRenderLoop=g(t.useDefaultRenderLoop,!0),this._targetFrameRate=void 0,this.targetFrameRate=t.targetFrameRate;let V=this;this._onRenderError=function(L,R){V._useDefaultRenderLoop=!1,V._renderLoopRunning=!1,V._showRenderLoopErrors&&V.showErrorPanel(\"An error occurred while rendering. Rendering has stopped.\",void 0,R)},p.renderError.addEventListener(this._onRenderError)}catch(p){throw u&&this.showErrorPanel(\"Error constructing CesiumWidget.\",'Visit <a href=\"http://get.webgl.org\">http://get.webgl.org</a> to verify that your web browser and hardware support WebGL. Consider trying a different web browser or updating your video drivers. Detailed error information is below:',p),p}}Object.defineProperties(KT.prototype,{container:{get:function(){return this._container}},canvas:{get:function(){return this._canvas}},creditContainer:{get:function(){return this._creditContainer}},creditViewport:{get:function(){return this._creditViewport}},scene:{get:function(){return this._scene}},imageryLayers:{get:function(){return this._scene.imageryLayers}},terrainProvider:{get:function(){return this._scene.terrainProvider},set:function(e){this._scene.terrainProvider=e}},creditDisplay:{get:function(){return this._scene.frameState.creditDisplay}},camera:{get:function(){return this._scene.camera}},clock:{get:function(){return this._clock}},screenSpaceEventHandler:{get:function(){return this._screenSpaceEventHandler}},targetFrameRate:{get:function(){return this._targetFrameRate},set:function(e){this._targetFrameRate=e}},useDefaultRenderLoop:{get:function(){return this._useDefaultRenderLoop},set:function(e){this._useDefaultRenderLoop!==e&&(this._useDefaultRenderLoop=e,e&&!this._renderLoopRunning&&oyt(this))}},resolutionScale:{get:function(){return this._resolutionScale},set:function(e){this._resolutionScale!==e&&(this._resolutionScale=e,this._forceResize=!0)}},useBrowserRecommendedResolution:{get:function(){return this._useBrowserRecommendedResolution},set:function(e){this._useBrowserRecommendedResolution!==e&&(this._useBrowserRecommendedResolution=e,this._forceResize=!0)}}});KT.prototype.showErrorPanel=function(e,t,n){let i=this._element,o=document.createElement(\"div\");o.className=\"cesium-widget-errorPanel\";let r=document.createElement(\"div\");r.className=\"cesium-widget-errorPanel-content\",o.appendChild(r);let s=document.createElement(\"div\");s.className=\"cesium-widget-errorPanel-header\",s.appendChild(document.createTextNode(e)),r.appendChild(s);let a=document.createElement(\"div\");a.className=\"cesium-widget-errorPanel-scroll\",r.appendChild(a);function c(){a.style.maxHeight=`${Math.max(Math.round(i.clientHeight*.9-100),30)}px`}c(),l(window.addEventListener)&&window.addEventListener(\"resize\",c,!1);let d=l(t),u=l(n);if(d||u){let b=document.createElement(\"div\");if(b.className=\"cesium-widget-errorPanel-message\",a.appendChild(b),u){let f=Mf(n);d||(typeof n==\"string\"&&(n=new Error(n)),t=Mf({name:n.name,message:n.message}),f=n.stack),typeof console<\"u\"&&console.error(`${e} ${t} ${f}`);let x=document.createElement(\"div\");x.className=\"cesium-widget-errorPanel-message-details collapsed\";let _=document.createElement(\"span\");_.className=\"cesium-widget-errorPanel-more-details\",_.appendChild(document.createTextNode(\"See more...\")),x.appendChild(_),x.onclick=function(C){x.removeChild(_),x.appendChild(document.createTextNode(f)),x.className=\"cesium-widget-errorPanel-message-details\",r.className=\"cesium-widget-errorPanel-content expanded\",x.onclick=void 0},a.appendChild(x)}b.innerHTML=`<p>${t}</p>`}let m=document.createElement(\"div\");m.className=\"cesium-widget-errorPanel-buttonPanel\",r.appendChild(m);let p=document.createElement(\"button\");p.setAttribute(\"type\",\"button\"),p.className=\"cesium-button\",p.appendChild(document.createTextNode(\"OK\")),p.onclick=function(){l(c)&&l(window.removeEventListener)&&window.removeEventListener(\"resize\",c,!1),i.removeChild(o)},m.appendChild(p),i.appendChild(o)};KT.prototype.isDestroyed=function(){return!1};KT.prototype.destroy=function(){l(this._scene)&&(this._scene.renderError.removeEventListener(this._onRenderError),this._scene=this._scene.destroy()),this._container.removeChild(this._element),this._creditContainer.removeChild(this._innerCreditContainer),me(this)};KT.prototype.resize=function(){let e=this._canvas;!this._forceResize&&this._canvasClientWidth===e.clientWidth&&this._canvasClientHeight===e.clientHeight&&this._lastDevicePixelRatio===window.devicePixelRatio||(this._forceResize=!1,yTe(this),gTe(this),this._scene.requestRender())};KT.prototype.render=function(){if(this._canRender){this._scene.initializeFrame();let e=this._clock.tick();this._scene.render(e)}else this._clock.tick()};var E9=KT;var k3i=T(S(),1),X9=`uniform sampler2D u_noiseTexture; uniform vec3 u_noiseTextureDimensions; uniform float u_noiseDetail; in vec2 v_offset; in vec3 v_maximumSize; in vec4 v_color; in float v_slice; in float v_brightness; float wrap(float value, float rangeLength) { if(value < 0.0) { float absValue = abs(value); float modValue = mod(absValue, rangeLength); return mod(rangeLength - modValue, rangeLength); } return mod(value, rangeLength); } vec3 wrapVec(vec3 value, float rangeLength) { return vec3(wrap(value.x, rangeLength), wrap(value.y, rangeLength), wrap(value.z, rangeLength)); } vec2 voxelToUV(vec3 voxelIndex) { float textureSliceWidth = u_noiseTextureDimensions.x; float noiseTextureRows = u_noiseTextureDimensions.y; float inverseNoiseTextureRows = u_noiseTextureDimensions.z; float textureSliceWidthSquared = textureSliceWidth * textureSliceWidth; vec2 inverseNoiseTextureDimensions = vec2(noiseTextureRows / textureSliceWidthSquared, inverseNoiseTextureRows / textureSliceWidth); vec3 wrappedIndex = wrapVec(voxelIndex, textureSliceWidth); float column = mod(wrappedIndex.z, textureSliceWidth * inverseNoiseTextureRows); float row = floor(wrappedIndex.z / textureSliceWidth * noiseTextureRows); float xPixelCoord = wrappedIndex.x + column * textureSliceWidth; float yPixelCoord = wrappedIndex.y + row * textureSliceWidth; return vec2(xPixelCoord, yPixelCoord) * inverseNoiseTextureDimensions; } // Interpolate a voxel with its neighbor (along the positive X-axis) vec4 lerpSamplesX(vec3 voxelIndex, float x) { vec2 uv0 = voxelToUV(voxelIndex); vec2 uv1 = voxelToUV(voxelIndex + vec3(1.0, 0.0, 0.0)); vec4 sample0 = texture(u_noiseTexture, uv0); vec4 sample1 = texture(u_noiseTexture, uv1); return mix(sample0, sample1, x); } vec4 sampleNoiseTexture(vec3 position) { float textureSliceWidth = u_noiseTextureDimensions.x; vec3 recenteredPos = position + vec3(textureSliceWidth / 2.0); vec3 lerpValue = fract(recenteredPos); vec3 voxelIndex = floor(recenteredPos); vec4 xLerp00 = lerpSamplesX(voxelIndex, lerpValue.x); vec4 xLerp01 = lerpSamplesX(voxelIndex + vec3(0.0, 0.0, 1.0), lerpValue.x); vec4 xLerp10 = lerpSamplesX(voxelIndex + vec3(0.0, 1.0, 0.0), lerpValue.x); vec4 xLerp11 = lerpSamplesX(voxelIndex + vec3(0.0, 1.0, 1.0), lerpValue.x); vec4 yLerp0 = mix(xLerp00, xLerp10, lerpValue.y); vec4 yLerp1 = mix(xLerp01, xLerp11, lerpValue.y); return mix(yLerp0, yLerp1, lerpValue.z); } // Intersection with a unit sphere with radius 0.5 at center (0, 0, 0). bool intersectSphere(vec3 origin, vec3 dir, float slice, out vec3 point, out vec3 normal) { float A = dot(dir, dir); float B = dot(origin, dir); float C = dot(origin, origin) - 0.25; float discriminant = (B * B) - (A * C); if(discriminant < 0.0) { return false; } float root = sqrt(discriminant); float t = (-B - root) / A; if(t < 0.0) { t = (-B + root) / A; } point = origin + t * dir; if(slice >= 0.0) { point.z = (slice / 2.0) - 0.5; if(length(point) > 0.5) { return false; } } normal = normalize(point); point -= czm_epsilon2 * normal; return true; } // Transforms the ray origin and direction into unit sphere space, // then transforms the result back into the ellipsoid's space. bool intersectEllipsoid(vec3 origin, vec3 dir, vec3 center, vec3 scale, float slice, out vec3 point, out vec3 normal) { if(scale.x <= 0.01 || scale.y < 0.01 || scale.z < 0.01) { return false; } vec3 o = (origin - center) / scale; vec3 d = dir / scale; vec3 p, n; bool intersected = intersectSphere(o, d, slice, p, n); if(intersected) { point = (p * scale) + center; normal = n; } return intersected; } // Assume that if phase shift is being called for octave i, // the frequency is of i - 1. This saves us from doing extra // division / multiplication operations. vec2 phaseShift2D(vec2 p, vec2 freq) { return (czm_pi / 2.0) * sin(freq.yx * p.yx); } vec2 phaseShift3D(vec3 p, vec2 freq) { return phaseShift2D(p.xy, freq) + czm_pi * vec2(sin(freq.x * p.z)); } // The cloud texture function derived from Gardner's 1985 paper, // \"Visual Simulation of Clouds.\" // https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf const float T0 = 0.6; // contrast of the texture pattern const float k = 0.1; // computed to produce a maximum value of 1 const float C0 = 0.8; // coefficient const float FX0 = 0.6; // frequency X const float FY0 = 0.6; // frequency Y const int octaves = 5; float T(vec3 point) { vec2 sum = vec2(0.0); float Ci = C0; vec2 FXY"
}