{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 16,
    "total_chunks": 194,
    "chunk_size": 5347,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.656Z"
  },
  "content": "identifier for the 3D {@link SceneMode} * * @name czm_sceneMode3D * @glslConstant * @see czm_sceneMode * @see czm_sceneMode2D * @see czm_sceneModeColumbusView * @see czm_sceneModeMorphing */ const float czm_sceneMode3D = 3.0; `;var n2t=T(S(),1),wZ=`/** * The constant identifier for the Columbus View {@link SceneMode} * * @name czm_sceneModeColumbusView * @glslConstant * @see czm_sceneMode * @see czm_sceneMode2D * @see czm_sceneMode3D * @see czm_sceneModeMorphing */ const float czm_sceneModeColumbusView = 1.0; `;var o2t=T(S(),1),FZ=`/** * The constant identifier for the Morphing {@link SceneMode} * * @name czm_sceneModeMorphing * @glslConstant * @see czm_sceneMode * @see czm_sceneMode2D * @see czm_sceneModeColumbusView * @see czm_sceneMode3D */ const float czm_sceneModeMorphing = 0.0; `;var s2t=T(S(),1),AZ=`/** * A built-in GLSL floating-point constant for one solar radius. * * @alias czm_solarRadius * @glslConstant * * @see CesiumMath.SOLAR_RADIUS * * @example * // GLSL declaration * const float czm_solarRadius = ...; */ const float czm_solarRadius = 695500000.0; `;var c2t=T(S(),1),MZ=`/** * A built-in GLSL floating-point constant for <code>3pi/2</code>. * * @alias czm_threePiOver2 * @glslConstant * * @see CesiumMath.THREE_PI_OVER_TWO * * @example * // GLSL declaration * const float czm_threePiOver2 = ...; * * // Example * float pi = (2.0 / 3.0) * czm_threePiOver2; */ const float czm_threePiOver2 = 4.71238898038469; `;var d2t=T(S(),1),NZ=`/** * A built-in GLSL floating-point constant for <code>2pi</code>. * * @alias czm_twoPi * @glslConstant * * @see CesiumMath.TWO_PI * * @example * // GLSL declaration * const float czm_twoPi = ...; * * // Example * float pi = czm_twoPi / 2.0; */ const float czm_twoPi = 6.283185307179586; `;var m2t=T(S(),1),kZ=`/** * The maximum latitude, in radians, both North and South, supported by a Web Mercator * (EPSG:3857) projection. Technically, the Mercator projection is defined * for any latitude up to (but not including) 90 degrees, but it makes sense * to cut it off sooner because it grows exponentially with increasing latitude. * The logic behind this particular cutoff value, which is the one used by * Google Maps, Bing Maps, and Esri, is that it makes the projection * square. That is, the rectangle is equal in the X and Y directions. * * The constant value is computed as follows: * czm_pi * 0.5 - (2.0 * atan(exp(-czm_pi))) * * @name czm_webMercatorMaxLatitude * @glslConstant */ const float czm_webMercatorMaxLatitude = 1.4844222297453324; `;var f2t=T(S(),1),UZ=`/** * @name czm_depthRangeStruct * @glslStruct */ struct czm_depthRangeStruct { float near; float far; }; `;var b2t=T(S(),1),DZ=`/** * Holds material information that can be used for lighting. Returned by all czm_getMaterial functions. * * @name czm_material * @glslStruct * * @property {vec3} diffuse Incoming light that scatters evenly in all directions. * @property {float} specular Intensity of incoming light reflecting in a single direction. * @property {float} shininess The sharpness of the specular reflection. Higher values create a smaller, more focused specular highlight. * @property {vec3} normal Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal. * @property {vec3} emission Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light. * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque. */ struct czm_material { vec3 diffuse; float specular; float shininess; vec3 normal; vec3 emission; float alpha; }; `;var g2t=T(S(),1),BZ=`/** * Used as input to every material's czm_getMaterial function. * * @name czm_materialInput * @glslStruct * * @property {float} s 1D texture coordinates. * @property {vec2} st 2D texture coordinates. * @property {vec3} str 3D texture coordinates. * @property {vec3} normalEC Unperturbed surface normal in eye coordinates. * @property {mat3} tangentToEyeMatrix Matrix for converting a tangent space normal to eye space. * @property {vec3} positionToEyeEC Vector from the fragment to the eye in eye coordinates. The magnitude is the distance in meters from the fragment to the eye. * @property {float} height The height of the terrain in meters above or below the WGS84 ellipsoid. Only available for globe materials. * @property {float} slope The slope of the terrain in radians. 0 is flat; pi/2 is vertical. Only available for globe materials. * @property {float} aspect The aspect of the terrain in radians. 0 is East, pi/2 is North, pi is West, 3pi/2 is South. Only available for globe materials. */ struct czm_materialInput { float s; vec2 st; vec3 str; vec3 normalEC; mat3 tangentToEyeMatrix; vec3 positionToEyeEC; float height; float slope; float aspect; }; `;var _2t=T(S(),1),YZ=`/** * Struct for representing a material for a {@link Model}. The model * rendering pipeline will pass this struct between material, custom shaders, * and lighting stages. This is not to be confused with {@link czm_material} * which is used by the older Fabric materials system, although they are similar. * <p> * All color values (diffuse, specular, emissive) are in linear color space. * </p> * * @name czm_modelMaterial * @glslStruct * * @property {vec3} diffuse Incoming light that scatters evenly"
}