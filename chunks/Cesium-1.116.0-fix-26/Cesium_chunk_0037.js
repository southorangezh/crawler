{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 37,
    "total_chunks": 194,
    "chunk_size": 6205,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.666Z"
  },
  "content": "{ return step(depth, czm_sampleShadowMap(shadowMap, uv)); } `;var mwt=T(S(),1),hG=` float czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness) { #ifdef USE_NORMAL_SHADING #ifdef USE_NORMAL_SHADING_SMOOTH float strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0); #else float strength = step(0.0, nDotL); #endif visibility *= strength; #endif visibility = max(visibility, darkness); return visibility; } #ifdef USE_CUBE_MAP_SHADOW float czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters) { float depthBias = shadowParameters.depthBias; float depth = shadowParameters.depth; float nDotL = shadowParameters.nDotL; float normalShadingSmooth = shadowParameters.normalShadingSmooth; float darkness = shadowParameters.darkness; vec3 uvw = shadowParameters.texCoords; depth -= depthBias; float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth); return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness); } #else float czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters) { float depthBias = shadowParameters.depthBias; float depth = shadowParameters.depth; float nDotL = shadowParameters.nDotL; float normalShadingSmooth = shadowParameters.normalShadingSmooth; float darkness = shadowParameters.darkness; vec2 uv = shadowParameters.texCoords; depth -= depthBias; #ifdef USE_SOFT_SHADOWS vec2 texelStepSize = shadowParameters.texelStepSize; float radius = 1.0; float dx0 = -texelStepSize.x * radius; float dy0 = -texelStepSize.y * radius; float dx1 = texelStepSize.x * radius; float dy1 = texelStepSize.y * radius; float visibility = ( czm_shadowDepthCompare(shadowMap, uv, depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth) ) * (1.0 / 9.0); #else float visibility = czm_shadowDepthCompare(shadowMap, uv, depth); #endif return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness); } #endif `;var fwt=T(S(),1),fG=`/** * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative. This is similar to the GLSL * built-in function <code>sign</code> except that returns 1.0 instead of 0.0 when the input value is 0.0. * * @name czm_signNotZero * @glslFunction * * @param {} value The value for which to determine the sign. * @returns {} 1.0 if the value is positive or zero, -1.0 if the value is negative. */ float czm_signNotZero(float value) { return value >= 0.0 ? 1.0 : -1.0; } vec2 czm_signNotZero(vec2 value) { return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y)); } vec3 czm_signNotZero(vec3 value) { return vec3(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z)); } vec4 czm_signNotZero(vec4 value) { return vec4(czm_signNotZero(value.x), czm_signNotZero(value.y), czm_signNotZero(value.z), czm_signNotZero(value.w)); } `;var bwt=T(S(),1),pG=`/** * Computes a color from the third order spherical harmonic coefficients and a normalized direction vector. * <p> * The order of the coefficients is [L00, L1_1, L10, L11, L2_2, L2_1, L20, L21, L22]. * </p> * * @name czm_sphericalHarmonics * @glslFunction * * @param {vec3} normal The normalized direction. * @param {vec3[9]} coefficients The third order spherical harmonic coefficients. * @returns {vec3} The color at the direction. * * @see https://graphics.stanford.edu/papers/envmap/envmap.pdf */ vec3 czm_sphericalHarmonics(vec3 normal, vec3 coefficients[9]) { vec3 L00 = coefficients[0]; vec3 L1_1 = coefficients[1]; vec3 L10 = coefficients[2]; vec3 L11 = coefficients[3]; vec3 L2_2 = coefficients[4]; vec3 L2_1 = coefficients[5]; vec3 L20 = coefficients[6]; vec3 L21 = coefficients[7]; vec3 L22 = coefficients[8]; float x = normal.x; float y = normal.y; float z = normal.z; return L00 + L1_1 * y + L10 * z + L11 * x + L2_2 * (y * x) + L2_1 * (y * z) + L20 * (3.0 * z * z - 1.0) + L21 * (z * x) + L22 * (x * x - y * y); } `;var gwt=T(S(),1),bG=`/** * Converts an sRGB color to a linear RGB color. * * @param {vec3|vec4} srgbIn The color in sRGB space * @returns {vec3|vec4} The color in linear color space. The vector type matches the input. */ vec3 czm_srgbToLinear(vec3 srgbIn) { return pow(srgbIn, vec3(2.2)); } vec4 czm_srgbToLinear(vec4 srgbIn) { vec3 linearOut = pow(srgbIn.rgb, vec3(2.2)); return vec4(linearOut, srgbIn.a); } `;var _wt=T(S(),1),yG=`/** * Creates a matrix that transforms vectors from tangent space to eye space. * * @name czm_tangentToEyeSpaceMatrix * @glslFunction * * @param {vec3} normalEC The normal vector in eye coordinates. * @param {vec3} tangentEC The tangent vector in eye coordinates. * @param {vec3} bitangentEC The bitangent vector in eye coordinates. * * @returns {mat3} The matrix that transforms from tangent space to eye space. * * @example * mat3 tangentToEye = czm_tangentToEyeSpaceMatrix(normalEC, tangentEC, bitangentEC); * vec3 normal = tangentToEye * texture(normalMap, st).xyz; */ mat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC) { vec3 normal = normalize(normalEC); vec3 tangent = normalize(tangentEC); vec3 bitangent = normalize(bitangentEC); return mat3(tangent.x , tangent.y , tangent.z, bitangent.x, bitangent.y, bitangent.z, normal.x , normal.y , normal.z); } `;var Swt=T(S(),1),gG=`/** * A wrapper around the texture (WebGL2) / textureCube (WebGL1) * function to allow for WebGL 1 support. * * @name czm_textureCube * @glslFunction * * @param {samplerCube} sampler The sampler. * @param {vec3} p The coordinates to sample the texture at. */ vec4 czm_textureCube(samplerCube sampler, vec3 p) { #if __VERSION__ == 300 return texture(sampler, p); #else return textureCube(sampler, p); #endif }`;var Vwt=T(S(),1),xG=`/** * Transforms a plane. * * @name czm_transformPlane *"
}