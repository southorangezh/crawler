{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 159,
    "total_chunks": 194,
    "chunk_size": 6558,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.745Z"
  },
  "content": "return RayShapeIntersection(intersection, farSide); } else { return RayShapeIntersection(-1.0 * farSide, intersection); } } void intersectFlippedWedge(in Ray ray, in vec2 minMaxAngle, out RayShapeIntersection intersections[2]) { intersections[0] = intersectHalfSpace(ray, minMaxAngle.x, false); intersections[1] = intersectHalfSpace(ray, minMaxAngle.y, true); } bool hitPositiveHalfPlane(in Ray ray, in vec4 intersection, in bool positiveNormal) { float normalSign = positiveNormal ? 1.0 : -1.0; vec2 planeDirection = vec2(intersection.y, -intersection.x) * normalSign; vec2 hit = ray.pos.xy + intersection.w * ray.dir.xy; return dot(hit, planeDirection) > 0.0; } void intersectHalfPlane(in Ray ray, in float angle, out RayShapeIntersection intersections[2]) { vec4 intersection = intersectLongitude(ray, angle, true); vec4 farSide = vec4(normalize(ray.dir), INF_HIT); if (hitPositiveHalfPlane(ray, intersection, true)) { intersections[0].entry = -1.0 * farSide; intersections[0].exit = vec4(-1.0 * intersection.xy, 0.0, intersection.w); intersections[1].entry = intersection; intersections[1].exit = farSide; } else { vec4 miss = vec4(normalize(ray.dir), NO_HIT); intersections[0].entry = -1.0 * farSide; intersections[0].exit = farSide; intersections[1].entry = miss; intersections[1].exit = miss; } } RayShapeIntersection intersectRegularWedge(in Ray ray, in vec2 minMaxAngle) { // Note: works for maxAngle > minAngle + pi, where the \"regular wedge\" // is actually a negative volume. // Compute intersections with the two planes. // Normals will point toward the \"outside\" (negative space) vec4 intersect1 = intersectLongitude(ray, minMaxAngle.x, false); vec4 intersect2 = intersectLongitude(ray, minMaxAngle.y, true); // Choose intersection with smallest T as the \"first\", the other as \"last\" // Note: first or last could be in the \"shadow\" wedge, beyond the tip bool inOrder = intersect1.w <= intersect2.w; vec4 first = inOrder ? intersect1 : intersect2; vec4 last = inOrder ? intersect2 : intersect1; bool firstIsAhead = first.w >= 0.0; bool startedInsideFirst = dot(ray.pos.xy, first.xy) < 0.0; bool exitFromInside = firstIsAhead == startedInsideFirst; bool lastIsAhead = last.w > 0.0; bool startedOutsideLast = dot(ray.pos.xy, last.xy) >= 0.0; bool enterFromOutside = lastIsAhead == startedOutsideLast; vec4 farSide = vec4(normalize(ray.dir), INF_HIT); vec4 miss = vec4(normalize(ray.dir), NO_HIT); if (exitFromInside && enterFromOutside) { // Ray crosses both faces of negative wedge, exiting then entering the positive shape return RayShapeIntersection(first, last); } else if (!exitFromInside && enterFromOutside) { // Ray starts inside wedge. last is in shadow wedge, and first is actually the entry return RayShapeIntersection(-1.0 * farSide, first); } else if (exitFromInside && !enterFromOutside) { // First intersection was in the shadow wedge, so last is actually the exit return RayShapeIntersection(last, farSide); } else { // !exitFromInside && !enterFromOutside // Both intersections were in the shadow wedge return RayShapeIntersection(miss, miss); } } `;var _Ai=T(S(),1),jF=`// See IntersectionUtils.glsl for the definitions of Ray, RayShapeIntersection, // NO_HIT, Intersections /* Box defines (set in Scene/VoxelBoxShape.js) #define BOX_INTERSECTION_INDEX ### // always 0 */ uniform vec3 u_renderMinBounds; uniform vec3 u_renderMaxBounds; RayShapeIntersection intersectBox(in Ray ray, in vec3 minBound, in vec3 maxBound) { // Consider the box as the intersection of the space between 3 pairs of parallel planes // Compute the distance along the ray to each plane vec3 t0 = (minBound - ray.pos) / ray.dir; vec3 t1 = (maxBound - ray.pos) / ray.dir; // Identify candidate entries/exits based on distance from ray.pos vec3 entries = min(t0, t1); vec3 exits = max(t0, t1); vec3 directions = sign(ray.dir); // The actual intersection points are the furthest entry and the closest exit float lastEntry = maxComponent(entries); bvec3 isLastEntry = equal(entries, vec3(lastEntry)); vec3 entryNormal = -1.0 * vec3(isLastEntry) * directions; vec4 entry = vec4(entryNormal, lastEntry); float firstExit = minComponent(exits); bvec3 isFirstExit = equal(exits, vec3(firstExit)); vec3 exitNormal = vec3(isLastEntry) * directions; vec4 exit = vec4(exitNormal, firstExit); if (entry.w > exit.w) { entry.w = NO_HIT; exit.w = NO_HIT; } return RayShapeIntersection(entry, exit); } void intersectShape(in Ray ray, inout Intersections ix) { RayShapeIntersection intersection = intersectBox(ray, u_renderMinBounds, u_renderMaxBounds); setShapeIntersection(ix, BOX_INTERSECTION_INDEX, intersection); } `;var SAi=T(S(),1),qF=`// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, Intersections, // RayShapeIntersection, setSurfaceIntersection, setShapeIntersection, // intersectIntersections // See IntersectLongitude.glsl for the definitions of intersectHalfPlane, // intersectFlippedWedge, intersectRegularWedge /* Cylinder defines (set in Scene/VoxelCylinderShape.js) #define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN #define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT #define CYLINDER_HAS_RENDER_BOUNDS_ANGLE #define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF #define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF #define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO #define CYLINDER_INTERSECTION_INDEX_RADIUS_MAX #define CYLINDER_INTERSECTION_INDEX_RADIUS_MIN #define CYLINDER_INTERSECTION_INDEX_ANGLE */ // Cylinder uniforms uniform vec2 u_cylinderRenderRadiusMinMax; uniform vec2 u_cylinderRenderHeightMinMax; #if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE) uniform vec2 u_cylinderRenderAngleMinMax; #endif /** * Find the intersection of a ray with the volume defined by two planes of constant z */ RayShapeIntersection intersectHeightBounds(in Ray ray, in vec2 minMaxHeight, in bool convex) { float zPosition = ray.pos.z; float zDirection = ray.dir.z; float tmin = (minMaxHeight.x - zPosition) / zDirection; float tmax = (minMaxHeight.y - zPosition) / zDirection; // Normals point outside the volume float signFlip = convex ? 1.0 : -1.0; vec4 intersectMin = vec4(0.0, 0.0, -1.0 * signFlip, tmin); vec4 intersectMax = vec4(0.0, 0.0, 1.0 * signFlip, tmax); bool topEntry = zDirection < 0.0; vec4 entry = topEntry ? intersectMax : intersectMin; vec4 exit = topEntry ? intersectMin : intersectMax; return RayShapeIntersection(entry, exit); } /** * Find the intersection of a ray with a right cylindrical surface of a given radius * about the z-axis. */ RayShapeIntersection intersectCylinder(in Ray ray, in float radius, in bool convex) {"
}