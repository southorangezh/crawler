{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 27,
    "total_chunks": 194,
    "chunk_size": 5123,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.662Z"
  },
  "content": "* @glslFunction * * @param {vec4} positionEC DOC_TBA. * @param {vec3} eyeOffset DOC_TBA. * * @returns {vec4} DOC_TBA. */ vec4 czm_eyeOffset(vec4 positionEC, vec3 eyeOffset) { // This equation is approximate in x and y. vec4 p = positionEC; vec4 zEyeOffset = normalize(p) * eyeOffset.z; p.xy += eyeOffset.xy + zEyeOffset.xy; p.z += zEyeOffset.z; return p; } `;var DPt=T(S(),1),GR=`/** * Transforms a position from eye to window coordinates. The transformation * from eye to clip coordinates is done using {@link czm_projection}. * The transform from normalized device coordinates to window coordinates is * done using {@link czm_viewportTransformation}, which assumes a depth range * of <code>near = 0</code> and <code>far = 1</code>. * <br /><br /> * This transform is useful when there is a need to manipulate window coordinates * in a vertex shader as done by {@link BillboardCollection}. * * @name czm_eyeToWindowCoordinates * @glslFunction * * @param {vec4} position The position in eye coordinates to transform. * * @returns {vec4} The transformed position in window coordinates. * * @see czm_modelToWindowCoordinates * @see czm_projection * @see czm_viewportTransformation * @see BillboardCollection * * @example * vec4 positionWC = czm_eyeToWindowCoordinates(positionEC); */ vec4 czm_eyeToWindowCoordinates(vec4 positionEC) { vec4 q = czm_projection * positionEC; // clip coordinates q.xyz /= q.w; // normalized device coordinates q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coordinates return q; } `;var YPt=T(S(),1),ER=`/** * Approxiamtes atan over the range [0, 1]. Safe to flip output for negative input. * * Based on Michal Drobot's approximation from ShaderFastLibs, which in turn is based on * \"Efficient approximations for the arctangent function,\" Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006. * Adapted from ShaderFastLibs under MIT License. * * Chosen for the following characteristics over range [0, 1]: * - basically no error at 0 and 1, important for getting around range limit (naive atan2 via atan requires infinite range atan) * - no visible artifacts from first-derivative discontinuities, unlike latitude via range-reduced sqrt asin approximations (at equator) * * The original code is x * (-0.1784 * abs(x) - 0.0663 * x * x + 1.0301); * Removed the abs() in here because it isn't needed, the input range is guaranteed as [0, 1] by how we're approximating atan2. * * @name czm_fastApproximateAtan * @glslFunction * * @param {float} x Value between 0 and 1 inclusive. * * @returns {float} Approximation of atan(x) */ float czm_fastApproximateAtan(float x) { return x * (-0.1784 * x - 0.0663 * x * x + 1.0301); } /** * Approximation of atan2. * * Range reduction math based on nvidia's cg reference implementation for atan2: http://developer.download.nvidia.com/cg/atan2.html * However, we replaced their atan curve with Michael Drobot's (see above). * * @name czm_fastApproximateAtan * @glslFunction * * @param {float} x Value between -1 and 1 inclusive. * @param {float} y Value between -1 and 1 inclusive. * * @returns {float} Approximation of atan2(x, y) */ float czm_fastApproximateAtan(float x, float y) { // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications. // So range-reduce using abs and by flipping whether x or y is on top. float t = abs(x); // t used as swap and atan result. float opposite = abs(y); float adjacent = max(t, opposite); opposite = min(t, opposite); t = czm_fastApproximateAtan(opposite / adjacent); // Undo range reduction t = czm_branchFreeTernary(abs(y) > abs(x), czm_piOverTwo - t, t); t = czm_branchFreeTernary(x < 0.0, czm_pi - t, t); t = czm_branchFreeTernary(y < 0.0, -t, t); return t; } `;var zPt=T(S(),1),XR=`/** * Gets the color with fog at a distance from the camera. * * @name czm_fog * @glslFunction * * @param {float} distanceToCamera The distance to the camera in meters. * @param {vec3} color The original color. * @param {vec3} fogColor The color of the fog. * * @returns {vec3} The color adjusted for fog at the distance from the camera. */ vec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) { float scalar = distanceToCamera * czm_fogDensity; float fog = 1.0 - exp(-(scalar * scalar)); return mix(color, fogColor, fog); } /** * Gets the color with fog at a distance from the camera. * * @name czm_fog * @glslFunction * * @param {float} distanceToCamera The distance to the camera in meters. * @param {vec3} color The original color. * @param {vec3} fogColor The color of the fog. * @param {float} fogModifierConstant A constant to modify the appearance of fog. * * @returns {vec3} The color adjusted for fog at the distance from the camera. */ vec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) { float scalar = distanceToCamera * czm_fogDensity; float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant)))); return mix(color, fogColor, fog); } `;var KPt=T(S(),1),IR=`/** * Converts a color from RGB space to linear space. * * @name czm_gammaCorrect"
}