{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 175,
    "total_chunks": 194,
    "chunk_size": 5389,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.755Z"
  },
  "content": "of (0.5 - ndDot) provides the best compromise. float minusDot = 0.5 - ndDot; // Even with the previous calculation, subtracting the second layer of wnoise // erode too much of the cloud. The addition of it, however, will detailed // volume to the cloud. As long as the noise is only added and not subtracted, // the results are aesthetically pleasing. // The minusDot product is mapped in a way that it is larger at the edges of // the ellipsoid, so a subtraction and min operation are used instead of // an addition and max one. TR -= min(minusDot * W2, 0.0); // The third level of worley noise is subtracted from the result, with some // modifications. First, a scalar is added to minusDot so that the noise // starts affecting the shape farther away from the center of the ellipsoid's // surface. Then, it is scaled down so its impact is not too intense. TR -= 0.8 * (minusDot + 0.25) * W3; // The texture function's shading does not correlate with the shape of the cloud // produced by the layers of noise, so an extra shading scalar is calculated. // The darkest areas of the cloud are assigned to be where the noise erodes // the cloud the most. This is then interpolated based on the translucency // and the diffuse shading term of that point in the cloud. float shading = mix(1.0 - 0.8 * W * W, 1.0, Id * TR); // To avoid values that are too dark, this scalar is increased by a small amount // and clamped so it never goes to zero. shading = clamp(shading + 0.2, 0.3, 1.0); // Finally, the contrast of the cloud's color is increased. vec3 finalColor = mix(vec3(0.5), shading * color, 1.15); return vec4(finalColor, clamp(TR, 0.0, 1.0)) * v_color; } void main() { #ifdef DEBUG_BILLBOARDS out_FragColor = vec4(0.0, 0.5, 0.5, 1.0); #endif // To avoid calculations with high values, // we raycast from an arbitrarily smaller space. vec2 coordinate = v_maximumSize.xy * v_offset; vec3 ellipsoidScale = 0.82 * v_maximumSize; vec3 ellipsoidCenter = vec3(0.0); float zOffset = max(ellipsoidScale.z - 10.0, 0.0); vec3 eye = vec3(0, 0, -10.0 - zOffset); vec3 rayDir = normalize(vec3(coordinate, 1.0) - eye); vec3 rayOrigin = eye; #ifdef DEBUG_ELLIPSOIDS vec3 point, normal; if(intersectEllipsoid(rayOrigin, rayDir, ellipsoidCenter, ellipsoidScale, v_slice, point, normal)) { out_FragColor = v_brightness * v_color; } #else #ifndef DEBUG_BILLBOARDS vec4 cloud = drawCloud(rayOrigin, rayDir, ellipsoidCenter, ellipsoidScale, v_slice, v_brightness); if(cloud.w < 0.01) { discard; } out_FragColor = cloud; #endif #endif } `;var D3i=T(S(),1),I9=`#ifdef INSTANCED in vec2 direction; #endif in vec4 positionHighAndScaleX; in vec4 positionLowAndScaleY; in vec4 packedAttribute0; in vec4 packedAttribute1; in vec4 color; out vec2 v_offset; out vec3 v_maximumSize; out vec4 v_color; out float v_slice; out float v_brightness; void main() { // Unpack attributes. vec3 positionHigh = positionHighAndScaleX.xyz; vec3 positionLow = positionLowAndScaleY.xyz; vec2 scale = vec2(positionHighAndScaleX.w, positionLowAndScaleY.w); float show = packedAttribute0.x; float brightness = packedAttribute0.y; vec2 coordinates = packedAttribute0.wz; vec3 maximumSize = packedAttribute1.xyz; float slice = packedAttribute1.w; #ifdef INSTANCED vec2 dir = direction; #else vec2 dir = coordinates; #endif vec2 offset = dir - vec2(0.5, 0.5); vec2 scaledOffset = scale * offset; vec4 p = czm_translateRelativeToEye(positionHigh, positionLow); vec4 positionEC = czm_modelViewRelativeToEye * p; positionEC.xy += scaledOffset; positionEC.xyz *= show; gl_Position = czm_projection * positionEC; v_offset = offset; v_maximumSize = maximumSize; v_color = color; v_slice = slice; v_brightness = brightness; } `;var Y3i=T(S(),1),W9=`uniform vec3 u_noiseTextureDimensions; uniform float u_noiseDetail; uniform vec3 u_noiseOffset; in vec2 v_position; float wrap(float value, float rangeLength) { if(value < 0.0) { float absValue = abs(value); float modValue = mod(absValue, rangeLength); return mod(rangeLength - modValue, rangeLength); } return mod(value, rangeLength); } vec3 wrapVec(vec3 value, float rangeLength) { return vec3(wrap(value.x, rangeLength), wrap(value.y, rangeLength), wrap(value.z, rangeLength)); } vec3 random3(vec3 p) { float dot1 = dot(p, vec3(127.1, 311.7, 932.8)); float dot2 = dot(p, vec3(269.5, 183.3, 421.4)); return fract(vec3(sin(dot1 - dot2), cos(dot1 * dot2), dot1 * dot2)); } // Frequency corresponds to cell size. // The higher the frequency, the smaller the cell size. vec3 getWorleyCellPoint(vec3 centerCell, vec3 offset, float freq) { float textureSliceWidth = u_noiseTextureDimensions.x; vec3 cell = centerCell + offset; cell = wrapVec(cell, textureSliceWidth / u_noiseDetail); cell += floor(u_noiseOffset / u_noiseDetail); vec3 p = offset + random3(cell); return p; } float worleyNoise(vec3 p, float freq) { vec3 centerCell = floor(p * freq); vec3 pointInCell = fract(p * freq); float shortestDistance = 1000.0; for(float z = -1.0; z <= 1.0; z++) { for(float y = -1.0; y <= 1.0; y++) { for(float x = -1.0; x <= 1.0; x++) { vec3 offset = vec3(x, y, z); vec3 point = getWorleyCellPoint(centerCell, offset, freq); float distance = length(pointInCell - point); if(distance < shortestDistance) { shortestDistance = distance; } } } } return shortestDistance; } const float MAX_FBM_ITERATIONS = 10.0; float worleyFBMNoise(vec3 p, float octaves, float scale) { float noise = 0.0; float freq = 1.0; float"
}