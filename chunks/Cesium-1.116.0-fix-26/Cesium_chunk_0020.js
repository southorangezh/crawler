{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 20,
    "total_chunks": 194,
    "chunk_size": 5426,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.658Z"
  },
  "content": "ignoreBlackPixels) { // Convert rgb color to hsb vec3 hsb = czm_RGBToHSB(rgb); // Perform hsb shift // Hue cycles around so no clamp is needed. hsb.x += hsbShift.x; // hue hsb.y = clamp(hsb.y + hsbShift.y, 0.0, 1.0); // saturation // brightness // // Some shaders such as atmosphere-related effects need to leave black // pixels unchanged if (ignoreBlackPixels) { hsb.z = hsb.z > czm_epsilon7 ? hsb.z + hsbShift.z : 0.0; } else { hsb.z = hsb.z + hsbShift.z; } hsb.z = clamp(hsb.z, 0.0, 1.0); // Convert shifted hsb back to rgb return czm_HSBToRGB(hsb); } `;var q2t=T(S(),1),sR=`/** * Approximately computes spherical coordinates given a normal. * Uses approximate inverse trigonometry for speed and consistency, * since inverse trigonometry can differ from vendor-to-vendor and when compared with the CPU. * * @name czm_approximateSphericalCoordinates * @glslFunction * * @param {vec3} normal arbitrary-length normal. * * @returns {vec2} Approximate latitude and longitude spherical coordinates. */ vec2 czm_approximateSphericalCoordinates(vec3 normal) { // Project into plane with vertical for latitude float latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z); float longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y); return vec2(latitudeApproximation, longitudeApproximation); } `;var ePt=T(S(),1),aR=`/** * Compute a rational approximation to tanh(x) * * @param {float} x A real number input * @returns {float} An approximation for tanh(x) */ float czm_approximateTanh(float x) { float x2 = x * x; return max(-1.0, min(1.0, x * (27.0 + x2) / (27.0 + 9.0 * x2))); } `;var nPt=T(S(),1),cR=`/** * Determines if the fragment is back facing * * @name czm_backFacing * @glslFunction * * @returns {bool} <code>true</code> if the fragment is back facing; otherwise, <code>false</code>. */ bool czm_backFacing() { // !gl_FrontFacing doesn't work as expected on Mac/Intel so use the more verbose form instead. See https://github.com/CesiumGS/cesium/pull/8494. return gl_FrontFacing == false; } `;var oPt=T(S(),1),lR=`/** * Branchless ternary operator to be used when it's inexpensive to explicitly * evaluate both possibilities for a float expression. * * @name czm_branchFreeTernary * @glslFunction * * @param {bool} comparison A comparison statement * @param {float} a Value to return if the comparison is true. * @param {float} b Value to return if the comparison is false. * * @returns {float} equivalent of comparison ? a : b */ float czm_branchFreeTernary(bool comparison, float a, float b) { float useA = float(comparison); return a * useA + b * (1.0 - useA); } /** * Branchless ternary operator to be used when it's inexpensive to explicitly * evaluate both possibilities for a vec2 expression. * * @name czm_branchFreeTernary * @glslFunction * * @param {bool} comparison A comparison statement * @param {vec2} a Value to return if the comparison is true. * @param {vec2} b Value to return if the comparison is false. * * @returns {vec2} equivalent of comparison ? a : b */ vec2 czm_branchFreeTernary(bool comparison, vec2 a, vec2 b) { float useA = float(comparison); return a * useA + b * (1.0 - useA); } /** * Branchless ternary operator to be used when it's inexpensive to explicitly * evaluate both possibilities for a vec3 expression. * * @name czm_branchFreeTernary * @glslFunction * * @param {bool} comparison A comparison statement * @param {vec3} a Value to return if the comparison is true. * @param {vec3} b Value to return if the comparison is false. * * @returns {vec3} equivalent of comparison ? a : b */ vec3 czm_branchFreeTernary(bool comparison, vec3 a, vec3 b) { float useA = float(comparison); return a * useA + b * (1.0 - useA); } /** * Branchless ternary operator to be used when it's inexpensive to explicitly * evaluate both possibilities for a vec4 expression. * * @name czm_branchFreeTernary * @glslFunction * * @param {bool} comparison A comparison statement * @param {vec3} a Value to return if the comparison is true. * @param {vec3} b Value to return if the comparison is false. * * @returns {vec3} equivalent of comparison ? a : b */ vec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) { float useA = float(comparison); return a * useA + b * (1.0 - useA); } `;var sPt=T(S(),1),dR=` vec4 czm_cascadeColor(vec4 weights) { return vec4(1.0, 0.0, 0.0, 1.0) * weights.x + vec4(0.0, 1.0, 0.0, 1.0) * weights.y + vec4(0.0, 0.0, 1.0, 1.0) * weights.z + vec4(1.0, 0.0, 1.0, 1.0) * weights.w; } `;var cPt=T(S(),1),uR=` uniform vec4 shadowMap_cascadeDistances; float czm_cascadeDistance(vec4 weights) { return dot(shadowMap_cascadeDistances, weights); } `;var dPt=T(S(),1),mR=` uniform mat4 shadowMap_cascadeMatrices[4]; mat4 czm_cascadeMatrix(vec4 weights) { return shadowMap_cascadeMatrices[0] * weights.x + shadowMap_cascadeMatrices[1] * weights.y + shadowMap_cascadeMatrices[2] * weights.z + shadowMap_cascadeMatrices[3] * weights.w; } `;var mPt=T(S(),1),hR=` uniform vec4 shadowMap_cascadeSplits[2]; vec4 czm_cascadeWeights(float depthEye) { // One component is set to 1.0 and all others set to 0.0. vec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye)); vec4 far = step(depthEye, shadowMap_cascadeSplits[1]); return near * far; } `;var fPt=T(S(),1),fR=`/** * DOC_TBA * * @name czm_columbusViewMorph * @glslFunction */ vec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time) { // Just linear for"
}