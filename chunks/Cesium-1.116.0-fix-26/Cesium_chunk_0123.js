{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 123,
    "total_chunks": 194,
    "chunk_size": 8332,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.725Z"
  },
  "content": "normalEC) * 5.0, 0.0, 1.0); #else float nightBlend = 0.0; #endif // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0 // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the // fragments on the edges of tiles even though the vertex shader is outputting // coordinates strictly in the 0-1 range. vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0), nightBlend); #ifdef SHOW_TILE_BOUNDARIES if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) || v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0)) { color = vec4(1.0, 0.0, 0.0, 1.0); } #endif #if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE) float cameraDist; if (czm_sceneMode == czm_sceneMode2D) { cameraDist = max(czm_frustumPlanes.x - czm_frustumPlanes.y, czm_frustumPlanes.w - czm_frustumPlanes.z) * 0.5; } else if (czm_sceneMode == czm_sceneModeColumbusView) { cameraDist = -czm_view[3].z; } else { cameraDist = length(czm_view[3]); } float fadeOutDist = u_lightingFadeDistance.x; float fadeInDist = u_lightingFadeDistance.y; if (czm_sceneMode != czm_sceneMode3D) { vec3 radii = czm_ellipsoidRadii; float maxRadii = max(radii.x, max(radii.y, radii.z)); fadeOutDist -= maxRadii; fadeInDist -= maxRadii; } float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0); #else float fade = 0.0; #endif #ifdef SHOW_REFLECTIVE_OCEAN vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy; vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw; vec2 waterMaskTextureCoordinates = v_textureCoordinates.xy * waterMaskScale + waterMaskTranslation; waterMaskTextureCoordinates.y = 1.0 - waterMaskTextureCoordinates.y; float mask = texture(u_waterMask, waterMaskTextureCoordinates).r; if (mask > 0.0) { mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC); vec2 ellipsoidTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC); vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidWgs84TextureCoordinates(normalMC.zyx); vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z)); color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask, fade); } #endif #ifdef APPLY_MATERIAL czm_materialInput materialInput; materialInput.st = v_textureCoordinates.st; materialInput.normalEC = normalize(v_normalEC); materialInput.positionToEyeEC = -v_positionEC; materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalize(v_normalEC)); materialInput.slope = v_slope; materialInput.height = v_height; materialInput.aspect = v_aspect; czm_material material = czm_getMaterial(materialInput); vec4 materialColor = vec4(material.diffuse, material.alpha); color = alphaBlend(materialColor, color); #endif #ifdef ENABLE_VERTEX_LIGHTING float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalize(v_normalEC)) * u_lambertDiffuseMultiplier + u_vertexShadowDarkness, 0.0, 1.0); vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a); #elif defined(ENABLE_DAYNIGHT_SHADING) float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0); diffuseIntensity = mix(1.0, diffuseIntensity, fade); vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a); #else vec4 finalColor = color; #endif #ifdef ENABLE_CLIPPING_PLANES vec4 clippingPlanesEdgeColor = vec4(1.0); clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb; float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a; if (clipDistance < clippingPlanesEdgeWidth) { finalColor = clippingPlanesEdgeColor; } #endif #ifdef HIGHLIGHT_FILL_TILE finalColor = vec4(mix(finalColor.rgb, u_fillHighlightColor.rgb, u_fillHighlightColor.a), finalColor.a); #endif #if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN) vec3 atmosphereLightDirection = czm_sunDirectionWC; #else vec3 atmosphereLightDirection = czm_lightDirectionWC; #endif #if defined(GROUND_ATMOSPHERE) || defined(FOG) if (!czm_backFacing()) { bool dynamicLighting = false; #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING)) dynamicLighting = true; #endif vec3 rayleighColor; vec3 mieColor; float opacity; vec3 positionWC; vec3 lightDirection; // When the camera is far away (camera distance > nightFadeOutDistance), the scattering is computed in the fragment shader. // Otherwise, the scattering is computed in the vertex shader. #ifdef PER_FRAGMENT_GROUND_ATMOSPHERE positionWC = computeEllipsoidPosition(); lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(positionWC)); computeAtmosphereScattering( positionWC, lightDirection, rayleighColor, mieColor, opacity ); #else positionWC = v_positionMC; lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(positionWC)); rayleighColor = v_atmosphereRayleighColor; mieColor = v_atmosphereMieColor; opacity = v_atmosphereOpacity; #endif #ifdef COLOR_CORRECT const bool ignoreBlackPixels = true; rayleighColor = czm_applyHSBShift(rayleighColor, u_hsbShift, ignoreBlackPixels); mieColor = czm_applyHSBShift(mieColor, u_hsbShift, ignoreBlackPixels); #endif vec4 groundAtmosphereColor = computeAtmosphereColor(positionWC, lightDirection, rayleighColor, mieColor, opacity); // Fog is applied to tiles selected for fog, close to the Earth. #ifdef FOG vec3 fogColor = groundAtmosphereColor.rgb; // If there is lighting, apply that to the fog. #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING)) float darken = clamp(dot(normalize(czm_viewerPositionWC), atmosphereLightDirection), u_minimumBrightness, 1.0); fogColor *= darken; #endif #ifndef HDR fogColor.rgb = czm_acesTonemapping(fogColor.rgb); fogColor.rgb = czm_inverseGamma(fogColor.rgb); #endif const float modifier = 0.15; finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor.rgb, modifier), finalColor.a); #else // Apply ground atmosphere. This happens when the camera is far away from the earth. // The transmittance is based on optical depth i.e. the length of segment of the ray inside the atmosphere. // This value is larger near the \"circumference\", as it is further away from the camera. We use it to // brighten up that area of the ground atmosphere. const float transmittanceModifier = 0.5; float transmittance = transmittanceModifier + clamp(1.0 - groundAtmosphereColor.a, 0.0, 1.0); vec3 finalAtmosphereColor = finalColor.rgb + groundAtmosphereColor.rgb * transmittance; #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING)) float fadeInDist = u_nightFadeDistance.x; float fadeOutDist = u_nightFadeDistance.y; float sunlitAtmosphereIntensity = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.05, 1.0); float darken = clamp(dot(normalize(positionWC), atmosphereLightDirection), 0.0, 1.0); vec3 darkenendGroundAtmosphereColor = mix(groundAtmosphereColor.rgb, finalAtmosphereColor.rgb, darken); finalAtmosphereColor = mix(darkenendGroundAtmosphereColor, finalAtmosphereColor, sunlitAtmosphereIntensity); #endif #ifndef HDR finalAtmosphereColor.rgb = vec3(1.0) - exp(-fExposure * finalAtmosphereColor.rgb); #else finalAtmosphereColor.rgb = czm_saturation(finalAtmosphereColor.rgb, 1.6); #endif finalColor.rgb = mix(finalColor.rgb, finalAtmosphereColor.rgb, fade); #endif } #endif #ifdef UNDERGROUND_COLOR if (czm_backFacing()) { float distanceFromEllipsoid = max(czm_eyeHeight, 0.0); float distance = max(v_distance - distanceFromEllipsoid, 0.0); float blendAmount = interpolateByDistance(u_undergroundColorAlphaByDistance, distance); vec4 undergroundColor = vec4(u_undergroundColor.rgb, u_undergroundColor.a * blendAmount); finalColor = alphaBlend(undergroundColor, finalColor); } #endif #ifdef TRANSLUCENT if (inTranslucencyRectangle()) { vec4 alphaByDistance = gl_FrontFacing ? u_frontFaceAlphaByDistance : u_backFaceAlphaByDistance; finalColor.a *= interpolateByDistance(alphaByDistance, v_distance); } #endif out_FragColor = finalColor; } #ifdef SHOW_REFLECTIVE_OCEAN float waveFade(float edge0, float edge1, float x) { float y"
}