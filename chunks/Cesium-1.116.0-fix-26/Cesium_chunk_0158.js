{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 158,
    "total_chunks": 194,
    "chunk_size": 7002,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.745Z"
  },
  "content": "and exit have been found, so the loop can stop if (exitPositive) { // After exiting positive shape there is nothing left to intersect, so jump to the end index. ix.index = passCount; } break; } } return shapeIntersection; } #endif // NOTE: initializeIntersections, nextIntersection aren't even declared unless INTERSECTION_COUNT > 1 `;var fAi=T(S(),1),JF=`// See IntersectionUtils.glsl for the definitions of Ray, Intersections, // setIntersectionPair, INF_HIT, NO_HIT /* intersectDepth defines (set in Scene/VoxelRenderResources.js) #define DEPTH_INTERSECTION_INDEX ### */ uniform mat4 u_transformPositionViewToUv; void intersectDepth(in vec2 screenCoord, in Ray ray, inout Intersections ix) { float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, screenCoord)); if (logDepthOrDepth != 0.0) { // Calculate how far the ray must travel before it hits the depth buffer. vec4 eyeCoordinateDepth = czm_screenToEyeCoordinates(screenCoord, logDepthOrDepth); eyeCoordinateDepth /= eyeCoordinateDepth.w; vec3 depthPositionUv = vec3(u_transformPositionViewToUv * eyeCoordinateDepth); float t = dot(depthPositionUv - ray.pos, ray.dir); setIntersectionPair(ix, DEPTH_INTERSECTION_INDEX, vec2(t, +INF_HIT)); } else { // There's no depth at this location. setIntersectionPair(ix, DEPTH_INTERSECTION_INDEX, vec2(NO_HIT)); } } `;var bAi=T(S(),1),QF=`// See IntersectionUtils.glsl for the definitions of Ray, Intersections, INF_HIT, // NO_HIT, setShapeIntersection /* Clipping plane defines (set in Scene/VoxelRenderResources.js) #define CLIPPING_PLANES_UNION #define CLIPPING_PLANES_COUNT #define CLIPPING_PLANES_INTERSECTION_INDEX */ uniform sampler2D u_clippingPlanesTexture; uniform mat4 u_clippingPlanesMatrix; // Plane is in Hessian Normal Form vec4 intersectPlane(in Ray ray, in vec4 plane) { vec3 n = plane.xyz; // normal float w = plane.w; // -dot(pointOnPlane, normal) float a = dot(ray.pos, n); float b = dot(ray.dir, n); float t = -(w + a) / b; return vec4(n, t); } void intersectClippingPlanes(in Ray ray, inout Intersections ix) { vec4 backSide = vec4(-ray.dir, -INF_HIT); vec4 farSide = vec4(ray.dir, +INF_HIT); RayShapeIntersection clippingVolume; #if (CLIPPING_PLANES_COUNT == 1) // Union and intersection are the same when there's one clipping plane, and the code // is more simplified. vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, 0, u_clippingPlanesMatrix); vec4 intersection = intersectPlane(ray, planeUv); bool reflects = dot(ray.dir, intersection.xyz) < 0.0; clippingVolume.entry = reflects ? backSide : intersection; clippingVolume.exit = reflects ? intersection : farSide; setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX, clippingVolume); #elif defined(CLIPPING_PLANES_UNION) vec4 firstTransmission = vec4(ray.dir, +INF_HIT); vec4 lastReflection = vec4(-ray.dir, -INF_HIT); for (int i = 0; i < CLIPPING_PLANES_COUNT; i++) { vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, i, u_clippingPlanesMatrix); vec4 intersection = intersectPlane(ray, planeUv); if (dot(ray.dir, planeUv.xyz) > 0.0) { firstTransmission = intersection.w <= firstTransmission.w ? intersection : firstTransmission; } else { lastReflection = intersection.w >= lastReflection.w ? intersection : lastReflection; } } clippingVolume.entry = backSide; clippingVolume.exit = lastReflection; setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX + 0, clippingVolume); clippingVolume.entry = firstTransmission; clippingVolume.exit = farSide; setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX + 1, clippingVolume); #else // intersection vec4 lastTransmission = vec4(ray.dir, -INF_HIT); vec4 firstReflection = vec4(-ray.dir, +INF_HIT); for (int i = 0; i < CLIPPING_PLANES_COUNT; i++) { vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, i, u_clippingPlanesMatrix); vec4 intersection = intersectPlane(ray, planeUv); if (dot(ray.dir, planeUv.xyz) > 0.0) { lastTransmission = intersection.w > lastTransmission.w ? intersection : lastTransmission; } else { firstReflection = intersection.w < firstReflection.w ? intersection: firstReflection; } } if (lastTransmission.w < firstReflection.w) { clippingVolume.entry = lastTransmission; clippingVolume.exit = firstReflection; } else { clippingVolume.entry = vec4(-ray.dir, NO_HIT); clippingVolume.exit = vec4(ray.dir, NO_HIT); } setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX, clippingVolume); #endif } `;var gAi=T(S(),1),JV=`// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, INF_HIT, // RayShapeIntersection vec4 intersectLongitude(in Ray ray, in float angle, in bool positiveNormal) { float normalSign = positiveNormal ? 1.0 : -1.0; vec2 planeNormal = vec2(-sin(angle), cos(angle)) * normalSign; vec2 position = ray.pos.xy; vec2 direction = ray.dir.xy; float approachRate = dot(direction, planeNormal); float distance = -dot(position, planeNormal); float t = (approachRate == 0.0) ? NO_HIT : distance / approachRate; return vec4(planeNormal, 0.0, t); } RayShapeIntersection intersectHalfSpace(in Ray ray, in float angle, in bool positiveNormal) { vec4 intersection = intersectLongitude(ray, angle, positiveNormal); vec4 farSide = vec4(normalize(ray.dir), INF_HIT); bool hitFront = (intersection.w > 0.0) == (dot(ray.pos.xy, intersection.xy) > 0.0); if (!hitFront) { return RayShapeIntersection(intersection, farSide); } else { return RayShapeIntersection(-1.0 * farSide, intersection); } } void intersectFlippedWedge(in Ray ray, in vec2 minMaxAngle, out RayShapeIntersection intersections[2]) { intersections[0] = intersectHalfSpace(ray, minMaxAngle.x, false); intersections[1] = intersectHalfSpace(ray, minMaxAngle.y, true); } bool hitPositiveHalfPlane(in Ray ray, in vec4 intersection, in bool positiveNormal) { float normalSign = positiveNormal ? 1.0 : -1.0; vec2 planeDirection = vec2(intersection.y, -intersection.x) * normalSign; vec2 hit = ray.pos.xy + intersection.w * ray.dir.xy; return dot(hit, planeDirection) > 0.0; } void intersectHalfPlane(in Ray ray, in float angle, out RayShapeIntersection intersections[2]) { vec4 intersection = intersectLongitude(ray, angle, true); vec4 farSide = vec4(normalize(ray.dir), INF_HIT); if (hitPositiveHalfPlane(ray, intersection, true)) { intersections[0].entry = -1.0 * farSide; intersections[0].exit = vec4(-1.0 * intersection.xy, 0.0, intersection.w); intersections[1].entry = intersection; intersections[1].exit = farSide; } else { vec4 miss = vec4(normalize(ray.dir), NO_HIT); intersections[0].entry = -1.0 * farSide; intersections[0].exit = farSide; intersections[1].entry = miss; intersections[1].exit = miss; } } RayShapeIntersection intersectRegularWedge(in Ray ray, in vec2 minMaxAngle) { // Note: works for maxAngle > minAngle + pi, where the \"regular wedge\" // is actually a negative volume. // Compute intersections with the two planes. // Normals will point toward the \"outside\" (negative space) vec4 intersect1 = intersectLongitude(ray, minMaxAngle.x, false); vec4 intersect2 = intersectLongitude(ray, minMaxAngle.y, true); //"
}