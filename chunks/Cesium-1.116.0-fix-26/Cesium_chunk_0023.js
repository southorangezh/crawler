{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 23,
    "total_chunks": 194,
    "chunk_size": 5742,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.659Z"
  },
  "content": "PRIMARY_STEPS_MAX - int(w_inside_atmosphere * 12.0); // Number of times the ray from the camera to the world position (primary ray) is sampled. int LIGHT_STEPS = LIGHT_STEPS_MAX - int(w_inside_atmosphere * 2.0); // Number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray. // Setup for sampling positions along the ray - starting from the intersection with the outer ring of the atmosphere. float rayPositionLength = primaryRayAtmosphereIntersect.start; // (1) Outside the atmosphere: constant rayStepLength // (2) Inside atmosphere: variable rayStepLength to compensate the rough rendering of the smaller number of ray steps float totalRayLength = primaryRayAtmosphereIntersect.stop - rayPositionLength; float rayStepLengthIncrease = w_inside_atmosphere * ((1.0 - w_stop_gt_lprl) * totalRayLength / (float(PRIMARY_STEPS * (PRIMARY_STEPS + 1)) / 2.0)); float rayStepLength = max(1.0 - w_inside_atmosphere, w_stop_gt_lprl) * totalRayLength / max(7.0 * w_inside_atmosphere, float(PRIMARY_STEPS)); vec3 rayleighAccumulation = vec3(0.0); vec3 mieAccumulation = vec3(0.0); vec2 opticalDepth = vec2(0.0); vec2 heightScale = vec2(czm_atmosphereRayleighScaleHeight, czm_atmosphereMieScaleHeight); // Sample positions on the primary ray. for (int i = 0; i < PRIMARY_STEPS_MAX; ++i) { // The loop should be: for (int i = 0; i < PRIMARY_STEPS; ++i) {...} but WebGL1 cannot // loop with non-constant condition, so it has to break early instead if (i >= PRIMARY_STEPS) { break; } // Calculate sample position along viewpoint ray. vec3 samplePosition = primaryRay.origin + primaryRay.direction * (rayPositionLength + rayStepLength); // Calculate height of sample position above ellipsoid. float sampleHeight = length(samplePosition) - atmosphereInnerRadius; // Calculate and accumulate density of particles at the sample position. vec2 sampleDensity = exp(-sampleHeight / heightScale) * rayStepLength; opticalDepth += sampleDensity; // Generate ray from the sample position segment to the light source, up to the outer ring of the atmosphere. czm_ray lightRay = czm_ray(samplePosition, lightDirection); czm_raySegment lightRayAtmosphereIntersect = czm_raySphereIntersectionInterval(lightRay, origin, atmosphereOuterRadius); float lightStepLength = lightRayAtmosphereIntersect.stop / float(LIGHT_STEPS); float lightPositionLength = 0.0; vec2 lightOpticalDepth = vec2(0.0); // Sample positions along the light ray, to accumulate incidence of light on the latest sample segment. for (int j = 0; j < LIGHT_STEPS_MAX; ++j) { // The loop should be: for (int j = 0; i < LIGHT_STEPS; ++j) {...} but WebGL1 cannot // loop with non-constant condition, so it has to break early instead if (j >= LIGHT_STEPS) { break; } // Calculate sample position along light ray. vec3 lightPosition = samplePosition + lightDirection * (lightPositionLength + lightStepLength * 0.5); // Calculate height of the light sample position above ellipsoid. float lightHeight = length(lightPosition) - atmosphereInnerRadius; // Calculate density of photons at the light sample position. lightOpticalDepth += exp(-lightHeight / heightScale) * lightStepLength; // Increment distance on light ray. lightPositionLength += lightStepLength; } // Compute attenuation via the primary ray and the light ray. vec3 attenuation = exp(-((czm_atmosphereMieCoefficient * (opticalDepth.y + lightOpticalDepth.y)) + (czm_atmosphereRayleighCoefficient * (opticalDepth.x + lightOpticalDepth.x)))); // Accumulate the scattering. rayleighAccumulation += sampleDensity.x * attenuation; mieAccumulation += sampleDensity.y * attenuation; // Increment distance on primary ray. rayPositionLength += (rayStepLength += rayStepLengthIncrease); } // Compute the scattering amount. rayleighColor = czm_atmosphereRayleighCoefficient * rayleighAccumulation; mieColor = czm_atmosphereMieCoefficient * mieAccumulation; // Compute the transmittance i.e. how much light is passing through the atmosphere. opacity = length(exp(-((czm_atmosphereMieCoefficient * opticalDepth.y) + (czm_atmosphereRayleighCoefficient * opticalDepth.x)))); } `;var VPt=T(S(),1),xR=`/** * @private */ vec2 cordic(float angle) { // Scale the vector by the appropriate factor for the 24 iterations to follow. vec2 vector = vec2(6.0725293500888267e-1, 0.0); // Iteration 1 float sense = (angle < 0.0) ? -1.0 : 1.0; // float factor = sense * 1.0; // 2^-0 mat2 rotation = mat2(1.0, sense, -sense, 1.0); vector = rotation * vector; angle -= sense * 7.8539816339744828e-1; // atan(2^-0) // Iteration 2 sense = (angle < 0.0) ? -1.0 : 1.0; float factor = sense * 5.0e-1; // 2^-1 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 4.6364760900080609e-1; // atan(2^-1) // Iteration 3 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 2.5e-1; // 2^-2 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 2.4497866312686414e-1; // atan(2^-2) // Iteration 4 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 1.25e-1; // 2^-3 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 1.2435499454676144e-1; // atan(2^-3) // Iteration 5 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 6.25e-2; // 2^-4 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 6.2418809995957350e-2; // atan(2^-4) // Iteration 6 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 3.125e-2; // 2^-5 rotation[0][1] = factor; rotation[1][0] = -factor; vector = rotation * vector; angle -= sense * 3.1239833430268277e-2; // atan(2^-5) // Iteration 7 sense = (angle < 0.0) ? -1.0 : 1.0; factor = sense * 1.5625e-2; // 2^-6 rotation[0][1]"
}