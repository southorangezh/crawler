{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 83,
    "total_chunks": 194,
    "chunk_size": 14127,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.695Z"
  },
  "content": "*= F * brdfLut.x + brdfLut.y; #else vec3 specularIBL = vec3(0.0); #endif return diffuseColor * diffuseIrradiance + specularColor * specularIBL; } #endif vec3 imageBasedLightingStage( vec3 positionEC, vec3 normalEC, vec3 lightDirectionEC, vec3 lightColorHdr, czm_pbrParameters pbrParameters ) { #if defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) // Environment maps were provided, use them for IBL return textureIBL( positionEC, normalEC, lightDirectionEC, pbrParameters ); #else // Use the procedural IBL if there are no environment maps return proceduralIBL( positionEC, normalEC, lightDirectionEC, lightColorHdr, pbrParameters ); #endif }`;var Kre={name:\"ImageBasedLightingPipelineStage\"};Kre.process=function(e,t,n){let i=t.imageBasedLighting,o=e.shaderBuilder;o.addDefine(\"USE_IBL_LIGHTING\",void 0,Ce.FRAGMENT),o.addUniform(\"vec2\",\"model_iblFactor\",Ce.FRAGMENT),Xm.isSupported(n.context)&&((i.useSphericalHarmonics||i.useSpecularEnvironmentMaps||i.enabled)&&o.addUniform(\"mat3\",\"model_iblReferenceFrameMatrix\",Ce.FRAGMENT),l(i.sphericalHarmonicCoefficients)?(o.addDefine(\"DIFFUSE_IBL\",void 0,Ce.FRAGMENT),o.addDefine(\"CUSTOM_SPHERICAL_HARMONICS\",void 0,Ce.FRAGMENT),o.addUniform(\"vec3\",\"model_sphericalHarmonicCoefficients[9]\",Ce.FRAGMENT)):i.useDefaultSphericalHarmonics&&o.addDefine(\"DIFFUSE_IBL\",void 0,Ce.FRAGMENT),l(i.specularEnvironmentMapAtlas)&&i.specularEnvironmentMapAtlas.ready?(o.addDefine(\"SPECULAR_IBL\",void 0,Ce.FRAGMENT),o.addDefine(\"CUSTOM_SPECULAR_IBL\",void 0,Ce.FRAGMENT),o.addUniform(\"sampler2D\",\"model_specularEnvironmentMaps\",Ce.FRAGMENT),o.addUniform(\"vec2\",\"model_specularEnvironmentMapsSize\",Ce.FRAGMENT),o.addUniform(\"float\",\"model_specularEnvironmentMapsMaximumLOD\",Ce.FRAGMENT)):t.useDefaultSpecularMaps&&o.addDefine(\"SPECULAR_IBL\",void 0,Ce.FRAGMENT)),l(i.luminanceAtZenith)&&(o.addDefine(\"USE_SUN_LUMINANCE\",void 0,Ce.FRAGMENT),o.addUniform(\"float\",\"model_luminanceAtZenith\",Ce.FRAGMENT)),o.addFragmentLines(RI);let r={model_iblFactor:function(){return i.imageBasedLightingFactor},model_iblReferenceFrameMatrix:function(){return t._iblReferenceFrameMatrix},model_luminanceAtZenith:function(){return i.luminanceAtZenith},model_sphericalHarmonicCoefficients:function(){return i.sphericalHarmonicCoefficients},model_specularEnvironmentMaps:function(){return i.specularEnvironmentMapAtlas.texture},model_specularEnvironmentMapsSize:function(){return i.specularEnvironmentMapAtlas.texture.dimensions},model_specularEnvironmentMapsMaximumLOD:function(){return i.specularEnvironmentMapAtlas.maximumMipmapLevel}};e.uniformMap=Ct(r,e.uniformMap)};var GI=Kre;var P_n=T(S(),1);var R_n=T(S(),1);var iUe=P.EPSILON16;function Dz(e){e=g(e,g.EMPTY_OBJECT);let t=e.stage,n=e.runtimeArticulation;this._stage=t,this._runtimeArticulation=n,this._name=t.name,this._type=t.type,this._minimumValue=t.minimumValue,this._maximumValue=t.maximumValue,this._currentValue=t.initialValue}Object.defineProperties(Dz.prototype,{stage:{get:function(){return this._stage}},runtimeArticulation:{get:function(){return this._runtimeArticulation}},name:{get:function(){return this._name}},type:{get:function(){return this._type}},minimumValue:{get:function(){return this._minimumValue}},maximumValue:{get:function(){return this._maximumValue}},currentValue:{get:function(){return this._currentValue},set:function(e){e=P.clamp(e,this.minimumValue,this.maximumValue),P.equalsEpsilon(this._currentValue,e,iUe)||(this._currentValue=e,this.runtimeArticulation._dirty=!0)}}});var oUe=new h,Uz=new $;Dz.prototype.applyStageToMatrix=function(e){let t=this.type,n=this.currentValue,i=oUe,o;switch(t){case cc.XROTATE:o=$.fromRotationX(P.toRadians(n),Uz),e=M.multiplyByMatrix3(e,o,e);break;case cc.YROTATE:o=$.fromRotationY(P.toRadians(n),Uz),e=M.multiplyByMatrix3(e,o,e);break;case cc.ZROTATE:o=$.fromRotationZ(P.toRadians(n),Uz),e=M.multiplyByMatrix3(e,o,e);break;case cc.XTRANSLATE:i.x=n,i.y=0,i.z=0,e=M.multiplyByTranslation(e,i,e);break;case cc.YTRANSLATE:i.x=0,i.y=n,i.z=0,e=M.multiplyByTranslation(e,i,e);break;case cc.ZTRANSLATE:i.x=0,i.y=0,i.z=n,e=M.multiplyByTranslation(e,i,e);break;case cc.XSCALE:i.x=n,i.y=1,i.z=1,e=M.multiplyByScale(e,i,e);break;case cc.YSCALE:i.x=1,i.y=n,i.z=1,e=M.multiplyByScale(e,i,e);break;case cc.ZSCALE:i.x=1,i.y=1,i.z=n,e=M.multiplyByScale(e,i,e);break;case cc.UNIFORMSCALE:e=M.multiplyByUniformScale(e,n,e);break;default:break}return e};var EI=Dz;function mN(e){e=g(e,g.EMPTY_OBJECT);let t=e.articulation,n=e.sceneGraph;this._articulation=t,this._sceneGraph=n,this._name=t.name,this._runtimeStages=[],this._runtimeStagesByName={},this._runtimeNodes=[],this._dirty=!0,rUe(this)}Object.defineProperties(mN.prototype,{articulation:{get:function(){return this._articulation}},sceneGraph:{get:function(){return this._sceneGraph}},name:{get:function(){return this._name}},runtimeStages:{get:function(){return this._runtimeStages}},runtimeNodes:{get:function(){return this._runtimeNodes}}});function rUe(e){let n=e.articulation.stages,i=n.length,o=e._runtimeStages,r=e._runtimeStagesByName;for(let s=0;s<i;s++){let a=n[s],c=new EI({stage:a,runtimeArticulation:e});o.push(c);let d=a.name;r[d]=c}}mN.prototype.setArticulationStage=function(e,t){let n=this._runtimeStagesByName[e];l(n)&&(n.currentValue=t)};var sUe=new M,aUe=new M;mN.prototype.apply=function(){if(!this._dirty)return;this._dirty=!1;let e=M.clone(M.IDENTITY,sUe),t,n=this._runtimeStages,i=n.length;for(t=0;t<i;t++)e=n[t].applyStageToMatrix(e);let o=this._runtimeNodes,r=o.length;for(t=0;t<r;t++){let s=o[t],a=M.multiplyTransformation(s.originalTransform,e,aUe);s.transform=a}};var XI=mN;var D_n=T(S(),1);var w_n=T(S(),1),II=`void modelColorStage(inout czm_modelMaterial material) { material.diffuse = mix(material.diffuse, model_color.rgb, model_colorBlend); float highlight = ceil(model_colorBlend); material.diffuse *= mix(model_color.rgb, vec3(1.0), highlight); material.alpha *= model_color.a; } `;var FC={name:\"ModelColorPipelineStage\",COLOR_UNIFORM_NAME:\"model_color\",COLOR_BLEND_UNIFORM_NAME:\"model_colorBlend\"};FC.process=function(e,t,n){let i=e.shaderBuilder;i.addDefine(\"HAS_MODEL_COLOR\",void 0,Ce.FRAGMENT),i.addFragmentLines(II);let o={},r=t.color;r.alpha===0&&!t.hasSilhouette(n)&&(e.renderStateOptions.colorMask={red:!1,green:!1,blue:!1,alpha:!1}),r.alpha<1&&(e.alphaOptions.pass=Ze.TRANSLUCENT),i.addUniform(\"vec4\",FC.COLOR_UNIFORM_NAME,Ce.FRAGMENT),o[FC.COLOR_UNIFORM_NAME]=function(){return t.color},i.addUniform(\"float\",FC.COLOR_BLEND_UNIFORM_NAME,Ce.FRAGMENT),o[FC.COLOR_BLEND_UNIFORM_NAME]=function(){return ac.getColorBlend(t.colorBlendMode,t.colorBlendAmount)},e.uniformMap=Ct(o,e.uniformMap)};var uy=FC;var q_n=T(S(),1);var Y_n=T(S(),1),WI=`#ifdef USE_CLIPPING_PLANES_FLOAT_TEXTURE vec4 getClippingPlane( highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform ) { int pixY = clippingPlaneNumber / CLIPPING_PLANES_TEXTURE_WIDTH; int pixX = clippingPlaneNumber - (pixY * CLIPPING_PLANES_TEXTURE_WIDTH); float pixelWidth = 1.0 / float(CLIPPING_PLANES_TEXTURE_WIDTH); float pixelHeight = 1.0 / float(CLIPPING_PLANES_TEXTURE_HEIGHT); float u = (float(pixX) + 0.5) * pixelWidth; // sample from center of pixel float v = (float(pixY) + 0.5) * pixelHeight; vec4 plane = texture(packedClippingPlanes, vec2(u, v)); return czm_transformPlane(plane, transform); } #else // Handle uint8 clipping texture instead vec4 getClippingPlane( highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform ) { int clippingPlaneStartIndex = clippingPlaneNumber * 2; // clipping planes are two pixels each int pixY = clippingPlaneStartIndex / CLIPPING_PLANES_TEXTURE_WIDTH; int pixX = clippingPlaneStartIndex - (pixY * CLIPPING_PLANES_TEXTURE_WIDTH); float pixelWidth = 1.0 / float(CLIPPING_PLANES_TEXTURE_WIDTH); float pixelHeight = 1.0 / float(CLIPPING_PLANES_TEXTURE_HEIGHT); float u = (float(pixX) + 0.5) * pixelWidth; // sample from center of pixel float v = (float(pixY) + 0.5) * pixelHeight; vec4 oct32 = texture(packedClippingPlanes, vec2(u, v)) * 255.0; vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w); vec4 plane; plane.xyz = czm_octDecode(oct, 65535.0); plane.w = czm_unpackFloat(texture(packedClippingPlanes, vec2(u + pixelWidth, v))); return czm_transformPlane(plane, transform); } #endif float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix) { vec4 position = czm_windowToEyeCoordinates(fragCoord); vec3 clipNormal = vec3(0.0); vec3 clipPosition = vec3(0.0); float pixelWidth = czm_metersPerPixel(position); #ifdef UNION_CLIPPING_REGIONS float clipAmount; // For union planes, we want to get the min distance. So we set the initial value to the first plane distance in the loop below. #else float clipAmount = 0.0; bool clipped = true; #endif for (int i = 0; i < CLIPPING_PLANES_LENGTH; ++i) { vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix); clipNormal = clippingPlane.xyz; clipPosition = -clippingPlane.w * clipNormal; float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth; #ifdef UNION_CLIPPING_REGIONS clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount)); if (amount <= 0.0) { discard; } #else clipAmount = max(amount, clipAmount); clipped = clipped && (amount <= 0.0); #endif } #ifndef UNION_CLIPPING_REGIONS if (clipped) { discard; } #endif return clipAmount; } void modelClippingPlanesStage(inout vec4 color) { float clipDistance = clip(gl_FragCoord, model_clippingPlanes, model_clippingPlanesMatrix); vec4 clippingPlanesEdgeColor = vec4(1.0); clippingPlanesEdgeColor.rgb = model_clippingPlanesEdgeStyle.rgb; float clippingPlanesEdgeWidth = model_clippingPlanesEdgeStyle.a; if (clipDistance > 0.0 && clipDistance < clippingPlanesEdgeWidth) { color = clippingPlanesEdgeColor; } } `;var Jre={name:\"ModelClippingPlanesPipelineStage\"},cUe=new D;Jre.process=function(e,t,n){let i=t.clippingPlanes,o=n.context,r=e.shaderBuilder;r.addDefine(\"HAS_CLIPPING_PLANES\",void 0,Ce.FRAGMENT),r.addDefine(\"CLIPPING_PLANES_LENGTH\",i.length,Ce.FRAGMENT),i.unionClippingRegions&&r.addDefine(\"UNION_CLIPPING_REGIONS\",void 0,Ce.FRAGMENT),fs.useFloatTexture(o)&&r.addDefine(\"USE_CLIPPING_PLANES_FLOAT_TEXTURE\",void 0,Ce.FRAGMENT);let s=fs.getTextureResolution(i,o,cUe);r.addDefine(\"CLIPPING_PLANES_TEXTURE_WIDTH\",s.x,Ce.FRAGMENT),r.addDefine(\"CLIPPING_PLANES_TEXTURE_HEIGHT\",s.y,Ce.FRAGMENT),r.addUniform(\"sampler2D\",\"model_clippingPlanes\",Ce.FRAGMENT),r.addUniform(\"vec4\",\"model_clippingPlanesEdgeStyle\",Ce.FRAGMENT),r.addUniform(\"mat4\",\"model_clippingPlanesMatrix\",Ce.FRAGMENT),r.addFragmentLines(WI);let a={model_clippingPlanes:function(){return i.texture},model_clippingPlanesEdgeStyle:function(){let c=O.clone(i.edgeColor);return c.alpha=i.edgeWidth,c},model_clippingPlanesMatrix:function(){return t._clippingPlanesMatrix}};e.uniformMap=Ct(a,e.uniformMap)};var PI=Jre;var tTn=T(S(),1);function Qre(e,t){this._model=e,this._runtimeNode=t}Object.defineProperties(Qre.prototype,{name:{get:function(){return this._runtimeNode._name}},id:{get:function(){return this._runtimeNode._id}},show:{get:function(){return this._runtimeNode.show},set:function(e){this._runtimeNode.show=e}},matrix:{get:function(){return this._runtimeNode.transform},set:function(e){l(e)?(this._runtimeNode.transform=e,this._runtimeNode.userAnimated=!0,this._model._userAnimationDirty=!0):(this._runtimeNode.transform=this.originalMatrix,this._runtimeNode.userAnimated=!1)}},originalMatrix:{get:function(){return this._runtimeNode.originalTransform}}});var vI=Qre;var KTn=T(S(),1);var ETn=T(S(),1);var iTn=T(S(),1),wI=`mat4 getInstancingTransform() { mat4 instancingTransform; #ifdef HAS_INSTANCE_MATRICES instancingTransform = mat4( a_instancingTransformRow0.x, a_instancingTransformRow1.x, a_instancingTransformRow2.x, 0.0, // Column 1 a_instancingTransformRow0.y, a_instancingTransformRow1.y, a_instancingTransformRow2.y, 0.0, // Column 2 a_instancingTransformRow0.z, a_instancingTransformRow1.z, a_instancingTransformRow2.z, 0.0, // Column 3 a_instancingTransformRow0.w, a_instancingTransformRow1.w, a_instancingTransformRow2.w, 1.0 // Column 4 ); #else vec3 translation = vec3(0.0, 0.0, 0.0); vec3 scale = vec3(1.0, 1.0, 1.0); #ifdef HAS_INSTANCE_TRANSLATION translation = a_instanceTranslation; #endif #ifdef HAS_INSTANCE_SCALE scale = a_instanceScale; #endif instancingTransform = mat4( scale.x, 0.0, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, 0.0, scale.z, 0.0, translation.x, translation.y, translation.z, 1.0 ); #endif return instancingTransform; } #ifdef USE_2D_INSTANCING mat4 getInstancingTransform2D() { mat4 instancingTransform2D; #ifdef HAS_INSTANCE_MATRICES instancingTransform2D = mat4( a_instancingTransform2DRow0.x, a_instancingTransform2DRow1.x, a_instancingTransform2DRow2.x, 0.0, // Column 1 a_instancingTransform2DRow0.y, a_instancingTransform2DRow1.y, a_instancingTransform2DRow2.y, 0.0, // Column 2 a_instancingTransform2DRow0.z, a_instancingTransform2DRow1.z, a_instancingTransform2DRow2.z, 0.0, // Column 3 a_instancingTransform2DRow0.w, a_instancingTransform2DRow1.w, a_instancingTransform2DRow2.w, 1.0 // Column 4 ); #else vec3 translation2D = vec3(0.0, 0.0, 0.0); vec3 scale = vec3(1.0, 1.0, 1.0); #ifdef HAS_INSTANCE_TRANSLATION translation2D = a_instanceTranslation2D; #endif #ifdef HAS_INSTANCE_SCALE scale = a_instanceScale; #endif instancingTransform2D = mat4( scale.x, 0.0, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, 0.0, scale.z, 0.0, translation2D.x, translation2D.y, translation2D.z, 1.0 ); #endif return instancingTransform2D; } #endif `;var rTn=T(S(),1),FI=`void instancingStage(inout ProcessedAttributes attributes) { vec3 positionMC = attributes.positionMC; mat4 instancingTransform = getInstancingTransform(); attributes.positionMC = (instancingTransform * vec4(positionMC, 1.0)).xyz; #ifdef HAS_NORMALS vec3 normalMC = attributes.normalMC; attributes.normalMC = (instancingTransform * vec4(normalMC, 0.0)).xyz; #endif #ifdef USE_2D_INSTANCING mat4 instancingTransform2D = getInstancingTransform2D(); attributes.position2D = (instancingTransform2D * vec4(positionMC, 1.0)).xyz; #endif } `;var aTn=T(S(),1),AI=`void legacyInstancingStage( inout ProcessedAttributes attributes, out"
}