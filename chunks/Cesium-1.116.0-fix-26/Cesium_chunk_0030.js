{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 30,
    "total_chunks": 194,
    "chunk_size": 5373,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.663Z"
  },
  "content": "otherwise, <code>false</code>. * * @example * bool b0 = czm_isEmpty(czm_emptyRaySegment); // true * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0. */ bool czm_isEmpty(czm_raySegment interval) { return (interval.stop < 0.0); } `;var fvt=T(S(),1),UR=`/** * Determines if a time interval is empty. * * @name czm_isFull * @glslFunction * * @param {czm_raySegment} interval The interval to test. * * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>. * * @example * bool b0 = czm_isEmpty(czm_emptyRaySegment); // true * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0. */ bool czm_isFull(czm_raySegment interval) { return (interval.start == 0.0 && interval.stop == czm_infinity); } `;var bvt=T(S(),1),DR=`/** * Computes the fraction of a Web Wercator rectangle at which a given geodetic latitude is located. * * @name czm_latitudeToWebMercatorFraction * @glslFunction * * @param {float} latitude The geodetic latitude, in radians. * @param {float} southMercatorY The Web Mercator coordinate of the southern boundary of the rectangle. * @param {float} oneOverMercatorHeight The total height of the rectangle in Web Mercator coordinates. * * @returns {float} The fraction of the rectangle at which the latitude occurs. If the latitude is the southern * boundary of the rectangle, the return value will be zero. If it is the northern boundary, the return * value will be 1.0. Latitudes in between are mapped according to the Web Mercator projection. */ float czm_latitudeToWebMercatorFraction(float latitude, float southMercatorY, float oneOverMercatorHeight) { float sinLatitude = sin(latitude); float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude)); return (mercatorY - southMercatorY) * oneOverMercatorHeight; } `;var gvt=T(S(),1),BR=`/** * Computes distance from an point in 2D to a line in 2D. * * @name czm_lineDistance * @glslFunction * * param {vec2} point1 A point along the line. * param {vec2} point2 A point along the line. * param {vec2} point A point that may or may not be on the line. * returns {float} The distance from the point to the line. */ float czm_lineDistance(vec2 point1, vec2 point2, vec2 point) { return abs((point2.y - point1.y) * point.x - (point2.x - point1.x) * point.y + point2.x * point1.y - point2.y * point1.x) / distance(point2, point1); } `;var _vt=T(S(),1),YR=`/** * Converts a linear RGB color to an sRGB color. * * @param {vec3|vec4} linearIn The color in linear color space. * @returns {vec3|vec4} The color in sRGB color space. The vector type matches the input. */ vec3 czm_linearToSrgb(vec3 linearIn) { return pow(linearIn, vec3(1.0/2.2)); } vec4 czm_linearToSrgb(vec4 linearIn) { vec3 srgbOut = pow(linearIn.rgb, vec3(1.0/2.2)); return vec4(srgbOut, linearIn.a); } `;var Svt=T(S(),1),OR=`/** * Computes the luminance of a color. * * @name czm_luminance * @glslFunction * * @param {vec3} rgb The color. * * @returns {float} The luminance. * * @example * float light = czm_luminance(vec3(0.0)); // 0.0 * float dark = czm_luminance(vec3(1.0)); // ~1.0 */ float czm_luminance(vec3 rgb) { // Algorithm from Chapter 10 of Graphics Shaders. const vec3 W = vec3(0.2125, 0.7154, 0.0721); return dot(rgb, W); } `;var Vvt=T(S(),1),zR=`/** * Computes the size of a pixel in meters at a distance from the eye. * <p> * Use this version when passing in a custom pixel ratio. For example, passing in 1.0 will return meters per native device pixel. * </p> * @name czm_metersPerPixel * @glslFunction * * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates. * @param {float} pixelRatio The scaling factor from pixel space to coordinate space * * @returns {float} The meters per pixel at positionEC. */ float czm_metersPerPixel(vec4 positionEC, float pixelRatio) { float width = czm_viewport.z; float height = czm_viewport.w; float pixelWidth; float pixelHeight; float top = czm_frustumPlanes.x; float bottom = czm_frustumPlanes.y; float left = czm_frustumPlanes.z; float right = czm_frustumPlanes.w; if (czm_sceneMode == czm_sceneMode2D || czm_orthographicIn3D == 1.0) { float frustumWidth = right - left; float frustumHeight = top - bottom; pixelWidth = frustumWidth / width; pixelHeight = frustumHeight / height; } else { float distanceToPixel = -positionEC.z; float inverseNear = 1.0 / czm_currentFrustum.x; float tanTheta = top * inverseNear; pixelHeight = 2.0 * distanceToPixel * tanTheta / height; tanTheta = right * inverseNear; pixelWidth = 2.0 * distanceToPixel * tanTheta / width; } return max(pixelWidth, pixelHeight) * pixelRatio; } /** * Computes the size of a pixel in meters at a distance from the eye. * <p> * Use this version when scaling by pixel ratio. * </p> * @name czm_metersPerPixel * @glslFunction * * @param {vec3} positionEC The position to get the meters per pixel in eye coordinates. * * @returns {float} The meters per pixel at positionEC. */ float czm_metersPerPixel(vec4 positionEC) { return czm_metersPerPixel(positionEC, czm_pixelRatio); } `;var Zvt=T(S(),1),HR=`/** * Transforms a position from model to window coordinates. The transformation * from model to clip coordinates is done using {@link czm_modelViewProjection}. * The transform from normalized"
}