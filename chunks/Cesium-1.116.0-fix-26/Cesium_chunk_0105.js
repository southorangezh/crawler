{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 105,
    "total_chunks": 194,
    "chunk_size": 10718,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.709Z"
  },
  "content": "0,this._pointPrimitiveCollection=t,this._dirty=!1,this._index=-1}var Zde=gr.SHOW_INDEX=0,Ede=gr.POSITION_INDEX=1,QQe=gr.COLOR_INDEX=2,jQe=gr.OUTLINE_COLOR_INDEX=3,qQe=gr.OUTLINE_WIDTH_INDEX=4,$Qe=gr.PIXEL_SIZE_INDEX=5,e4e=gr.SCALE_BY_DISTANCE_INDEX=6,t4e=gr.TRANSLUCENCY_BY_DISTANCE_INDEX=7,n4e=gr.DISTANCE_DISPLAY_CONDITION_INDEX=8,i4e=gr.DISABLE_DEPTH_DISTANCE_INDEX=9,o4e=gr.DEPTH_FAIL_TRANSLUCENCY=10;gr.NUMBER_OF_PROPERTIES=11;function Td(e,t){let n=e._pointPrimitiveCollection;l(n)&&(n._updatePointPrimitive(e,t),e._dirty=!0)}Object.defineProperties(gr.prototype,{show:{get:function(){return this._show},set:function(e){this._show!==e&&(this._show=e,Td(this,Zde))}},position:{get:function(){return this._position},set:function(e){let t=this._position;h.equals(t,e)||(h.clone(e,t),h.clone(e,this._actualPosition),Td(this,Ede))}},scaleByDistance:{get:function(){return this._scaleByDistance},set:function(e){let t=this._scaleByDistance;At.equals(t,e)||(this._scaleByDistance=At.clone(e,t),Td(this,e4e))}},translucencyByDistance:{get:function(){return this._translucencyByDistance},set:function(e){let t=this._translucencyByDistance;At.equals(t,e)||(this._translucencyByDistance=At.clone(e,t),Td(this,t4e))}},pixelSize:{get:function(){return this._pixelSize},set:function(e){this._pixelSize!==e&&(this._pixelSize=e,Td(this,$Qe))}},color:{get:function(){return this._color},set:function(e){let t=this._color;O.equals(t,e)||(O.clone(e,t),Td(this,QQe))}},outlineColor:{get:function(){return this._outlineColor},set:function(e){let t=this._outlineColor;O.equals(t,e)||(O.clone(e,t),Td(this,jQe))}},outlineWidth:{get:function(){return this._outlineWidth},set:function(e){this._outlineWidth!==e&&(this._outlineWidth=e,Td(this,qQe))}},distanceDisplayCondition:{get:function(){return this._distanceDisplayCondition},set:function(e){It.equals(this._distanceDisplayCondition,e)||(this._distanceDisplayCondition=It.clone(e,this._distanceDisplayCondition),Td(this,n4e))}},disableDepthTestDistance:{get:function(){return this._disableDepthTestDistance},set:function(e){this._disableDepthTestDistance!==e&&(this._disableDepthTestDistance=e,Td(this,i4e))}},id:{get:function(){return this._id},set:function(e){this._id=e,l(this._pickId)&&(this._pickId.object.id=e)}},pickId:{get:function(){return this._pickId}},clusterShow:{get:function(){return this._clusterShow},set:function(e){this._clusterShow!==e&&(this._clusterShow=e,Td(this,Zde))}},depthFailTranslucency:{get:function(){return this._depthFailTranslucency},set:function(e){l(e)&&(bi.typeOf.number(\"value\",e),e<0&&(e=0),e>1&&(e=1)),this._depthFailTranslucency!==e&&(this._depthFailTranslucency=e,Td(this,o4e))}}});gr.prototype.getPickId=function(e){return l(this._pickId)||(this._pickId=e.createPickId({primitive:this,collection:this._collection,id:this._id})),this._pickId};gr.prototype._getActualPosition=function(){return this._actualPosition};gr.prototype._setActualPosition=function(e){h.clone(e,this._actualPosition),Td(this,Ede)};var Rde=new se;gr._computeActualPosition=function(e,t,n){return t.mode===ie.SCENE3D?e:(M.multiplyByPoint(n,e,Rde),Zi.computeActualWgs84Position(t,Rde))};var Gde=new se;gr._computeScreenSpacePosition=function(e,t,n,i){let o=M.multiplyByVector(e,se.fromElements(t.x,t.y,t.z,1,Gde),Gde);return Zi.wgs84ToWindowCoordinates(n,o,i)};gr.prototype.computeScreenSpacePosition=function(e,t){let n=this._pointPrimitiveCollection;l(t)||(t=new D);let i=n.modelMatrix,o=gr._computeScreenSpacePosition(i,this._actualPosition,e,t);if(l(o))return o.y=e.canvas.clientHeight-o.y,o};gr.getScreenSpaceBoundingBox=function(e,t,n){let i=e.pixelSize,o=i*.5,r=t.x-o,s=t.y-o,a=i,c=i;return l(n)||(n=new ze),n.x=r,n.y=s,n.width=a,n.height=c,n};gr.prototype.equals=function(e){return this===e||l(e)&&this._id===e._id&&h.equals(this._position,e._position)&&O.equals(this._color,e._color)&&this._pixelSize===e._pixelSize&&this._outlineWidth===e._outlineWidth&&this._show===e._show&&O.equals(this._outlineColor,e._outlineColor)&&At.equals(this._scaleByDistance,e._scaleByDistance)&&At.equals(this._translucencyByDistance,e._translucencyByDistance)&&It.equals(this._distanceDisplayCondition,e._distanceDisplayCondition)&&this._disableDepthTestDistance===e._disableDepthTestDistance};gr.prototype._destroy=function(){this._pickId=this._pickId&&this._pickId.destroy(),this._pointPrimitiveCollection=void 0};var _s=gr;var dYn=T(S(),1);var wBn=T(S(),1),Z0=`in vec4 v_color; in vec4 v_outlineColor; in float v_innerPercent; in float v_pixelDistance; in vec4 v_pickColor; void main() { // The distance in UV space from this fragment to the center of the point, at most 0.5. float distanceToCenter = length(gl_PointCoord - vec2(0.5)); // The max distance stops one pixel shy of the edge to leave space for anti-aliasing. float maxDistance = max(0.0, 0.5 - v_pixelDistance); float wholeAlpha = 1.0 - smoothstep(maxDistance, 0.5, distanceToCenter); float innerAlpha = 1.0 - smoothstep(maxDistance * v_innerPercent, 0.5 * v_innerPercent, distanceToCenter); vec4 color = mix(v_outlineColor, v_color, innerAlpha); color.a *= wholeAlpha; // Fully transparent parts of the billboard are not pickable. #if !defined(OPAQUE) && !defined(TRANSLUCENT) if (color.a < 0.005) // matches 0/255 and 1/255 { discard; } #else // The billboard is rendered twice. The opaque pass discards translucent fragments // and the translucent pass discards opaque fragments. #ifdef OPAQUE if (color.a < 0.995) // matches < 254/255 { discard; } #else if (color.a >= 0.995) // matches 254/255 and 255/255 { discard; } #endif #endif out_FragColor = czm_gammaCorrect(color); czm_writeLogDepth(); } `;var ABn=T(S(),1),j2=`uniform float u_maxTotalPointSize; in vec4 positionHighAndSize; in vec4 positionLowAndOutline; in vec4 compressedAttribute0; // color, outlineColor, pick color in vec4 compressedAttribute1; // show, translucency by distance, some free space in vec4 scaleByDistance; // near, nearScale, far, farScale in vec3 distanceDisplayConditionAndDisableDepth; // near, far, disableDepthTestDistance #ifdef DEPTH_FAIL_TRANSLUCENCY in float depthFailTranslucency; #endif out vec4 v_color; out vec4 v_outlineColor; out float v_innerPercent; out float v_pixelDistance; out vec4 v_pickColor; const float SHIFT_LEFT8 = 256.0; const float SHIFT_RIGHT8 = 1.0 / 256.0; void main() { // Modifying this shader may also require modifications to PointPrimitive._computeScreenSpacePosition // unpack attributes vec3 positionHigh = positionHighAndSize.xyz; vec3 positionLow = positionLowAndOutline.xyz; float outlineWidthBothSides = 2.0 * positionLowAndOutline.w; float totalSize = positionHighAndSize.w + outlineWidthBothSides; float outlinePercent = outlineWidthBothSides / totalSize; // Scale in response to browser-zoom. totalSize *= czm_pixelRatio; float temp = compressedAttribute1.x * SHIFT_RIGHT8; float show = floor(temp); #ifdef EYE_DISTANCE_TRANSLUCENCY vec4 translucencyByDistance; translucencyByDistance.x = compressedAttribute1.z; translucencyByDistance.z = compressedAttribute1.w; translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0; temp = compressedAttribute1.y * SHIFT_RIGHT8; translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0; #endif /////////////////////////////////////////////////////////////////////////// vec4 color; vec4 outlineColor; vec4 pickColor; // compressedAttribute0.z => pickColor.rgb temp = compressedAttribute0.z * SHIFT_RIGHT8; pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8; temp = floor(temp) * SHIFT_RIGHT8; pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8; pickColor.r = floor(temp); // compressedAttribute0.x => color.rgb temp = compressedAttribute0.x * SHIFT_RIGHT8; color.b = (temp - floor(temp)) * SHIFT_LEFT8; temp = floor(temp) * SHIFT_RIGHT8; color.g = (temp - floor(temp)) * SHIFT_LEFT8; color.r = floor(temp); // compressedAttribute0.y => outlineColor.rgb temp = compressedAttribute0.y * SHIFT_RIGHT8; outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8; temp = floor(temp) * SHIFT_RIGHT8; outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8; outlineColor.r = floor(temp); // compressedAttribute0.w => color.a, outlineColor.a, pickColor.a temp = compressedAttribute0.w * SHIFT_RIGHT8; pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8; pickColor = pickColor / 255.0; temp = floor(temp) * SHIFT_RIGHT8; outlineColor.a = (temp - floor(temp)) * SHIFT_LEFT8; outlineColor /= 255.0; color.a = floor(temp); color /= 255.0; /////////////////////////////////////////////////////////////////////////// vec4 p = czm_translateRelativeToEye(positionHigh, positionLow); vec4 positionEC = czm_modelViewRelativeToEye * p; /////////////////////////////////////////////////////////////////////////// #if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE) float lengthSq; if (czm_sceneMode == czm_sceneMode2D) { // 2D camera distance is a special case // treat all billboards as flattened to the z=0.0 plane lengthSq = czm_eyeHeight2D.y; } else { lengthSq = dot(positionEC.xyz, positionEC.xyz); } #endif #ifdef EYE_DISTANCE_SCALING totalSize *= czm_nearFarScalar(scaleByDistance, lengthSq); #endif if (totalSize > 0.0) { // Add padding for anti-aliasing on both sides. totalSize += 3.0; } // Clamp to max point size. totalSize = min(totalSize, u_maxTotalPointSize); // If size is too small, push vertex behind near plane for clipping. // Note that context.minimumAliasedPointSize \"will be at most 1.0\". if (totalSize < 1.0) { positionEC.xyz = vec3(0.0); totalSize = 1.0; } float translucency = 1.0; #ifdef EYE_DISTANCE_TRANSLUCENCY translucency = czm_nearFarScalar(translucencyByDistance, lengthSq); // push vertex behind near plane for clipping if (translucency < 0.004) { positionEC.xyz = vec3(0.0); } #endif #ifdef DISTANCE_DISPLAY_CONDITION float nearSq = distanceDisplayConditionAndDisableDepth.x; float farSq = distanceDisplayConditionAndDisableDepth.y; if (lengthSq < nearSq || lengthSq > farSq) { // push vertex behind camera to force it to be clipped positionEC.xyz = vec3(0.0, 0.0, 1.0); } #endif gl_Position = czm_projection * positionEC; czm_vertexLogDepth(); #ifdef DISABLE_DEPTH_DISTANCE float disableDepthTestDistance = distanceDisplayConditionAndDisableDepth.z; if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0) { disableDepthTestDistance = czm_minimumDisableDepthTestDistance; } if (disableDepthTestDistance != 0.0) { // Don't try to \"multiply both sides\" by w. Greater/less-than comparisons won't work for negative values of w. float zclip = gl_Position.z / gl_Position.w; bool clipped = (zclip < -1.0 || zclip > 1.0); if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq"
}