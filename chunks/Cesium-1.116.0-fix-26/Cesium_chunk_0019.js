{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 19,
    "total_chunks": 194,
    "chunk_size": 5390,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.657Z"
  },
  "content": "= xyz.g; float temp = dot(vec3(1.0), xyz); Yxy.gb = xyz.rg / temp; return Yxy; } `;var D2t=T(S(),1),tR=`/** * Converts a CIE Yxy color to RGB. * <p>The conversion is described in * {@link http://content.gpwiki.org/index.php/D3DBook:High-Dynamic_Range_Rendering#Luminance_Transform|Luminance Transform} * </p> * * @name czm_XYZToRGB * @glslFunction * * @param {vec3} Yxy The color in CIE Yxy. * * @returns {vec3} The color in RGB. * * @example * vec3 xyz = czm_RGBToXYZ(rgb); * xyz.x = max(xyz.x - luminanceThreshold, 0.0); * rgb = czm_XYZToRGB(xyz); */ vec3 czm_XYZToRGB(vec3 Yxy) { const mat3 XYZ2RGB = mat3( 3.2405, -0.9693, 0.0556, -1.5371, 1.8760, -0.2040, -0.4985, 0.0416, 1.0572); vec3 xyz; xyz.r = Yxy.r * Yxy.g / Yxy.b; xyz.g = Yxy.r; xyz.b = Yxy.r * (1.0 - Yxy.g - Yxy.b) / Yxy.b; return XYZ2RGB * xyz; } `;var Y2t=T(S(),1),nR=`// See: // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/ vec3 czm_acesTonemapping(vec3 color) { float g = 0.985; float a = 0.065; float b = 0.0001; float c = 0.433; float d = 0.238; color = (color * (color + a) - b) / (color * (g * color + c) + d); color = clamp(color, 0.0, 1.0); return color; } `;var z2t=T(S(),1),iR=`/** * @private */ float czm_alphaWeight(float a) { float z = (gl_FragCoord.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2]; // See Weighted Blended Order-Independent Transparency for examples of different weighting functions: // http://jcgt.org/published/0002/02/09/ return pow(a + 0.01, 4.0) + max(1e-2, min(3.0 * 1e3, 0.003 / (1e-5 + pow(abs(z) / 200.0, 4.0)))); } `;var K2t=T(S(),1),oR=`/** * Procedural anti-aliasing by blurring two colors that meet at a sharp edge. * * @name czm_antialias * @glslFunction * * @param {vec4} color1 The color on one side of the edge. * @param {vec4} color2 The color on the other side of the edge. * @param {vec4} currentcolor The current color, either <code>color1</code> or <code>color2</code>. * @param {float} dist The distance to the edge in texture coordinates. * @param {float} [fuzzFactor=0.1] Controls the blurriness between the two colors. * @returns {vec4} The anti-aliased color. * * @example * // GLSL declarations * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor); * vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist); * * // get the color for a material that has a sharp edge at the line y = 0.5 in texture space * float dist = abs(textureCoordinates.t - 0.5); * vec4 currentColor = mix(bottomColor, topColor, step(0.5, textureCoordinates.t)); * vec4 color = czm_antialias(bottomColor, topColor, currentColor, dist, 0.1); */ vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist, float fuzzFactor) { float val1 = clamp(dist / fuzzFactor, 0.0, 1.0); float val2 = clamp((dist - 0.5) / fuzzFactor, 0.0, 1.0); val1 = val1 * (1.0 - val2); val1 = val1 * val1 * (3.0 - (2.0 * val1)); val1 = pow(val1, 0.5); //makes the transition nicer vec4 midColor = (color1 + color2) * 0.5; return mix(midColor, currentColor, val1); } vec4 czm_antialias(vec4 color1, vec4 color2, vec4 currentColor, float dist) { return czm_antialias(color1, color2, currentColor, dist, 0.1); } `;var Q2t=T(S(),1),rR=`/** * Apply a HSB color shift to an RGB color. * * @param {vec3} rgb The color in RGB space. * @param {vec3} hsbShift The amount to shift each component. The xyz components correspond to hue, saturation, and brightness. Shifting the hue by +/- 1.0 corresponds to shifting the hue by a full cycle. Saturation and brightness are clamped between 0 and 1 after the adjustment * @param {bool} ignoreBlackPixels If true, black pixels will be unchanged. This is necessary in some shaders such as atmosphere-related effects. * * @return {vec3} The RGB color after shifting in HSB space and clamping saturation and brightness to a valid range. */ vec3 czm_applyHSBShift(vec3 rgb, vec3 hsbShift, bool ignoreBlackPixels) { // Convert rgb color to hsb vec3 hsb = czm_RGBToHSB(rgb); // Perform hsb shift // Hue cycles around so no clamp is needed. hsb.x += hsbShift.x; // hue hsb.y = clamp(hsb.y + hsbShift.y, 0.0, 1.0); // saturation // brightness // // Some shaders such as atmosphere-related effects need to leave black // pixels unchanged if (ignoreBlackPixels) { hsb.z = hsb.z > czm_epsilon7 ? hsb.z + hsbShift.z : 0.0; } else { hsb.z = hsb.z + hsbShift.z; } hsb.z = clamp(hsb.z, 0.0, 1.0); // Convert shifted hsb back to rgb return czm_HSBToRGB(hsb); } `;var q2t=T(S(),1),sR=`/** * Approximately computes spherical coordinates given a normal. * Uses approximate inverse trigonometry for speed and consistency, * since inverse trigonometry can differ from vendor-to-vendor and when compared with the CPU. * * @name czm_approximateSphericalCoordinates * @glslFunction * * @param {vec3} normal arbitrary-length normal. * * @returns {vec2} Approximate latitude and longitude spherical coordinates. */ vec2 czm_approximateSphericalCoordinates(vec3 normal) { // Project into plane with vertical for latitude float latitudeApproximation = czm_fastApproximateAtan(sqrt(normal.x * normal.x + normal.y * normal.y), normal.z); float longitudeApproximation = czm_fastApproximateAtan(normal.x, normal.y); return vec2(latitudeApproximation, longitudeApproximation); } `;var ePt=T(S(),1),aR=`/** * Compute a rational approximation to tanh(x) * * @param {float} x A real number"
}