{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 29,
    "total_chunks": 194,
    "chunk_size": 5465,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.662Z"
  },
  "content": "diffuseIntensity) + (specularColor * specularIntensity); */ float czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC) { return max(dot(lightDirectionEC, normalEC), 0.0); } `;var ovt=T(S(),1),FR=`/** * Calculates the specular intensity of reflected light. * * @name czm_getSpecular * @glslFunction * * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates. * @param {vec3} toEyeEC Unit vector pointing to the eye position in eye coordinates. * @param {vec3} normalEC The surface normal in eye coordinates. * @param {float} shininess The sharpness of the specular reflection. Higher values create a smaller, more focused specular highlight. * * @returns {float} The intensity of the specular highlight. * * @see czm_phong * * @example * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC); * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200); * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity); */ float czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess) { vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC); float specular = max(dot(toReflectedLight, toEyeEC), 0.0); // pow has undefined behavior if both parameters <= 0. // Prevent this by making sure shininess is at least czm_epsilon2. return pow(specular, max(shininess, czm_epsilon2)); } `;var svt=T(S(),1),AR=`/** * @private */ vec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians) { float cosAngle = cos(angleInRadians); float sinAngle = sin(angleInRadians); // time dependent sampling directions vec2 s0 = vec2(1.0/17.0, 0.0); vec2 s1 = vec2(-1.0/29.0, 0.0); vec2 s2 = vec2(1.0/101.0, 1.0/59.0); vec2 s3 = vec2(-1.0/109.0, -1.0/57.0); // rotate sampling direction by specified angle s0 = vec2((cosAngle * s0.x) - (sinAngle * s0.y), (sinAngle * s0.x) + (cosAngle * s0.y)); s1 = vec2((cosAngle * s1.x) - (sinAngle * s1.y), (sinAngle * s1.x) + (cosAngle * s1.y)); s2 = vec2((cosAngle * s2.x) - (sinAngle * s2.y), (sinAngle * s2.x) + (cosAngle * s2.y)); s3 = vec2((cosAngle * s3.x) - (sinAngle * s3.y), (sinAngle * s3.x) + (cosAngle * s3.y)); vec2 uv0 = (uv/103.0) + (time * s0); vec2 uv1 = uv/107.0 + (time * s1) + vec2(0.23); vec2 uv2 = uv/vec2(897.0, 983.0) + (time * s2) + vec2(0.51); vec2 uv3 = uv/vec2(991.0, 877.0) + (time * s3) + vec2(0.71); uv0 = fract(uv0); uv1 = fract(uv1); uv2 = fract(uv2); uv3 = fract(uv3); vec4 noise = (texture(normalMap, uv0)) + (texture(normalMap, uv1)) + (texture(normalMap, uv2)) + (texture(normalMap, uv3)); // average and scale to between -1 and 1 return ((noise / 4.0) - 0.5) * 2.0; } `;var cvt=T(S(),1),MR=`/** * Adjusts the hue of a color. * * @name czm_hue * @glslFunction * * @param {vec3} rgb The color. * @param {float} adjustment The amount to adjust the hue of the color in radians. * * @returns {float} The color with the hue adjusted. * * @example * vec3 adjustHue = czm_hue(color, czm_pi); // The same as czm_hue(color, -czm_pi) */ vec3 czm_hue(vec3 rgb, float adjustment) { const mat3 toYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135); const mat3 toRGB = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.107, 1.7046); vec3 yiq = toYIQ * rgb; float hue = atan(yiq.z, yiq.y) + adjustment; float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y); vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue)); return toRGB * color; } `;var dvt=T(S(),1),NR=`/** * Converts a color in linear space to RGB space. * * @name czm_inverseGamma * @glslFunction * * @param {vec3} color The color in linear space. * @returns {vec3} The color in RGB space. */ vec3 czm_inverseGamma(vec3 color) { return pow(color, vec3(1.0 / czm_gamma)); } `;var mvt=T(S(),1),kR=`/** * Determines if a time interval is empty. * * @name czm_isEmpty * @glslFunction * * @param {czm_raySegment} interval The interval to test. * * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>. * * @example * bool b0 = czm_isEmpty(czm_emptyRaySegment); // true * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0. */ bool czm_isEmpty(czm_raySegment interval) { return (interval.stop < 0.0); } `;var fvt=T(S(),1),UR=`/** * Determines if a time interval is empty. * * @name czm_isFull * @glslFunction * * @param {czm_raySegment} interval The interval to test. * * @returns {bool} <code>true</code> if the time interval is empty; otherwise, <code>false</code>. * * @example * bool b0 = czm_isEmpty(czm_emptyRaySegment); // true * bool b1 = czm_isEmpty(czm_raySegment(0.0, 1.0)); // false * bool b2 = czm_isEmpty(czm_raySegment(1.0, 1.0)); // false, contains 1.0. */ bool czm_isFull(czm_raySegment interval) { return (interval.start == 0.0 && interval.stop == czm_infinity); } `;var bvt=T(S(),1),DR=`/** * Computes the fraction of a Web Wercator rectangle at which a given geodetic latitude is located. * * @name czm_latitudeToWebMercatorFraction * @glslFunction * * @param {float} latitude The geodetic latitude, in radians. * @param {float} southMercatorY The Web Mercator coordinate of the southern boundary of the rectangle. * @param {float} oneOverMercatorHeight The total height of the rectangle in Web Mercator coordinates. * * @returns {float} The fraction of the rectangle at which the latitude occurs. If the"
}