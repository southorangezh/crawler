{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 163,
    "total_chunks": 194,
    "chunk_size": 8438,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.747Z"
  },
  "content": "{ return RayShapeIntersection(miss, miss); } else if (p0InShadowCone) { return RayShapeIntersection(intersect1, farSide); } else if (p1InShadowCone) { return RayShapeIntersection(-1.0 * farSide, intersect0); } else { return RayShapeIntersection(intersect0, intersect1); } } void intersectShape(in Ray ray, inout Intersections ix) { // Position is converted from [0,1] to [-1,+1] because shape intersections assume unit space is [-1,+1]. // Direction is scaled as well to be in sync with position. ray.pos = ray.pos * 2.0 - 1.0; ray.dir *= 2.0; // Outer ellipsoid RayShapeIntersection outerIntersect = intersectHeight(ray, u_clipMinMaxHeight.y, true); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX, outerIntersect); // Exit early if the outer ellipsoid was missed. if (outerIntersect.entry.w == NO_HIT) { return; } // Inner ellipsoid RayShapeIntersection innerIntersect = intersectHeight(ray, u_clipMinMaxHeight.x, false); if (innerIntersect.entry.w == NO_HIT) { setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN, innerIntersect); } else { // When the ellipsoid is large and thin it's possible for floating point math // to cause the ray to intersect the inner ellipsoid before the outer ellipsoid. // To prevent this from happening, clamp innerIntersect to outerIntersect and // sandwich the inner ellipsoid intersection inside the outer ellipsoid intersection. // Without this special case, // [outerMin, outerMax, innerMin, innerMax] will bubble sort to // [outerMin, innerMin, outerMax, innerMax] which will cause the back // side of the ellipsoid to be invisible because it will think the ray // is still inside the inner (negative) ellipsoid after exiting the // outer (positive) ellipsoid. // With this special case, // [outerMin, innerMin, innerMax, outerMax] will bubble sort to // [outerMin, innerMin, innerMax, outerMax] which will work correctly. // Note: If initializeIntersections() changes its sorting function // from bubble sort to something else, this code may need to change. innerIntersect.entry.w = max(innerIntersect.entry.w, outerIntersect.entry.w); innerIntersect.exit.w = min(innerIntersect.exit.w, outerIntersect.exit.w); setSurfaceIntersection(ix, 0, outerIntersect.entry, true, true); // positive, enter setSurfaceIntersection(ix, 1, innerIntersect.entry, false, true); // negative, enter setSurfaceIntersection(ix, 2, innerIntersect.exit, false, false); // negative, exit setSurfaceIntersection(ix, 3, outerIntersect.exit, true, false); // positive, exit } // Bottom cone #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF) RayShapeIntersection bottomConeIntersection = intersectRegularCone(ray, u_ellipsoidRenderLatitudeSinMinMax.x, false); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN, bottomConeIntersection); #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF) RayShapeIntersection bottomConeIntersection = intersectZPlane(ray, -1.0); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN, bottomConeIntersection); #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF) RayShapeIntersection bottomConeIntersections[2]; intersectFlippedCone(ray, u_ellipsoidRenderLatitudeSinMinMax.x, bottomConeIntersections); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN + 0, bottomConeIntersections[0]); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN + 1, bottomConeIntersections[1]); #endif // Top cone #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF) RayShapeIntersection topConeIntersections[2]; intersectFlippedCone(ray, u_ellipsoidRenderLatitudeSinMinMax.y, topConeIntersections); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX + 0, topConeIntersections[0]); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX + 1, topConeIntersections[1]); #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF) RayShapeIntersection topConeIntersection = intersectZPlane(ray, 1.0); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX, topConeIntersection); #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF) RayShapeIntersection topConeIntersection = intersectRegularCone(ray, u_ellipsoidRenderLatitudeSinMinMax.y, false); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX, topConeIntersection); #endif // Wedge #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO) RayShapeIntersection wedgeIntersects[2]; intersectHalfPlane(ray, u_ellipsoidRenderLongitudeMinMax.x, wedgeIntersects); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 0, wedgeIntersects[0]); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 1, wedgeIntersects[1]); #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF) RayShapeIntersection wedgeIntersect = intersectRegularWedge(ray, u_ellipsoidRenderLongitudeMinMax); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE, wedgeIntersect); #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF) RayShapeIntersection wedgeIntersects[2]; intersectFlippedWedge(ray, u_ellipsoidRenderLongitudeMinMax, wedgeIntersects); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 0, wedgeIntersects[0]); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 1, wedgeIntersects[1]); #endif } `;var ZAi=T(S(),1),kT=`// Main intersection function for Voxel scenes. // See IntersectBox.glsl, IntersectCylinder.glsl, or IntersectEllipsoid.glsl // for the definition of intersectShape. The appropriate function is selected // based on the VoxelPrimitive shape type, and added to the shader in // Scene/VoxelRenderResources.js. // See also IntersectClippingPlane.glsl and IntersectDepth.glsl. // See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, // getFirstIntersection, initializeIntersections, nextIntersection. /* Intersection defines (set in Scene/VoxelRenderResources.js) #define INTERSECTION_COUNT ### */ RayShapeIntersection intersectScene(in vec2 screenCoord, in Ray ray, out Intersections ix) { // Do a ray-shape intersection to find the exact starting and ending points. intersectShape(ray, ix); // Exit early if the positive shape was completely missed or behind the ray. RayShapeIntersection intersection = getFirstIntersection(ix); if (intersection.entry.w == NO_HIT) { // Positive shape was completely missed - so exit early. return intersection; } // Clipping planes #if defined(CLIPPING_PLANES) intersectClippingPlanes(ray, ix); #endif // Depth #if defined(DEPTH_TEST) intersectDepth(screenCoord, ray, ix); #endif // Find the first intersection that's in front of the ray #if (INTERSECTION_COUNT > 1) initializeIntersections(ix); for (int i = 0; i < INTERSECTION_COUNT; ++i) { intersection = nextIntersection(ix); if (intersection.exit.w > 0.0) { // Set start to 0.0 when ray is inside the shape. intersection.entry.w = max(intersection.entry.w, 0.0); break; } } #else // Set start to 0.0 when ray is inside the shape. intersection.entry.w = max(intersection.entry.w, 0.0); #endif return intersection; } `;var GAi=T(S(),1),e9=`/* Box defines (set in Scene/VoxelBoxShape.js) #define BOX_HAS_SHAPE_BOUNDS */ #if defined(BOX_HAS_SHAPE_BOUNDS) uniform vec3 u_boxUvToShapeUvScale; uniform vec3 u_boxUvToShapeUvTranslate; #endif PointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) { // For BOX, UV space = shape space, so we can use positionUv as-is, // and the Jacobian is the identity matrix, except that a step of 1 // only spans half the shape space [-1, 1], so the identity is scaled. return PointJacobianT(positionUv, mat3(0.5)); } vec3 convertShapeToShapeUvSpace(in vec3 positionShape) { #if defined(BOX_HAS_SHAPE_BOUNDS) return positionShape * u_boxUvToShapeUvScale + u_boxUvToShapeUvTranslate; #else return positionShape; #endif } PointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) { PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv); pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point); return pointJacobian; } vec3 convertShapeUvToUvSpace(in vec3 shapeUv) { #if defined(BOX_HAS_SHAPE_BOUNDS) return (shapeUv - u_boxUvToShapeUvTranslate) / u_boxUvToShapeUvScale; #else return shapeUv; #endif } vec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) { #if defined(BOX_HAS_SHAPE_BOUNDS) return shapeUv / u_boxUvToShapeUvScale; #else return shapeUv; #endif }`;var"
}