{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 47,
    "total_chunks": 194,
    "chunk_size": 6351,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.674Z"
  },
  "content": "} color.rgb = czm_gammaCorrect(color.rgb); material.diffuse = color.rgb; material.alpha = color.a; return material; } `;var k3t=T(S(),1),sE=`uniform vec4 color; uniform float spacing; uniform float width; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); float distanceToContour = mod(materialInput.height, spacing); #if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives)) float dxc = abs(dFdx(materialInput.height)); float dyc = abs(dFdy(materialInput.height)); float dF = max(dxc, dyc) * czm_pixelRatio * width; float alpha = (distanceToContour < dF) ? 1.0 : 0.0; #else // If no derivatives available (IE 10?), use pixel ratio float alpha = (distanceToContour < (czm_pixelRatio * width)) ? 1.0 : 0.0; #endif vec4 outColor = czm_gammaCorrect(vec4(color.rgb, alpha * color.a)); material.diffuse = outColor.rgb; material.alpha = outColor.a; return material; } `;var D3t=T(S(),1),aE=`uniform sampler2D image; uniform float minimumHeight; uniform float maximumHeight; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); float scaledHeight = clamp((materialInput.height - minimumHeight) / (maximumHeight - minimumHeight), 0.0, 1.0); vec4 rampColor = texture(image, vec2(scaledHeight, 0.5)); rampColor = czm_gammaCorrect(rampColor); material.diffuse = rampColor.rgb; material.alpha = rampColor.a; return material; } `;var Y3t=T(S(),1),cE=`uniform vec4 fadeInColor; uniform vec4 fadeOutColor; uniform float maximumDistance; uniform bool repeat; uniform vec2 fadeDirection; uniform vec2 time; float getTime(float t, float coord) { float scalar = 1.0 / maximumDistance; float q = distance(t, coord) * scalar; if (repeat) { float r = distance(t, coord + 1.0) * scalar; float s = distance(t, coord - 1.0) * scalar; q = min(min(r, s), q); } return clamp(q, 0.0, 1.0); } czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st; float s = getTime(time.x, st.s) * fadeDirection.s; float t = getTime(time.y, st.t) * fadeDirection.t; float u = length(vec2(s, t)); vec4 color = mix(fadeInColor, fadeOutColor, u); color = czm_gammaCorrect(color); material.emission = color.rgb; material.alpha = color.a; return material; } `;var z3t=T(S(),1),lE=`uniform vec4 color; uniform float cellAlpha; uniform vec2 lineCount; uniform vec2 lineThickness; uniform vec2 lineOffset; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st; float scaledWidth = fract(lineCount.s * st.s - lineOffset.s); scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5)); float scaledHeight = fract(lineCount.t * st.t - lineOffset.t); scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5)); float value; // Fuzz Factor - Controls blurriness of lines #if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives)) const float fuzz = 1.2; vec2 thickness = (lineThickness * czm_pixelRatio) - 1.0; // From \"3D Engine Design for Virtual Globes\" by Cozzi and Ring, Listing 4.13. vec2 dx = abs(dFdx(st)); vec2 dy = abs(dFdy(st)); vec2 dF = vec2(max(dx.s, dy.s), max(dx.t, dy.t)) * lineCount; value = min( smoothstep(dF.s * thickness.s, dF.s * (fuzz + thickness.s), scaledWidth), smoothstep(dF.t * thickness.t, dF.t * (fuzz + thickness.t), scaledHeight)); #else // If no derivatives available (IE 10?), revert to view-dependent fuzz const float fuzz = 0.05; vec2 range = 0.5 - (lineThickness * 0.05); value = min( 1.0 - smoothstep(range.s, range.s + fuzz, scaledWidth), 1.0 - smoothstep(range.t, range.t + fuzz, scaledHeight)); #endif // Edges taken from RimLightingMaterial.glsl // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html float dRim = 1.0 - abs(dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC))); float sRim = smoothstep(0.8, 1.0, dRim); value *= (1.0 - sRim); vec4 halfColor; halfColor.rgb = color.rgb * 0.5; halfColor.a = color.a * (1.0 - ((1.0 - cellAlpha) * value)); halfColor = czm_gammaCorrect(halfColor); material.diffuse = halfColor.rgb; material.emission = halfColor.rgb; material.alpha = halfColor.a; return material; } `;var K3t=T(S(),1),dE=`uniform sampler2D image; uniform float strength; uniform vec2 repeat; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec4 textureValue = texture(image, fract(repeat * materialInput.st)); vec3 normalTangentSpace = textureValue.channels; normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0; normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0); normalTangentSpace = normalize(normalTangentSpace); vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace; material.normal = normalEC; return material; } `;var Q3t=T(S(),1),uE=`uniform vec4 color; float getPointOnLine(vec2 p0, vec2 p1, float x) { float slope = (p0.y - p1.y) / (p0.x - p1.x); return slope * (x - p0.x) + p0.y; } czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st; #if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives)) float base = 1.0 - abs(fwidth(st.s)) * 10.0 * czm_pixelRatio; #else // If no derivatives available (IE 10?), 2.5% of the line will be the arrow head float base = 0.975; #endif vec2 center = vec2(1.0, 0.5); float ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s); float ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s); float halfWidth = 0.15; float s = step(0.5 - halfWidth, st.t); s *= 1.0 - step(0.5 + halfWidth, st.t); s *= 1.0 - step(base, st.s); float t = step(base, materialInput.st.s); t *= 1.0 - step(ptOnUpperLine, st.t); t *= step(ptOnLowerLine, st.t); // Find the distance from the closest separator (region between two colors) float dist; if (st.s < base) { float d1 = abs(st.t - (0.5 - halfWidth)); float d2 = abs(st.t - (0.5 + halfWidth)); dist = min(d1, d2); } else { float d1 = czm_infinity; if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth) { d1 = abs(st.s - base); } float d2 = abs(st.t - ptOnUpperLine); float d3 = abs(st.t - ptOnLowerLine); dist = min(min(d1, d2), d3); } vec4 outsideColor"
}