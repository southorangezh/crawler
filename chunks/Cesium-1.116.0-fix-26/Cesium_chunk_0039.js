{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 39,
    "total_chunks": 194,
    "chunk_size": 5886,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.667Z"
  },
  "content": "czm_transpose * @glslFunction * * @param {} matrix The matrix to transpose. * * @returns {} The transposed matrix. * * @example * // GLSL declarations * mat2 czm_transpose(mat2 matrix); * mat3 czm_transpose(mat3 matrix); * mat4 czm_transpose(mat4 matrix); * * // Transpose a 3x3 rotation matrix to find its inverse. * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates( * positionMC, normalEC); * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye); */ mat2 czm_transpose(mat2 matrix) { return mat2( matrix[0][0], matrix[1][0], matrix[0][1], matrix[1][1]); } mat3 czm_transpose(mat3 matrix) { return mat3( matrix[0][0], matrix[1][0], matrix[2][0], matrix[0][1], matrix[1][1], matrix[2][1], matrix[0][2], matrix[1][2], matrix[2][2]); } mat4 czm_transpose(mat4 matrix) { return mat4( matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0], matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1], matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2], matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]); } `;var Wwt=T(S(),1),CG=`/** * Unpacks a vec4 depth value to a float in [0, 1) range. * * @name czm_unpackDepth * @glslFunction * * @param {vec4} packedDepth The packed depth. * * @returns {float} The floating-point depth in [0, 1) range. */ float czm_unpackDepth(vec4 packedDepth) { // See Aras Pranckevi\\u010Dius' post Encoding Floats to RGBA // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/ return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)); } `;var vwt=T(S(),1),VG=`/** * Unpack an IEEE 754 single-precision float that is packed as a little-endian unsigned normalized vec4. * * @name czm_unpackFloat * @glslFunction * * @param {vec4} packedFloat The packed float. * * @returns {float} The floating-point depth in arbitrary range. */ float czm_unpackFloat(vec4 packedFloat) { // Convert to [0.0, 255.0] and round to integer packedFloat = floor(packedFloat * 255.0 + 0.5); float sign = 1.0 - step(128.0, packedFloat[3]) * 2.0; float exponent = 2.0 * mod(packedFloat[3], 128.0) + step(128.0, packedFloat[2]) - 127.0; if (exponent == -127.0) { return 0.0; } float mantissa = mod(packedFloat[2], 128.0) * 65536.0 + packedFloat[1] * 256.0 + packedFloat[0] + float(0x800000); float result = sign * exp2(exponent - 23.0) * mantissa; return result; } `;var Fwt=T(S(),1),LG=`/** * Unpack unsigned integers of 1-4 bytes. in WebGL 1, there is no uint type, * so the return value is an int. * <p> * There are also precision limitations in WebGL 1. highp int is still limited * to 24 bits. Above the value of 2^24 = 16777216, precision loss may occur. * </p> * * @param {float|vec2|vec3|vec4} packed The packed value. For vectors, the components are listed in little-endian order. * * @return {int} The unpacked value. */ int czm_unpackUint(float packedValue) { float rounded = czm_round(packedValue * 255.0); return int(rounded); } int czm_unpackUint(vec2 packedValue) { vec2 rounded = czm_round(packedValue * 255.0); return int(dot(rounded, vec2(1.0, 256.0))); } int czm_unpackUint(vec3 packedValue) { vec3 rounded = czm_round(packedValue * 255.0); return int(dot(rounded, vec3(1.0, 256.0, 65536.0))); } int czm_unpackUint(vec4 packedValue) { vec4 rounded = czm_round(packedValue * 255.0); return int(dot(rounded, vec4(1.0, 256.0, 65536.0, 16777216.0))); } `;var Mwt=T(S(),1),ZG=`/** * Transform metadata values following the EXT_structural_metadata spec * by multiplying by scale and adding the offset. Operations are always * performed component-wise, even for matrices. * * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} offset The offset to add * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} scale The scale factor to multiply * @param {float|vec2|vec3|vec4|mat2|mat3|mat4} value The original value. * * @return {float|vec2|vec3|vec4|mat2|mat3|mat4} The transformed value of the same scalar/vector/matrix type as the input. */ float czm_valueTransform(float offset, float scale, float value) { return scale * value + offset; } vec2 czm_valueTransform(vec2 offset, vec2 scale, vec2 value) { return scale * value + offset; } vec3 czm_valueTransform(vec3 offset, vec3 scale, vec3 value) { return scale * value + offset; } vec4 czm_valueTransform(vec4 offset, vec4 scale, vec4 value) { return scale * value + offset; } mat2 czm_valueTransform(mat2 offset, mat2 scale, mat2 value) { return matrixCompMult(scale, value) + offset; } mat3 czm_valueTransform(mat3 offset, mat3 scale, mat3 value) { return matrixCompMult(scale, value) + offset; } mat4 czm_valueTransform(mat4 offset, mat4 scale, mat4 value) { return matrixCompMult(scale, value) + offset; } `;var kwt=T(S(),1),RG=`#ifdef LOG_DEPTH // 1.0 at the near plane, increasing linearly from there. out float v_depthFromNearPlusOne; #ifdef SHADOW_MAP out vec3 v_logPositionEC; #endif #endif vec4 czm_updatePositionDepth(vec4 coords) { #if defined(LOG_DEPTH) #ifdef SHADOW_MAP vec3 logPositionEC = (czm_inverseProjection * coords).xyz; v_logPositionEC = logPositionEC; #endif // With the very high far/near ratios used with the logarithmic depth // buffer, floating point rounding errors can cause linear depth values // to end up on the wrong side of the far plane, even for vertices that // are really nowhere near it. Since we always write a correct logarithmic // depth value in the fragment shader anyway, we just need to make sure // such errors don't cause the primitive to be clipped entirely before // we even get to the fragment shader. coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w; #endif return coords; } /** * Writes the logarithmic depth to gl_Position using the already computed gl_Position. * * @name czm_vertexLogDepth * @glslFunction */ void czm_vertexLogDepth() { #ifdef LOG_DEPTH v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0; gl_Position = czm_updatePositionDepth(gl_Position); #endif } /** * Writes the logarithmic"
}