{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 94,
    "total_chunks": 194,
    "chunk_size": 7279,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.701Z"
  },
  "content": "origin.x = floor(compressed * SHIFT_RIGHT5); compressed -= origin.x * SHIFT_LEFT5; origin.y = floor(compressed * SHIFT_RIGHT3); compressed -= origin.y * SHIFT_LEFT3; #ifdef FRAGMENT_DEPTH_CHECK vec2 depthOrigin = origin.xy; #endif origin -= vec2(1.0); float show = floor(compressed * SHIFT_RIGHT2); compressed -= show * SHIFT_LEFT2; #ifdef INSTANCED vec2 textureCoordinatesBottomLeft = czm_decompressTextureCoordinates(compressedAttribute0.w); vec2 textureCoordinatesRange = czm_decompressTextureCoordinates(eyeOffset.w); vec2 textureCoordinates = textureCoordinatesBottomLeft + direction * textureCoordinatesRange; #else vec2 direction; direction.x = floor(compressed * SHIFT_RIGHT1); direction.y = compressed - direction.x * SHIFT_LEFT1; vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w); #endif float temp = compressedAttribute0.y * SHIFT_RIGHT8; pixelOffset.y = -(floor(temp) - UPPER_BOUND); vec2 translate; translate.y = (temp - floor(temp)) * SHIFT_LEFT16; temp = compressedAttribute0.z * SHIFT_RIGHT8; translate.x = floor(temp) - UPPER_BOUND; translate.y += (temp - floor(temp)) * SHIFT_LEFT8; translate.y -= UPPER_BOUND; temp = compressedAttribute1.x * SHIFT_RIGHT8; float temp2 = floor(compressedAttribute2.w * SHIFT_RIGHT2); vec2 imageSize = vec2(floor(temp), temp2); #ifdef FRAGMENT_DEPTH_CHECK float labelHorizontalOrigin = floor(compressedAttribute2.w - (temp2 * SHIFT_LEFT2)); float applyTranslate = 0.0; if (labelHorizontalOrigin != 0.0) // is a billboard, so set apply translate to false { applyTranslate = 1.0; labelHorizontalOrigin -= 2.0; depthOrigin.x = labelHorizontalOrigin + 1.0; } depthOrigin = vec2(1.0) - (depthOrigin * 0.5); #endif #ifdef EYE_DISTANCE_TRANSLUCENCY vec4 translucencyByDistance; translucencyByDistance.x = compressedAttribute1.z; translucencyByDistance.z = compressedAttribute1.w; translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0; temp = compressedAttribute1.y * SHIFT_RIGHT8; translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0; #endif #if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK) temp = compressedAttribute3.w; temp = temp * SHIFT_RIGHT12; vec2 dimensions; dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12; dimensions.x = floor(temp); #endif #ifdef ALIGNED_AXIS vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8)); temp = compressedAttribute2.z * SHIFT_RIGHT5; bool validAlignedAxis = (temp - floor(temp)) * SHIFT_LEFT1 > 0.0; #else vec3 alignedAxis = vec3(0.0); bool validAlignedAxis = false; #endif vec4 pickColor; vec4 color; temp = compressedAttribute2.y; temp = temp * SHIFT_RIGHT8; pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8; temp = floor(temp) * SHIFT_RIGHT8; pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8; pickColor.r = floor(temp); temp = compressedAttribute2.x; temp = temp * SHIFT_RIGHT8; color.b = (temp - floor(temp)) * SHIFT_LEFT8; temp = floor(temp) * SHIFT_RIGHT8; color.g = (temp - floor(temp)) * SHIFT_LEFT8; color.r = floor(temp); temp = compressedAttribute2.z * SHIFT_RIGHT8; bool sizeInMeters = floor((temp - floor(temp)) * SHIFT_LEFT7) > 0.0; temp = floor(temp) * SHIFT_RIGHT8; pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8; pickColor /= 255.0; color.a = floor(temp); color /= 255.0; /////////////////////////////////////////////////////////////////////////// vec4 p = czm_translateRelativeToEye(positionHigh, positionLow); vec4 positionEC = czm_modelViewRelativeToEye * p; #if defined(FRAGMENT_DEPTH_CHECK) || defined(VERTEX_DEPTH_CHECK) float eyeDepth = positionEC.z; #endif positionEC = czm_eyeOffset(positionEC, eyeOffset.xyz); positionEC.xyz *= show; /////////////////////////////////////////////////////////////////////////// #if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE) float lengthSq; if (czm_sceneMode == czm_sceneMode2D) { // 2D camera distance is a special case // treat all billboards as flattened to the z=0.0 plane lengthSq = czm_eyeHeight2D.y; } else { lengthSq = dot(positionEC.xyz, positionEC.xyz); } #endif #ifdef EYE_DISTANCE_SCALING float distanceScale = czm_nearFarScalar(scaleByDistance, lengthSq); scale *= distanceScale; translate *= distanceScale; // push vertex behind near plane for clipping if (scale == 0.0) { positionEC.xyz = vec3(0.0); } #endif float translucency = 1.0; #ifdef EYE_DISTANCE_TRANSLUCENCY translucency = czm_nearFarScalar(translucencyByDistance, lengthSq); // push vertex behind near plane for clipping if (translucency == 0.0) { positionEC.xyz = vec3(0.0); } #endif #ifdef EYE_DISTANCE_PIXEL_OFFSET float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq); pixelOffset *= pixelOffsetScale; #endif #ifdef DISTANCE_DISPLAY_CONDITION float nearSq = compressedAttribute3.x; float farSq = compressedAttribute3.y; if (lengthSq < nearSq || lengthSq > farSq) { positionEC.xyz = vec3(0.0); } #endif mat2 rotationMatrix; float mpp; #ifdef DISABLE_DEPTH_DISTANCE float disableDepthTestDistance = compressedAttribute3.z; #endif #ifdef VERTEX_DEPTH_CHECK if (lengthSq < disableDepthTestDistance) { float depthsilon = 10.0; vec2 labelTranslate = textureCoordinateBoundsOrLabelTranslate.xy; vec4 pEC1 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp); float globeDepth1 = getGlobeDepth(pEC1); if (globeDepth1 != 0.0 && pEC1.z + depthsilon < globeDepth1) { vec4 pEC2 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0, 1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp); float globeDepth2 = getGlobeDepth(pEC2); if (globeDepth2 != 0.0 && pEC2.z + depthsilon < globeDepth2) { vec4 pEC3 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp); float globeDepth3 = getGlobeDepth(pEC3); if (globeDepth3 != 0.0 && pEC3.z + depthsilon < globeDepth3) { positionEC.xyz = vec3(0.0); } } } } #endif positionEC = addScreenSpaceOffset(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp); gl_Position = czm_projection * positionEC; v_textureCoordinates = textureCoordinates; #ifdef LOG_DEPTH czm_vertexLogDepth(); #endif #ifdef DISABLE_DEPTH_DISTANCE if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0) { disableDepthTestDistance = czm_minimumDisableDepthTestDistance; } if (disableDepthTestDistance != 0.0) { // Don't try to \"multiply both sides\" by w. Greater/less-than comparisons won't work for negative values of w. float zclip = gl_Position.z / gl_Position.w; bool clipped = (zclip < -1.0 || zclip > 1.0); if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance))) { // Position z on the near plane. gl_Position.z = -gl_Position.w; #ifdef LOG_DEPTH v_depthFromNearPlusOne = 1.0; #endif } } #endif #ifdef FRAGMENT_DEPTH_CHECK if (sizeInMeters) { translate /= mpp; dimensions /= mpp;"
}