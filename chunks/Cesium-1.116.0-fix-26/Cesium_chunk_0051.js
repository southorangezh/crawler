{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 51,
    "total_chunks": 194,
    "chunk_size": 21436,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.676Z"
  },
  "content": "h);let o=h.subtract(t,e,sXe),r=n.normal,s=h.dot(r,o);if(Math.abs(s)<P.EPSILON6)return;let a=h.dot(r,e),c=-(n.distance+a)/s;if(!(c<0||c>1))return h.multiplyByScalar(o,c,i),h.add(e,i,i),i};Wo.trianglePlaneIntersection=function(e,t,n,i){let o=i.normal,r=i.distance,s=h.dot(o,e)+r<0,a=h.dot(o,t)+r<0,c=h.dot(o,n)+r<0,d=0;d+=s?1:0,d+=a?1:0,d+=c?1:0;let u,m;if((d===1||d===2)&&(u=new h,m=new h),d===1){if(s)return Wo.lineSegmentPlane(e,t,i,u),Wo.lineSegmentPlane(e,n,i,m),{positions:[e,t,n,u,m],indices:[0,3,4,1,2,4,1,4,3]};if(a)return Wo.lineSegmentPlane(t,n,i,u),Wo.lineSegmentPlane(t,e,i,m),{positions:[e,t,n,u,m],indices:[1,3,4,2,0,4,2,4,3]};if(c)return Wo.lineSegmentPlane(n,e,i,u),Wo.lineSegmentPlane(n,t,i,m),{positions:[e,t,n,u,m],indices:[2,3,4,0,1,4,0,4,3]}}else if(d===2)if(s)if(a){if(!c)return Wo.lineSegmentPlane(e,n,i,u),Wo.lineSegmentPlane(t,n,i,m),{positions:[e,t,n,u,m],indices:[0,1,4,0,4,3,2,3,4]}}else return Wo.lineSegmentPlane(n,t,i,u),Wo.lineSegmentPlane(e,t,i,m),{positions:[e,t,n,u,m],indices:[2,0,4,2,4,3,1,3,4]};else return Wo.lineSegmentPlane(t,e,i,u),Wo.lineSegmentPlane(n,e,i,m),{positions:[e,t,n,u,m],indices:[1,2,4,1,4,3,0,3,4]}};var jn=Wo;var tO=new se;function qh(e,t){t=g(t,oe.WGS84),e=t.scaleToGeodeticSurface(e);let n=Wt.eastNorthUpToFixedFrame(e,t);this._ellipsoid=t,this._origin=e,this._xAxis=h.fromCartesian4(M.getColumn(n,0,tO)),this._yAxis=h.fromCartesian4(M.getColumn(n,1,tO));let i=h.fromCartesian4(M.getColumn(n,2,tO));this._plane=an.fromPointNormal(e,i)}Object.defineProperties(qh.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},origin:{get:function(){return this._origin}},plane:{get:function(){return this._plane}},xAxis:{get:function(){return this._xAxis}},yAxis:{get:function(){return this._yAxis}},zAxis:{get:function(){return this._plane.normal}}});var aXe=new vb;qh.fromPoints=function(e,t){let n=vb.fromPoints(e,aXe);return new qh(n.center,t)};var Vte=new bn,p5=new h;qh.prototype.projectPointOntoPlane=function(e,t){let n=Vte;n.origin=e,h.normalize(e,n.direction);let i=jn.rayPlane(n,this._plane,p5);if(l(i)||(h.negate(n.direction,n.direction),i=jn.rayPlane(n,this._plane,p5)),l(i)){let o=h.subtract(i,this._origin,i),r=h.dot(this._xAxis,o),s=h.dot(this._yAxis,o);return l(t)?(t.x=r,t.y=s,t):new D(r,s)}};qh.prototype.projectPointsOntoPlane=function(e,t){l(t)||(t=[]);let n=0,i=e.length;for(let o=0;o<i;o++){let r=this.projectPointOntoPlane(e[o],t[n]);l(r)&&(t[n]=r,n++)}return t.length=n,t};qh.prototype.projectPointToNearestOnPlane=function(e,t){l(t)||(t=new D);let n=Vte;n.origin=e,h.clone(this._plane.normal,n.direction);let i=jn.rayPlane(n,this._plane,p5);l(i)||(h.negate(n.direction,n.direction),i=jn.rayPlane(n,this._plane,p5));let o=h.subtract(i,this._origin,i),r=h.dot(this._xAxis,o),s=h.dot(this._yAxis,o);return t.x=r,t.y=s,t};qh.prototype.projectPointsToNearestOnPlane=function(e,t){l(t)||(t=[]);let n=e.length;t.length=n;for(let i=0;i<n;i++)t[i]=this.projectPointToNearestOnPlane(e[i],t[i]);return t};var cXe=new h;qh.prototype.projectPointOntoEllipsoid=function(e,t){l(t)||(t=new h);let n=this._ellipsoid,i=this._origin,o=this._xAxis,r=this._yAxis,s=cXe;return h.multiplyByScalar(o,e.x,s),t=h.add(i,s,t),h.multiplyByScalar(r,e.y,s),h.add(t,s,t),n.scaleToGeocentricSurface(t,t),t};qh.prototype.projectPointsOntoEllipsoid=function(e,t){let n=e.length;l(t)?t.length=n:t=new Array(n);for(let i=0;i<n;++i)t[i]=this.projectPointOntoEllipsoid(e[i],t[i]);return t};var Dr=qh;function wi(e,t){this.center=h.clone(g(e,h.ZERO)),this.halfAxes=$.clone(g(t,$.ZERO))}wi.packedLength=h.packedLength+$.packedLength;wi.pack=function(e,t,n){return n=g(n,0),h.pack(e.center,t,n),$.pack(e.halfAxes,t,n+h.packedLength),t};wi.unpack=function(e,t,n){return t=g(t,0),l(n)||(n=new wi),h.unpack(e,t,n.center),$.unpack(e,t+h.packedLength,n.halfAxes),n};var lXe=new h,dXe=new h,uXe=new h,mXe=new h,hXe=new h,fXe=new h,pXe=new $,bXe={unitary:new $,diagonal:new $};wi.fromPoints=function(e,t){if(l(t)||(t=new wi),!l(e)||e.length===0)return t.halfAxes=$.ZERO,t.center=h.ZERO,t;let n,i=e.length,o=h.clone(e[0],lXe);for(n=1;n<i;n++)h.add(o,e[n],o);let r=1/i;h.multiplyByScalar(o,r,o);let s=0,a=0,c=0,d=0,u=0,m=0,p;for(n=0;n<i;n++)p=h.subtract(e[n],o,dXe),s+=p.x*p.x,a+=p.x*p.y,c+=p.x*p.z,d+=p.y*p.y,u+=p.y*p.z,m+=p.z*p.z;s*=r,a*=r,c*=r,d*=r,u*=r,m*=r;let b=pXe;b[0]=s,b[1]=a,b[2]=c,b[3]=a,b[4]=d,b[5]=u,b[6]=c,b[7]=u,b[8]=m;let f=$.computeEigenDecomposition(b,bXe),x=$.clone(f.unitary,t.halfAxes),_=$.getColumn(x,0,mXe),C=$.getColumn(x,1,hXe),V=$.getColumn(x,2,fXe),L=-Number.MAX_VALUE,R=-Number.MAX_VALUE,G=-Number.MAX_VALUE,X=Number.MAX_VALUE,v=Number.MAX_VALUE,W=Number.MAX_VALUE;for(n=0;n<i;n++)p=e[n],L=Math.max(h.dot(_,p),L),R=Math.max(h.dot(C,p),R),G=Math.max(h.dot(V,p),G),X=Math.min(h.dot(_,p),X),v=Math.min(h.dot(C,p),v),W=Math.min(h.dot(V,p),W);_=h.multiplyByScalar(_,.5*(X+L),_),C=h.multiplyByScalar(C,.5*(v+R),C),V=h.multiplyByScalar(V,.5*(W+G),V);let F=h.add(_,C,t.center);h.add(F,V,F);let A=uXe;return A.x=L-X,A.y=R-v,A.z=G-W,h.multiplyByScalar(A,.5,A),$.multiplyByScale(t.halfAxes,A,t.halfAxes),t};var Xte=new h,yXe=new h;function Lte(e,t,n,i,o,r,s,a,c,d,u){l(u)||(u=new wi);let m=u.halfAxes;$.setColumn(m,0,t,m),$.setColumn(m,1,n,m),$.setColumn(m,2,i,m);let p=Xte;p.x=(o+r)/2,p.y=(s+a)/2,p.z=(c+d)/2;let b=yXe;b.x=(r-o)/2,b.y=(a-s)/2,b.z=(d-c)/2;let f=u.center;return p=$.multiplyByVector(m,p,p),h.add(e,p,f),$.multiplyByScale(m,b,m),u}var Zte=new he,gXe=new h,xXe=new he,_Xe=new he,TXe=new he,SXe=new he,CXe=new he,VXe=new h,Rte=new h,LXe=new h,Gte=new h,ZXe=new h,RXe=new D,GXe=new D,EXe=new D,XXe=new D,IXe=new D,WXe=new h,PXe=new h,vXe=new h,wXe=new h,FXe=new D,AXe=new h,MXe=new h,NXe=new h,kXe=new an(h.UNIT_X,0);wi.fromRectangle=function(e,t,n,i,o){t=g(t,0),n=g(n,0),i=g(i,oe.WGS84);let r,s,a,c,d,u,m;if(e.width<=P.PI){let v=le.center(e,Zte),W=i.cartographicToCartesian(v,gXe),F=new Dr(W,i);m=F.plane;let A=v.longitude,y=e.south<0&&e.north>0?0:v.latitude,Z=he.fromRadians(A,e.north,n,xXe),E=he.fromRadians(e.west,e.north,n,_Xe),I=he.fromRadians(e.west,y,n,TXe),w=he.fromRadians(e.west,e.south,n,SXe),k=he.fromRadians(A,e.south,n,CXe),B=i.cartographicToCartesian(Z,VXe),U=i.cartographicToCartesian(E,Rte),Y=i.cartographicToCartesian(I,LXe),N=i.cartographicToCartesian(w,Gte),J=i.cartographicToCartesian(k,ZXe),z=F.projectPointToNearestOnPlane(B,RXe),ee=F.projectPointToNearestOnPlane(U,GXe),H=F.projectPointToNearestOnPlane(Y,EXe),j=F.projectPointToNearestOnPlane(N,XXe),q=F.projectPointToNearestOnPlane(J,IXe);return r=Math.min(ee.x,H.x,j.x),s=-r,c=Math.max(ee.y,z.y),a=Math.min(j.y,q.y),E.height=w.height=t,U=i.cartographicToCartesian(E,Rte),N=i.cartographicToCartesian(w,Gte),d=Math.min(an.getPointDistance(m,U),an.getPointDistance(m,N)),u=n,Lte(F.origin,F.xAxis,F.yAxis,F.zAxis,r,s,a,c,d,u,o)}let p=e.south>0,b=e.north<0,f=p?e.south:b?e.north:0,x=le.center(e,Zte).longitude,_=h.fromRadians(x,f,n,i,WXe);_.z=0;let V=Math.abs(_.x)<P.EPSILON10&&Math.abs(_.y)<P.EPSILON10?h.UNIT_X:h.normalize(_,PXe),L=h.UNIT_Z,R=h.cross(V,L,vXe);m=an.fromPointNormal(_,V,kXe);let G=h.fromRadians(x+P.PI_OVER_TWO,f,n,i,wXe);s=h.dot(an.projectPointOntoPlane(m,G,FXe),R),r=-s,c=h.fromRadians(0,e.north,b?t:n,i,AXe).z,a=h.fromRadians(0,e.south,p?t:n,i,MXe).z;let X=h.fromRadians(e.east,f,n,i,NXe);return d=an.getPointDistance(m,X),u=0,Lte(_,R,L,V,r,s,a,c,d,u,o)};wi.fromTransformation=function(e,t){return l(t)||(t=new wi),t.center=M.getTranslation(e,t.center),t.halfAxes=M.getMatrix3(e,t.halfAxes),t.halfAxes=$.multiplyByScalar(t.halfAxes,.5,t.halfAxes),t};wi.clone=function(e,t){if(l(e))return l(t)?(h.clone(e.center,t.center),$.clone(e.halfAxes,t.halfAxes),t):new wi(e.center,e.halfAxes)};wi.intersectPlane=function(e,t){let n=e.center,i=t.normal,o=e.halfAxes,r=i.x,s=i.y,a=i.z,c=Math.abs(r*o[$.COLUMN0ROW0]+s*o[$.COLUMN0ROW1]+a*o[$.COLUMN0ROW2])+Math.abs(r*o[$.COLUMN1ROW0]+s*o[$.COLUMN1ROW1]+a*o[$.COLUMN1ROW2])+Math.abs(r*o[$.COLUMN2ROW0]+s*o[$.COLUMN2ROW1]+a*o[$.COLUMN2ROW2]),d=h.dot(i,n)+t.distance;return d<=-c?nn.OUTSIDE:d>=c?nn.INSIDE:nn.INTERSECTING};var Ite=new h,Wte=new h,Pte=new h,UXe=new h,Ete=new h,DXe=new h;wi.distanceSquaredTo=function(e,t){let n=h.subtract(t,e.center,Xte),i=e.halfAxes,o=$.getColumn(i,0,Ite),r=$.getColumn(i,1,Wte),s=$.getColumn(i,2,Pte),a=h.magnitude(o),c=h.magnitude(r),d=h.magnitude(s),u=!0,m=!0,p=!0;a>0?h.divideByScalar(o,a,o):u=!1,c>0?h.divideByScalar(r,c,r):m=!1,d>0?h.divideByScalar(s,d,s):p=!1;let b=!u+!m+!p,f,x,_;if(b===1){let R=o;f=r,x=s,m?p||(R=s,x=o):(R=r,f=o),_=h.cross(f,x,Ete),R===o?o=_:R===r?r=_:R===s&&(s=_)}else if(b===2){f=o,m?f=r:p&&(f=s);let R=h.UNIT_Y;R.equalsEpsilon(f,P.EPSILON3)&&(R=h.UNIT_X),x=h.cross(f,R,UXe),h.normalize(x,x),_=h.cross(f,x,Ete),h.normalize(_,_),f===o?(r=x,s=_):f===r?(s=x,o=_):f===s&&(o=x,r=_)}else b===3&&(o=h.UNIT_X,r=h.UNIT_Y,s=h.UNIT_Z);let C=DXe;C.x=h.dot(n,o),C.y=h.dot(n,r),C.z=h.dot(n,s);let V=0,L;return C.x<-a?(L=C.x+a,V+=L*L):C.x>a&&(L=C.x-a,V+=L*L),C.y<-c?(L=C.y+c,V+=L*L):C.y>c&&(L=C.y-c,V+=L*L),C.z<-d?(L=C.z+d,V+=L*L):C.z>d&&(L=C.z-d,V+=L*L),V};var BXe=new h,YXe=new h;wi.computePlaneDistances=function(e,t,n,i){l(i)||(i=new Va);let o=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,s=e.center,a=e.halfAxes,c=$.getColumn(a,0,Ite),d=$.getColumn(a,1,Wte),u=$.getColumn(a,2,Pte),m=h.add(c,d,BXe);h.add(m,u,m),h.add(m,s,m);let p=h.subtract(m,t,YXe),b=h.dot(n,p);return o=Math.min(b,o),r=Math.max(b,r),h.add(s,c,m),h.add(m,d,m),h.subtract(m,u,m),h.subtract(m,t,p),b=h.dot(n,p),o=Math.min(b,o),r=Math.max(b,r),h.add(s,c,m),h.subtract(m,d,m),h.add(m,u,m),h.subtract(m,t,p),b=h.dot(n,p),o=Math.min(b,o),r=Math.max(b,r),h.add(s,c,m),h.subtract(m,d,m),h.subtract(m,u,m),h.subtract(m,t,p),b=h.dot(n,p),o=Math.min(b,o),r=Math.max(b,r),h.subtract(s,c,m),h.add(m,d,m),h.add(m,u,m),h.subtract(m,t,p),b=h.dot(n,p),o=Math.min(b,o),r=Math.max(b,r),h.subtract(s,c,m),h.add(m,d,m),h.subtract(m,u,m),h.subtract(m,t,p),b=h.dot(n,p),o=Math.min(b,o),r=Math.max(b,r),h.subtract(s,c,m),h.subtract(m,d,m),h.add(m,u,m),h.subtract(m,t,p),b=h.dot(n,p),o=Math.min(b,o),r=Math.max(b,r),h.subtract(s,c,m),h.subtract(m,d,m),h.subtract(m,u,m),h.subtract(m,t,p),b=h.dot(n,p),o=Math.min(b,o),r=Math.max(b,r),i.start=o,i.stop=r,i};var OXe=new h,zXe=new h,HXe=new h;wi.computeCorners=function(e,t){l(t)||(t=[new h,new h,new h,new h,new h,new h,new h,new h]);let n=e.center,i=e.halfAxes,o=$.getColumn(i,0,OXe),r=$.getColumn(i,1,zXe),s=$.getColumn(i,2,HXe);return h.clone(n,t[0]),h.subtract(t[0],o,t[0]),h.subtract(t[0],r,t[0]),h.subtract(t[0],s,t[0]),h.clone(n,t[1]),h.subtract(t[1],o,t[1]),h.subtract(t[1],r,t[1]),h.add(t[1],s,t[1]),h.clone(n,t[2]),h.subtract(t[2],o,t[2]),h.add(t[2],r,t[2]),h.subtract(t[2],s,t[2]),h.clone(n,t[3]),h.subtract(t[3],o,t[3]),h.add(t[3],r,t[3]),h.add(t[3],s,t[3]),h.clone(n,t[4]),h.add(t[4],o,t[4]),h.subtract(t[4],r,t[4]),h.subtract(t[4],s,t[4]),h.clone(n,t[5]),h.add(t[5],o,t[5]),h.subtract(t[5],r,t[5]),h.add(t[5],s,t[5]),h.clone(n,t[6]),h.add(t[6],o,t[6]),h.add(t[6],r,t[6]),h.subtract(t[6],s,t[6]),h.clone(n,t[7]),h.add(t[7],o,t[7]),h.add(t[7],r,t[7]),h.add(t[7],s,t[7]),t};var KXe=new $;wi.computeTransformation=function(e,t){l(t)||(t=new M);let n=e.center,i=$.multiplyByUniformScale(e.halfAxes,2,KXe);return M.fromRotationTranslation(i,n,t)};var JXe=new ce;wi.isOccluded=function(e,t){let n=ce.fromOrientedBoundingBox(e,JXe);return!t.isBoundingSphereVisible(n)};wi.prototype.intersectPlane=function(e){return wi.intersectPlane(this,e)};wi.prototype.distanceSquaredTo=function(e){return wi.distanceSquaredTo(this,e)};wi.prototype.computePlaneDistances=function(e,t,n){return wi.computePlaneDistances(this,e,t,n)};wi.prototype.computeCorners=function(e){return wi.computeCorners(this,e)};wi.prototype.computeTransformation=function(e){return wi.computeTransformation(this,e)};wi.prototype.isOccluded=function(e){return wi.isOccluded(this,e)};wi.equals=function(e,t){return e===t||l(e)&&l(t)&&h.equals(e.center,t.center)&&$.equals(e.halfAxes,t.halfAxes)};wi.prototype.clone=function(e){return wi.clone(this,e)};wi.prototype.equals=function(e){return wi.equals(this,e)};var Zn=wi;var pzt=T(S(),1);var b5={};b5.getHeight=function(e,t,n){return(e-n)*t+n};var QXe=new he;b5.getPosition=function(e,t,n,i,o){let r=t.cartesianToCartographic(e,QXe);if(!l(r))return h.clone(e,o);let s=b5.getHeight(r.height,n,i);return h.fromRadians(r.longitude,r.latitude,s,t,o)};var pr=b5;var iQt=T(S(),1);var yzt=T(S(),1),GE=`in vec3 position3DHigh; in vec3 position3DLow; in float batchId; #ifdef EXTRUDED_GEOMETRY in vec3 extrudeDirection; uniform float u_globeMinimumAltitude; #endif // EXTRUDED_GEOMETRY #ifdef PER_INSTANCE_COLOR out vec4 v_color; #endif // PER_INSTANCE_COLOR #ifdef TEXTURE_COORDINATES #ifdef SPHERICAL out vec4 v_sphericalExtents; #else // SPHERICAL out vec2 v_inversePlaneExtents; out vec4 v_westPlane; out vec4 v_southPlane; #endif // SPHERICAL out vec3 v_uvMinAndSphericalLongitudeRotation; out vec3 v_uMaxAndInverseDistance; out vec3 v_vMaxAndInverseDistance; #endif // TEXTURE_COORDINATES void main() { vec4 position = czm_computePosition(); #ifdef EXTRUDED_GEOMETRY float delta = min(u_globeMinimumAltitude, czm_geometricToleranceOverMeter * length(position.xyz)); delta *= czm_sceneMode == czm_sceneMode3D ? 1.0 : 0.0; //extrudeDirection is zero for the top layer position = position + vec4(extrudeDirection * delta, 0.0); #endif #ifdef TEXTURE_COORDINATES #ifdef SPHERICAL v_sphericalExtents = czm_batchTable_sphericalExtents(batchId); v_uvMinAndSphericalLongitudeRotation.z = czm_batchTable_longitudeRotation(batchId); #else // SPHERICAL #ifdef COLUMBUS_VIEW_2D vec4 planes2D_high = czm_batchTable_planes2D_HIGH(batchId); vec4 planes2D_low = czm_batchTable_planes2D_LOW(batchId); // If the primitive is split across the IDL (planes2D_high.x > planes2D_high.w): // - If this vertex is on the east side of the IDL (position3DLow.y > 0.0, comparison with position3DHigh may produce artifacts) // - existing \"east\" is on the wrong side of the world, far away (planes2D_high/low.w) // - so set \"east\" as beyond the eastmost extent of the projection (idlSplitNewPlaneHiLow) vec2 idlSplitNewPlaneHiLow = vec2(EAST_MOST_X_HIGH - (WEST_MOST_X_HIGH - planes2D_high.w), EAST_MOST_X_LOW - (WEST_MOST_X_LOW - planes2D_low.w)); bool idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y > 0.0; planes2D_high.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.w); planes2D_low.w = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.w); // - else, if this vertex is on the west side of the IDL (position3DLow.y < 0.0) // - existing \"west\" is on the wrong side of the world, far away (planes2D_high/low.x) // - so set \"west\" as beyond the westmost extent of the projection (idlSplitNewPlaneHiLow) idlSplit = planes2D_high.x > planes2D_high.w && position3DLow.y < 0.0; idlSplitNewPlaneHiLow = vec2(WEST_MOST_X_HIGH - (EAST_MOST_X_HIGH - planes2D_high.x), WEST_MOST_X_LOW - (EAST_MOST_X_LOW - planes2D_low.x)); planes2D_high.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.x, planes2D_high.x); planes2D_low.x = czm_branchFreeTernary(idlSplit, idlSplitNewPlaneHiLow.y, planes2D_low.x); vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.xy), vec3(0.0, planes2D_low.xy))).xyz; vec3 northWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.x, planes2D_high.z), vec3(0.0, planes2D_low.x, planes2D_low.z))).xyz; vec3 southEastCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, planes2D_high.w, planes2D_high.y), vec3(0.0, planes2D_low.w, planes2D_low.y))).xyz; #else // COLUMBUS_VIEW_2D // 3D case has smaller \"plane extents,\" so planes encoded as a 64 bit position and 2 vec3s for distances/direction vec3 southWestCorner = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(czm_batchTable_southWest_HIGH(batchId), czm_batchTable_southWest_LOW(batchId))).xyz; vec3 northWestCorner = czm_normal * czm_batchTable_northward(batchId) + southWestCorner; vec3 southEastCorner = czm_normal * czm_batchTable_eastward(batchId) + southWestCorner; #endif // COLUMBUS_VIEW_2D vec3 eastWard = southEastCorner - southWestCorner; float eastExtent = length(eastWard); eastWard /= eastExtent; vec3 northWard = northWestCorner - southWestCorner; float northExtent = length(northWard); northWard /= northExtent; v_westPlane = vec4(eastWard, -dot(eastWard, southWestCorner)); v_southPlane = vec4(northWard, -dot(northWard, southWestCorner)); v_inversePlaneExtents = vec2(1.0 / eastExtent, 1.0 / northExtent); #endif // SPHERICAL vec4 uvMinAndExtents = czm_batchTable_uvMinAndExtents(batchId); vec4 uMaxVmax = czm_batchTable_uMaxVmax(batchId); v_uMaxAndInverseDistance = vec3(uMaxVmax.xy, uvMinAndExtents.z); v_vMaxAndInverseDistance = vec3(uMaxVmax.zw, uvMinAndExtents.w); v_uvMinAndSphericalLongitudeRotation.xy = uvMinAndExtents.xy; #endif // TEXTURE_COORDINATES #ifdef PER_INSTANCE_COLOR v_color = czm_batchTable_color(batchId); #endif gl_Position = czm_depthClamp(czm_modelViewProjectionRelativeToEye * position); } `;var xzt=T(S(),1),wb=`#ifdef VECTOR_TILE uniform vec4 u_highlightColor; #endif void main(void) { #ifdef VECTOR_TILE out_FragColor = czm_gammaCorrect(u_highlightColor); #else out_FragColor = vec4(1.0); #endif czm_writeDepthClamp(); } `;var Tzt=T(S(),1),vte={TERRAIN:0,CESIUM_3D_TILE:1,BOTH:2};vte.NUMBER_OF_CLASSIFICATION_TYPES=3;var Un=Object.freeze(vte);var Vzt=T(S(),1);var jXe={NEVER:ne.NEVER,LESS:ne.LESS,EQUAL:ne.EQUAL,LESS_OR_EQUAL:ne.LEQUAL,GREATER:ne.GREATER,NOT_EQUAL:ne.NOTEQUAL,GREATER_OR_EQUAL:ne.GEQUAL,ALWAYS:ne.ALWAYS},tc=Object.freeze(jXe);var $Kt=T(S(),1);var Zzt=T(S(),1);function qXe(e,t){let n=[],i=e.length,o=0;for(;o<i;){let r=Math.ceil((i-o)/t--);n.push(e.slice(o,o+r)),o+=r}return n}var EE=qXe;var kzt=T(S(),1);function Tp(e,t,n){if(this._attributes=t,this._numberOfInstances=n,t.length===0)return;let i=$Xe(t),o=e.floatingPointTexture,r=i===Qe.FLOAT&&!o,s=eIe(t,r),a=tIe(s,t,r),c=Math.floor(Yt.maximumTextureSize/a),d=Math.min(n,c),u=a*d,m=Math.ceil(n/d),p=1/u,b=p*.5,f=1/m,x=f*.5;this._textureDimensions=new D(u,m),this._textureStep=new se(p,b,f,x),this._pixelDatatype=r?Qe.UNSIGNED_BYTE:i,this._packFloats=r,this._offsets=s,this._stride=a,this._texture=void 0;let _=4*u*m;this._batchValues=i===Qe.FLOAT&&!r?new Float32Array(_):new Uint8Array(_),this._batchValuesDirty=!1}Object.defineProperties(Tp.prototype,{attributes:{get:function(){return this._attributes}},numberOfInstances:{get:function(){return this._numberOfInstances}}});function $Xe(e){let t=!1,n=e.length;for(let i=0;i<n;++i)if(e[i].componentDatatype!==Q.UNSIGNED_BYTE){t=!0;break}return t?Qe.FLOAT:Qe.UNSIGNED_BYTE}function Fte(e,t){let n=e[t].componentsPerAttribute;return n===2?D:n===3?h:n===4?se:Number}function eIe(e,t){let n=new Array(e.length),i=0,o=e.length;for(let r=0;r<o;++r){let a=e[r].componentDatatype;n[r]=i,a!==Q.UNSIGNED_BYTE&&t?i+=4:++i}return n}function tIe(e,t,n){let i=e.length,o=e[i-1];return t[i-1].componentDatatype!==Q.UNSIGNED_BYTE&&n?o+4:o+1}var XE=new se;function nIe(e,t,n){let i=se.unpack(e,t,XE),o=se.unpackFloat(i);i=se.unpack(e,t+4,XE);let r=se.unpackFloat(i);i=se.unpack(e,t+8,XE);let s=se.unpackFloat(i);i=se.unpack(e,t+12,XE);let a=se.unpackFloat(i);return se.fromElements(o,r,s,a,n)}function iIe(e,t,n){let i=se.packFloat(e.x,XE);se.pack(i,t,n),i=se.packFloat(e.y,i),se.pack(i,t,n+4),i=se.packFloat(e.z,i),se.pack(i,t,n+8),i=se.packFloat(e.w,i),se.pack(i,t,n+12)}var wte=new se;Tp.prototype.getBatchedAttribute=function(e,t,n){let i=this._attributes,o=this._offsets[t],s=4*this._stride*e+4*o,a;this._packFloats&&i[t].componentDatatype!==Qe.UNSIGNED_BYTE?a=nIe(this._batchValues,s,wte):a=se.unpack(this._batchValues,s,wte);let c=Fte(i,t);return l(c.fromCartesian4)?c.fromCartesian4(a,n):l(c.clone)?c.clone(a,n):a.x};var oIe=[void 0,void 0,new D,new h,new se],rIe=new se;Tp.prototype.setBatchedAttribute=function(e,t,n){let i=this._attributes,o=oIe[i[t].componentsPerAttribute],r=this.getBatchedAttribute(e,t,o),s=Fte(this._attributes,t);if(l(s.equals)?s.equals(r,n):r===n)return;let c=rIe;c.x=l(n.x)?n.x:n,c.y=l(n.y)?n.y:0,c.z=l(n.z)?n.z:0,c.w=l(n.w)?n.w:0;let d=this._offsets[t],m=4*this._stride*e+4*d;this._packFloats&&i[t].componentDatatype!==Qe.UNSIGNED_BYTE?iIe(c,this._batchValues,m):se.pack(c,this._batchValues,m),this._batchValuesDirty=!0};function sIe(e,t){let n=e._textureDimensions;e._texture=new Ft({context:t,pixelFormat:at.RGBA,pixelDatatype:e._pixelDatatype,width:n.x,height:n.y,sampler:mn.NEAREST,flipY:!1})}function aIe(e){let t=e._textureDimensions;e._texture.copyFrom({source:{width:t.x,height:t.y,arrayBufferView:e._batchValues}})}Tp.prototype.update=function(e){l(this._texture)&&!this._batchValuesDirty||this._attributes.length===0||(this._batchValuesDirty=!1,l(this._texture)||sIe(this,e.context),aIe(this))};Tp.prototype.getUniformMapCallback=function(){let e=this;return function(t){return e._attributes.length===0?t:Ct(t,{batchTexture:function(){return e._texture},batchTextureDimensions:function(){return e._textureDimensions},batchTextureStep:function(){return e._textureStep}})}};function cIe(e){let t=e._stride;return e._textureDimensions.y===1?`uniform vec4 batchTextureStep; vec2 computeSt(float batchId) { float stepX = batchTextureStep.x; float centerX = batchTextureStep.y; float numberOfAttributes = float(${t}); return vec2(centerX + (batchId * numberOfAttributes * stepX), 0.5); } `:`uniform vec4 batchTextureStep; uniform vec2 batchTextureDimensions;"
}