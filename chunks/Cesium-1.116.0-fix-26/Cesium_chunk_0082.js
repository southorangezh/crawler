{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 82,
    "total_chunks": 194,
    "chunk_size": 12394,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.695Z"
  },
  "content": "// Figure out if the reflection vector hits the ellipsoid float vertexRadius = length(positionWC); float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius); float reflectionDotNadir = dot(r, normalize(positionWC)); // Flipping the X vector is a cheap way to get the inverse of czm_temeToPseudoFixed, since that's a rotation about Z. r.x = -r.x; r = -normalize(czm_temeToPseudoFixed * r); r.x = -r.x; vec3 diffuseColor = pbrParameters.diffuseColor; float roughness = pbrParameters.roughness; vec3 specularColor = pbrParameters.f0; float inverseRoughness = 1.04 - roughness; inverseRoughness *= inverseRoughness; vec3 sceneSkyBox = czm_textureCube(czm_environmentMap, r).rgb * inverseRoughness; float atmosphereHeight = 0.05; float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir); float blendRegionOffset = roughness * -1.0; float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999); float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999); float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999); float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir); vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight); vec3 nadirColor = belowHorizonColor * 0.5; vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5); vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75); vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight); vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9); float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight; float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25)); vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0); float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8); vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough); specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness); specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness); // Luminance model from page 40 of http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf #ifdef USE_SUN_LUMINANCE // Angle between sun and zenith float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), vWC), 0.001, 1.0); float S = acos(LdotZenith); // Angle between zenith and current pixel float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), vWC), 0.001, 1.0); // Angle between sun and current pixel float gamma = acos(NdotL); float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith))); float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32)); float luminance = model_luminanceAtZenith * (numerator / denominator); #endif vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg; vec3 iblColor = (diffuseIrradiance * diffuseColor * model_iblFactor.x) + (specularIrradiance * czm_srgbToLinear(specularColor * brdfLut.x + brdfLut.y) * model_iblFactor.y); float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z); vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0); iblColor *= lightColor; #ifdef USE_SUN_LUMINANCE iblColor *= luminance; #endif return iblColor; } #if defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) vec3 textureIBL( vec3 positionEC, vec3 normalEC, vec3 lightDirectionEC, czm_pbrParameters pbrParameters ) { vec3 diffuseColor = pbrParameters.diffuseColor; float roughness = pbrParameters.roughness; vec3 specularColor = pbrParameters.f0; vec3 v = -positionEC; vec3 n = normalEC; vec3 l = normalize(lightDirectionEC); vec3 h = normalize(v + l); float NdotV = abs(dot(n, v)) + 0.001; float VdotH = clamp(dot(v, h), 0.0, 1.0); const mat3 yUpToZUp = mat3( -1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 ); vec3 cubeDir = normalize(yUpToZUp * model_iblReferenceFrameMatrix * normalize(reflect(-v, n))); #ifdef DIFFUSE_IBL #ifdef CUSTOM_SPHERICAL_HARMONICS vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, model_sphericalHarmonicCoefficients); #else vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); #endif #else vec3 diffuseIrradiance = vec3(0.0); #endif #ifdef SPECULAR_IBL vec3 r0 = specularColor.rgb; float reflectance = max(max(r0.r, r0.g), r0.b); vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0)); vec3 F = fresnelSchlick2(r0, r90, VdotH); vec2 brdfLut = texture(czm_brdfLut, vec2(NdotV, roughness)).rg; #ifdef CUSTOM_SPECULAR_IBL vec3 specularIBL = czm_sampleOctahedralProjection(model_specularEnvironmentMaps, model_specularEnvironmentMapsSize, cubeDir, roughness * model_specularEnvironmentMapsMaximumLOD, model_specularEnvironmentMapsMaximumLOD); #else vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir, roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD); #endif specularIBL *= F * brdfLut.x + brdfLut.y; #else vec3 specularIBL = vec3(0.0); #endif return diffuseColor * diffuseIrradiance + specularColor * specularIBL; } #endif vec3 imageBasedLightingStage( vec3 positionEC, vec3 normalEC, vec3 lightDirectionEC, vec3 lightColorHdr, czm_pbrParameters pbrParameters ) { #if defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) // Environment maps were provided, use them for IBL return textureIBL( positionEC, normalEC, lightDirectionEC, pbrParameters ); #else // Use the procedural IBL if there are no environment maps return proceduralIBL( positionEC, normalEC, lightDirectionEC, lightColorHdr, pbrParameters ); #endif }`;var Kre={name:\"ImageBasedLightingPipelineStage\"};Kre.process=function(e,t,n){let i=t.imageBasedLighting,o=e.shaderBuilder;o.addDefine(\"USE_IBL_LIGHTING\",void 0,Ce.FRAGMENT),o.addUniform(\"vec2\",\"model_iblFactor\",Ce.FRAGMENT),Xm.isSupported(n.context)&&((i.useSphericalHarmonics||i.useSpecularEnvironmentMaps||i.enabled)&&o.addUniform(\"mat3\",\"model_iblReferenceFrameMatrix\",Ce.FRAGMENT),l(i.sphericalHarmonicCoefficients)?(o.addDefine(\"DIFFUSE_IBL\",void 0,Ce.FRAGMENT),o.addDefine(\"CUSTOM_SPHERICAL_HARMONICS\",void 0,Ce.FRAGMENT),o.addUniform(\"vec3\",\"model_sphericalHarmonicCoefficients[9]\",Ce.FRAGMENT)):i.useDefaultSphericalHarmonics&&o.addDefine(\"DIFFUSE_IBL\",void 0,Ce.FRAGMENT),l(i.specularEnvironmentMapAtlas)&&i.specularEnvironmentMapAtlas.ready?(o.addDefine(\"SPECULAR_IBL\",void 0,Ce.FRAGMENT),o.addDefine(\"CUSTOM_SPECULAR_IBL\",void 0,Ce.FRAGMENT),o.addUniform(\"sampler2D\",\"model_specularEnvironmentMaps\",Ce.FRAGMENT),o.addUniform(\"vec2\",\"model_specularEnvironmentMapsSize\",Ce.FRAGMENT),o.addUniform(\"float\",\"model_specularEnvironmentMapsMaximumLOD\",Ce.FRAGMENT)):t.useDefaultSpecularMaps&&o.addDefine(\"SPECULAR_IBL\",void 0,Ce.FRAGMENT)),l(i.luminanceAtZenith)&&(o.addDefine(\"USE_SUN_LUMINANCE\",void 0,Ce.FRAGMENT),o.addUniform(\"float\",\"model_luminanceAtZenith\",Ce.FRAGMENT)),o.addFragmentLines(RI);let r={model_iblFactor:function(){return i.imageBasedLightingFactor},model_iblReferenceFrameMatrix:function(){return t._iblReferenceFrameMatrix},model_luminanceAtZenith:function(){return i.luminanceAtZenith},model_sphericalHarmonicCoefficients:function(){return i.sphericalHarmonicCoefficients},model_specularEnvironmentMaps:function(){return i.specularEnvironmentMapAtlas.texture},model_specularEnvironmentMapsSize:function(){return i.specularEnvironmentMapAtlas.texture.dimensions},model_specularEnvironmentMapsMaximumLOD:function(){return i.specularEnvironmentMapAtlas.maximumMipmapLevel}};e.uniformMap=Ct(r,e.uniformMap)};var GI=Kre;var P_n=T(S(),1);var R_n=T(S(),1);var iUe=P.EPSILON16;function Dz(e){e=g(e,g.EMPTY_OBJECT);let t=e.stage,n=e.runtimeArticulation;this._stage=t,this._runtimeArticulation=n,this._name=t.name,this._type=t.type,this._minimumValue=t.minimumValue,this._maximumValue=t.maximumValue,this._currentValue=t.initialValue}Object.defineProperties(Dz.prototype,{stage:{get:function(){return this._stage}},runtimeArticulation:{get:function(){return this._runtimeArticulation}},name:{get:function(){return this._name}},type:{get:function(){return this._type}},minimumValue:{get:function(){return this._minimumValue}},maximumValue:{get:function(){return this._maximumValue}},currentValue:{get:function(){return this._currentValue},set:function(e){e=P.clamp(e,this.minimumValue,this.maximumValue),P.equalsEpsilon(this._currentValue,e,iUe)||(this._currentValue=e,this.runtimeArticulation._dirty=!0)}}});var oUe=new h,Uz=new $;Dz.prototype.applyStageToMatrix=function(e){let t=this.type,n=this.currentValue,i=oUe,o;switch(t){case cc.XROTATE:o=$.fromRotationX(P.toRadians(n),Uz),e=M.multiplyByMatrix3(e,o,e);break;case cc.YROTATE:o=$.fromRotationY(P.toRadians(n),Uz),e=M.multiplyByMatrix3(e,o,e);break;case cc.ZROTATE:o=$.fromRotationZ(P.toRadians(n),Uz),e=M.multiplyByMatrix3(e,o,e);break;case cc.XTRANSLATE:i.x=n,i.y=0,i.z=0,e=M.multiplyByTranslation(e,i,e);break;case cc.YTRANSLATE:i.x=0,i.y=n,i.z=0,e=M.multiplyByTranslation(e,i,e);break;case cc.ZTRANSLATE:i.x=0,i.y=0,i.z=n,e=M.multiplyByTranslation(e,i,e);break;case cc.XSCALE:i.x=n,i.y=1,i.z=1,e=M.multiplyByScale(e,i,e);break;case cc.YSCALE:i.x=1,i.y=n,i.z=1,e=M.multiplyByScale(e,i,e);break;case cc.ZSCALE:i.x=1,i.y=1,i.z=n,e=M.multiplyByScale(e,i,e);break;case cc.UNIFORMSCALE:e=M.multiplyByUniformScale(e,n,e);break;default:break}return e};var EI=Dz;function mN(e){e=g(e,g.EMPTY_OBJECT);let t=e.articulation,n=e.sceneGraph;this._articulation=t,this._sceneGraph=n,this._name=t.name,this._runtimeStages=[],this._runtimeStagesByName={},this._runtimeNodes=[],this._dirty=!0,rUe(this)}Object.defineProperties(mN.prototype,{articulation:{get:function(){return this._articulation}},sceneGraph:{get:function(){return this._sceneGraph}},name:{get:function(){return this._name}},runtimeStages:{get:function(){return this._runtimeStages}},runtimeNodes:{get:function(){return this._runtimeNodes}}});function rUe(e){let n=e.articulation.stages,i=n.length,o=e._runtimeStages,r=e._runtimeStagesByName;for(let s=0;s<i;s++){let a=n[s],c=new EI({stage:a,runtimeArticulation:e});o.push(c);let d=a.name;r[d]=c}}mN.prototype.setArticulationStage=function(e,t){let n=this._runtimeStagesByName[e];l(n)&&(n.currentValue=t)};var sUe=new M,aUe=new M;mN.prototype.apply=function(){if(!this._dirty)return;this._dirty=!1;let e=M.clone(M.IDENTITY,sUe),t,n=this._runtimeStages,i=n.length;for(t=0;t<i;t++)e=n[t].applyStageToMatrix(e);let o=this._runtimeNodes,r=o.length;for(t=0;t<r;t++){let s=o[t],a=M.multiplyTransformation(s.originalTransform,e,aUe);s.transform=a}};var XI=mN;var D_n=T(S(),1);var w_n=T(S(),1),II=`void modelColorStage(inout czm_modelMaterial material) { material.diffuse = mix(material.diffuse, model_color.rgb, model_colorBlend); float highlight = ceil(model_colorBlend); material.diffuse *= mix(model_color.rgb, vec3(1.0), highlight); material.alpha *= model_color.a; } `;var FC={name:\"ModelColorPipelineStage\",COLOR_UNIFORM_NAME:\"model_color\",COLOR_BLEND_UNIFORM_NAME:\"model_colorBlend\"};FC.process=function(e,t,n){let i=e.shaderBuilder;i.addDefine(\"HAS_MODEL_COLOR\",void 0,Ce.FRAGMENT),i.addFragmentLines(II);let o={},r=t.color;r.alpha===0&&!t.hasSilhouette(n)&&(e.renderStateOptions.colorMask={red:!1,green:!1,blue:!1,alpha:!1}),r.alpha<1&&(e.alphaOptions.pass=Ze.TRANSLUCENT),i.addUniform(\"vec4\",FC.COLOR_UNIFORM_NAME,Ce.FRAGMENT),o[FC.COLOR_UNIFORM_NAME]=function(){return t.color},i.addUniform(\"float\",FC.COLOR_BLEND_UNIFORM_NAME,Ce.FRAGMENT),o[FC.COLOR_BLEND_UNIFORM_NAME]=function(){return ac.getColorBlend(t.colorBlendMode,t.colorBlendAmount)},e.uniformMap=Ct(o,e.uniformMap)};var uy=FC;var q_n=T(S(),1);var Y_n=T(S(),1),WI=`#ifdef USE_CLIPPING_PLANES_FLOAT_TEXTURE vec4 getClippingPlane( highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform ) { int pixY = clippingPlaneNumber / CLIPPING_PLANES_TEXTURE_WIDTH; int pixX"
}