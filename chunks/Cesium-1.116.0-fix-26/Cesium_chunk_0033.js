{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 33,
    "total_chunks": 194,
    "chunk_size": 5999,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.664Z"
  },
  "content": "roughnessSquared / (czm_pi * f * f); } /** * Compute the diffuse and specular contributions using physically based * rendering. This function only handles direct lighting. * <p> * This function only handles the lighting calculations. Metallic/roughness * and specular/glossy must be handled separately. See {@czm_pbrMetallicRoughnessMaterial}, {@czm_pbrSpecularGlossinessMaterial} and {@czm_defaultPbrMaterial} * </p> * * @name czm_pbrlighting * @glslFunction * * @param {vec3} positionEC The position of the fragment in eye coordinates * @param {vec3} normalEC The surface normal in eye coordinates * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates. * @param {vec3} lightColorHdr radiance of the light source. This is a HDR value. * @param {czm_pbrParameters} The computed PBR parameters. * @return {vec3} The computed HDR color * * @example * czm_pbrParameters pbrParameters = czm_pbrMetallicRoughnessMaterial( * baseColor, * metallic, * roughness * ); * vec3 color = czm_pbrlighting( * positionEC, * normalEC, * lightDirectionEC, * lightColorHdr, * pbrParameters); */ vec3 czm_pbrLighting( vec3 positionEC, vec3 normalEC, vec3 lightDirectionEC, vec3 lightColorHdr, czm_pbrParameters pbrParameters ) { vec3 v = -normalize(positionEC); vec3 l = normalize(lightDirectionEC); vec3 h = normalize(v + l); vec3 n = normalEC; float NdotL = clamp(dot(n, l), 0.001, 1.0); float NdotV = abs(dot(n, v)) + 0.001; float NdotH = clamp(dot(n, h), 0.0, 1.0); float LdotH = clamp(dot(l, h), 0.0, 1.0); float VdotH = clamp(dot(v, h), 0.0, 1.0); vec3 f0 = pbrParameters.f0; float reflectance = max(max(f0.r, f0.g), f0.b); vec3 f90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0)); vec3 F = fresnelSchlick2(f0, f90, VdotH); float alpha = pbrParameters.roughness; float G = smithVisibilityGGX(alpha, NdotL, NdotV); float D = GGX(alpha, NdotH); vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV); vec3 diffuseColor = pbrParameters.diffuseColor; // F here represents the specular contribution vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor); // Lo = (diffuse + specular) * Li * NdotL return (diffuseContribution + specularContribution) * NdotL * lightColorHdr; } `;var Mvt=T(S(),1),$R=`/** * Compute parameters for physically based rendering using the * metallic/roughness workflow. All inputs are linear; sRGB texture values must * be decoded beforehand * * @name czm_pbrMetallicRoughnessMaterial * @glslFunction * * @param {vec3} baseColor For dielectrics, this is the base color. For metals, this is the f0 value (reflectance at normal incidence) * @param {float} metallic 0.0 indicates dielectric. 1.0 indicates metal. Values in between are allowed (e.g. to model rust or dirt); * @param {float} roughness A value between 0.0 and 1.0 * @return {czm_pbrParameters} parameters to pass into {@link czm_pbrLighting} */ czm_pbrParameters czm_pbrMetallicRoughnessMaterial( vec3 baseColor, float metallic, float roughness ) { czm_pbrParameters results; // roughness is authored as perceptual roughness // square it to get material roughness roughness = clamp(roughness, 0.0, 1.0); results.roughness = roughness * roughness; // dielectrics use f0 = 0.04, metals use albedo as f0 metallic = clamp(metallic, 0.0, 1.0); const vec3 REFLECTANCE_DIELECTRIC = vec3(0.04); vec3 f0 = mix(REFLECTANCE_DIELECTRIC, baseColor, metallic); results.f0 = f0; // diffuse only applies to dielectrics. results.diffuseColor = baseColor * (1.0 - f0) * (1.0 - metallic); return results; } `;var kvt=T(S(),1),eG=`/** * Compute parameters for physically based rendering using the * specular/glossy workflow. All inputs are linear; sRGB texture values must * be decoded beforehand * * @name czm_pbrSpecularGlossinessMaterial * @glslFunction * * @param {vec3} diffuse The diffuse color for dielectrics (non-metals) * @param {vec3} specular The reflectance at normal incidence (f0) * @param {float} glossiness A number from 0.0 to 1.0 indicating how smooth the surface is. * @return {czm_pbrParameters} parameters to pass into {@link czm_pbrLighting} */ czm_pbrParameters czm_pbrSpecularGlossinessMaterial( vec3 diffuse, vec3 specular, float glossiness ) { czm_pbrParameters results; // glossiness is the opposite of roughness, but easier for artists to use. float roughness = 1.0 - glossiness; results.roughness = roughness * roughness; results.diffuseColor = diffuse * (1.0 - max(max(specular.r, specular.g), specular.b)); results.f0 = specular; return results; } `;var Dvt=T(S(),1),tG=`float czm_private_getLambertDiffuseOfMaterial(vec3 lightDirectionEC, czm_material material) { return czm_getLambertDiffuse(lightDirectionEC, material.normal); } float czm_private_getSpecularOfMaterial(vec3 lightDirectionEC, vec3 toEyeEC, czm_material material) { return czm_getSpecular(lightDirectionEC, toEyeEC, material.normal, material.shininess); } /** * Computes a color using the Phong lighting model. * * @name czm_phong * @glslFunction * * @param {vec3} toEye A normalized vector from the fragment to the eye in eye coordinates. * @param {czm_material} material The fragment's material. * * @returns {vec4} The computed color. * * @example * vec3 positionToEyeEC = // ... * czm_material material = // ... * vec3 lightDirectionEC = // ... * out_FragColor = czm_phong(normalize(positionToEyeEC), material, lightDirectionEC); * * @see czm_getMaterial */ vec4 czm_phong(vec3 toEye, czm_material material, vec3 lightDirectionEC) { // Diffuse from directional light sources at eye (for top-down) float diffuse = czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 0.0, 1.0), material); if (czm_sceneMode == czm_sceneMode3D) { // (and horizon views in 3D) diffuse += czm_private_getLambertDiffuseOfMaterial(vec3(0.0, 1.0, 0.0), material); } float specular = czm_private_getSpecularOfMaterial(lightDirectionEC, toEye, material); // Temporary workaround for adding ambient. vec3 materialDiffuse = material.diffuse * 0.5; vec3 ambient = materialDiffuse; vec3 color = ambient + material.emission;"
}