{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 84,
    "total_chunks": 194,
    "chunk_size": 19998,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.696Z"
  },
  "content": "a_instancingTransformRow2.w, 1.0 // Column 4 ); #else vec3 translation = vec3(0.0, 0.0, 0.0); vec3 scale = vec3(1.0, 1.0, 1.0); #ifdef HAS_INSTANCE_TRANSLATION translation = a_instanceTranslation; #endif #ifdef HAS_INSTANCE_SCALE scale = a_instanceScale; #endif instancingTransform = mat4( scale.x, 0.0, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, 0.0, scale.z, 0.0, translation.x, translation.y, translation.z, 1.0 ); #endif return instancingTransform; } #ifdef USE_2D_INSTANCING mat4 getInstancingTransform2D() { mat4 instancingTransform2D; #ifdef HAS_INSTANCE_MATRICES instancingTransform2D = mat4( a_instancingTransform2DRow0.x, a_instancingTransform2DRow1.x, a_instancingTransform2DRow2.x, 0.0, // Column 1 a_instancingTransform2DRow0.y, a_instancingTransform2DRow1.y, a_instancingTransform2DRow2.y, 0.0, // Column 2 a_instancingTransform2DRow0.z, a_instancingTransform2DRow1.z, a_instancingTransform2DRow2.z, 0.0, // Column 3 a_instancingTransform2DRow0.w, a_instancingTransform2DRow1.w, a_instancingTransform2DRow2.w, 1.0 // Column 4 ); #else vec3 translation2D = vec3(0.0, 0.0, 0.0); vec3 scale = vec3(1.0, 1.0, 1.0); #ifdef HAS_INSTANCE_TRANSLATION translation2D = a_instanceTranslation2D; #endif #ifdef HAS_INSTANCE_SCALE scale = a_instanceScale; #endif instancingTransform2D = mat4( scale.x, 0.0, 0.0, 0.0, 0.0, scale.y, 0.0, 0.0, 0.0, 0.0, scale.z, 0.0, translation2D.x, translation2D.y, translation2D.z, 1.0 ); #endif return instancingTransform2D; } #endif `;var rTn=T(S(),1),FI=`void instancingStage(inout ProcessedAttributes attributes) { vec3 positionMC = attributes.positionMC; mat4 instancingTransform = getInstancingTransform(); attributes.positionMC = (instancingTransform * vec4(positionMC, 1.0)).xyz; #ifdef HAS_NORMALS vec3 normalMC = attributes.normalMC; attributes.normalMC = (instancingTransform * vec4(normalMC, 0.0)).xyz; #endif #ifdef USE_2D_INSTANCING mat4 instancingTransform2D = getInstancingTransform2D(); attributes.position2D = (instancingTransform2D * vec4(positionMC, 1.0)).xyz; #endif } `;var aTn=T(S(),1),AI=`void legacyInstancingStage( inout ProcessedAttributes attributes, out mat4 instanceModelView, out mat3 instanceModelViewInverseTranspose) { vec3 positionMC = attributes.positionMC; mat4 instancingTransform = getInstancingTransform(); mat4 instanceModel = instancingTransform * u_instance_nodeTransform; instanceModelView = u_instance_modifiedModelView; instanceModelViewInverseTranspose = mat3(u_instance_modifiedModelView * instanceModel); attributes.positionMC = (instanceModel * vec4(positionMC, 1.0)).xyz; #ifdef USE_2D_INSTANCING mat4 instancingTransform2D = getInstancingTransform2D(); attributes.position2D = (instancingTransform2D * vec4(positionMC, 1.0)).xyz; #endif } `;var hN=new M,lUe=new M,dUe=new M,qre={name:\"InstancingPipelineStage\",_getInstanceTransformsAsMatrices:ise,_transformsToTypedArray:Yz};qre.process=function(e,t,n){let i=t.instances,o=i.attributes[0].count,r=e.shaderBuilder;r.addDefine(\"HAS_INSTANCING\"),r.addVertexLines(wI);let s=e.model,a=s.sceneGraph,c=e.runtimeNode,d=n.mode!==ie.SCENE3D&&!n.scene3DOnly&&s._projectTo2D,u=s._enablePick&&!n.context.webgl2,m=[];LUe(e,n,i,m,d,u),GUe(e,n,i,m);let p={};if(i.transformInWorldSpace?(r.addDefine(\"USE_LEGACY_INSTANCING\",void 0,Ce.VERTEX),r.addUniform(\"mat4\",\"u_instance_modifiedModelView\",Ce.VERTEX),r.addUniform(\"mat4\",\"u_instance_nodeTransform\",Ce.VERTEX),p.u_instance_modifiedModelView=function(){let b=M.multiplyTransformation(s.modelMatrix,a.components.transform,hN);return d?M.multiplyTransformation(n.context.uniformState.view3D,b,hN):(n.mode!==ie.SCENE3D&&(b=Wt.basisTo2D(n.mapProjection,b,hN)),M.multiplyTransformation(n.context.uniformState.view,b,hN))},p.u_instance_nodeTransform=function(){return M.multiplyTransformation(a.axisCorrectionMatrix,c.computedTransform,lUe)},r.addVertexLines(AI)):r.addVertexLines(FI),d){r.addDefine(\"USE_2D_INSTANCING\",void 0,Ce.VERTEX),r.addUniform(\"mat4\",\"u_modelView2D\",Ce.VERTEX);let b=n.context,f=M.fromTranslation(c.instancingReferencePoint2D,new M);p.u_modelView2D=function(){return M.multiplyTransformation(b.uniformState.view,f,dUe)}}e.uniformMap=Ct(p,e.uniformMap),e.instanceCount=o,e.attributes.push.apply(e.attributes,m)};var MI=new M,uUe=new h;function mUe(e,t,n,i,o){let r=M.multiplyTransformation(t,e,MI);return r=M.multiplyTransformation(r,n,MI),o=Wt.basisTo2D(i.mapProjection,r,o),o}function hUe(e,t,n,i,o){let r=M.fromTranslation(e,MI),s=M.multiplyTransformation(t,r,MI);s=M.multiplyTransformation(s,n,MI);let a=M.getTranslation(s,uUe);return o=Zi.computeActualWgs84Position(i,a,o),o}function $re(e,t,n){let i=e.model,o=i.sceneGraph;e.runtimeNode.node.instances.transformInWorldSpace?(t=M.multiplyTransformation(i.modelMatrix,o.components.transform,t),n=M.multiplyTransformation(o.axisCorrectionMatrix,e.runtimeNode.computedTransform,n)):(t=M.clone(o.computedModelMatrix,t),t=M.multiplyTransformation(t,e.runtimeNode.computedTransform,t),n=M.clone(M.IDENTITY,n))}var ese=new M,tse=new M,fUe=new M,pUe=new h;function bUe(e,t,n,i){let o=ese,r=tse;$re(t,o,r);let a=t.runtimeNode.instancingReferencePoint2D,c=e.length;for(let d=0;d<c;d++){let u=e[d],m=mUe(u,o,r,n,fUe),p=M.getTranslation(m,pUe),b=h.subtract(p,a,p);i[d]=M.setTranslation(m,b,i[d])}return i}function yUe(e,t,n,i){let o=ese,r=tse;$re(t,o,r);let a=t.runtimeNode.instancingReferencePoint2D,c=e.length;for(let d=0;d<c;d++){let u=e[d],m=hUe(u,o,r,n,u);i[d]=h.subtract(m,a,i[d])}return i}var gUe=new h,xUe=new h;function nse(e,t){let n=e.runtimeNode,i=e.model.sceneGraph.computedModelMatrix,o=M.multiplyByPoint(i,n.instancingTranslationMin,gUe),r=Zi.computeActualWgs84Position(t,o,o),s=M.multiplyByPoint(i,n.instancingTranslationMax,xUe),a=Zi.computeActualWgs84Position(t,s,s);n.instancingReferencePoint2D=h.lerp(r,a,.5,new h)}function Yz(e){let n=e.length,i=new Float32Array(n*12);for(let o=0;o<n;o++){let r=e[o],s=12*o;i[s+0]=r[0],i[s+1]=r[4],i[s+2]=r[8],i[s+3]=r[12],i[s+4]=r[1],i[s+5]=r[5],i[s+6]=r[9],i[s+7]=r[13],i[s+8]=r[2],i[s+9]=r[6],i[s+10]=r[10],i[s+11]=r[14]}return i}function _Ue(e){let n=e.length,i=new Float32Array(n*3);for(let o=0;o<n;o++){let r=e[o],s=3*o;i[s+0]=r[0],i[s+1]=r[4],i[s+2]=r[8]}return i}var TUe=new h,SUe=new Fe,CUe=new h;function ise(e,t,n){let i=new Array(t),o=qt.getAttributeBySemantic(e,zr.TRANSLATION),r=qt.getAttributeBySemantic(e,zr.ROTATION),s=qt.getAttributeBySemantic(e,zr.SCALE),a=new h(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),c=new h(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),d=l(o),u=l(r),m=l(s),p=d?o.typedArray:new Float32Array(t*3),b=u?r.typedArray:new Float32Array(t*4);u&&r.normalized&&(b=wn.dequantize(b,r.componentDatatype,r.type,t));let f;m?f=s.typedArray:(f=new Float32Array(t*3),f.fill(1));for(let _=0;_<t;_++){let C=new h(p[_*3],p[_*3+1],p[_*3+2],TUe);h.maximumByComponent(a,C,a),h.minimumByComponent(c,C,c);let V=new Fe(b[_*4],b[_*4+1],b[_*4+2],u?b[_*4+3]:1,SUe),L=new h(f[_*3],f[_*3+1],f[_*3+2],CUe),R=M.fromTranslationQuaternionRotationScale(C,V,L,new M);i[_]=R}let x=n.runtimeNode;return x.instancingTranslationMin=c,x.instancingTranslationMax=a,d&&(o.typedArray=void 0),u&&(r.typedArray=void 0),m&&(s.typedArray=void 0),i}function VUe(e,t,n){let i=new Array(t),o=e.typedArray,r=new h(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),s=new h(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let c=0;c<t;c++){let d=new h(o[c*3],o[c*3+1],o[c*3+2]);i[c]=d,h.minimumByComponent(r,d,r),h.maximumByComponent(s,d,s)}let a=n.runtimeNode;return a.instancingTranslationMin=r,a.instancingTranslationMax=s,e.typedArray=void 0,i}function Oz(e,t){let n=pt.createVertexBuffer({context:t.context,typedArray:e,usage:Me.STATIC_DRAW});return n.vertexArrayDestroyable=!1,n}function LUe(e,t,n,i,o,r){let s=qt.getAttributeBySemantic(n,zr.ROTATION);l(s)?ZUe(e,n,i,t,o,r):RUe(e,n,i,t,o)}function ZUe(e,t,n,i,o,r){let s=e.shaderBuilder,a=t.attributes[0].count,c=e.model,d=e.runtimeNode;s.addDefine(\"HAS_INSTANCE_MATRICES\");let u=\"Transform\",m,p=d.instancingTransformsBuffer;if(!l(p)){m=ise(t,a,e);let _=Yz(m);p=Oz(_,i),c._modelResources.push(p),r&&(d.transformsTypedArray=_),d.instancingTransformsBuffer=p}if(jre(e,p,n,u),!o)return;let b=Oe(i);b.mode=ie.COLUMBUS_VIEW,nse(e,b);let f=d.instancingTransformsBuffer2D;if(!l(f)){let _=bUe(m,e,b,m),C=Yz(_);f=Oz(C,i),c._modelResources.push(f),d.instancingTransformsBuffer2D=f}jre(e,f,n,\"Transform2D\")}function RUe(e,t,n,i,o,r){let s=e.shaderBuilder,a=e.runtimeNode,c=qt.getAttributeBySemantic(t,zr.TRANSLATION),d=qt.getAttributeBySemantic(t,zr.SCALE);if(l(d)&&(s.addDefine(\"HAS_INSTANCE_SCALE\"),Bz(e,d.buffer,d.byteOffset,d.byteStride,n,\"Scale\")),!l(c))return;let u,m=c.typedArray;if(l(m)?u=VUe(c,c.count,e):l(a.instancingTranslationMin)||(a.instancingTranslationMin=c.min,a.instancingTranslationMax=c.max),s.addDefine(\"HAS_INSTANCE_TRANSLATION\"),Bz(e,c.buffer,c.byteOffset,c.byteStride,n,\"Translation\"),!o&&!r)return;let b=Oe(i);b.mode=ie.COLUMBUS_VIEW,nse(e,b);let f=a.instancingTranslationBuffer2D;if(!l(f)){let V=yUe(u,e,b,u),L=_Ue(V);r&&(a.transformsTypedArray=L),f=Oz(L,i),e.model._modelResources.push(f),a.instancingTranslationBuffer2D=f}if(!o)return;Bz(e,f,0,void 0,n,\"Translation2D\")}function jre(e,t,n,i){let r=Q.getSizeInBytes(Q.FLOAT),s=r*12,a=[{index:e.attributeIndex++,vertexBuffer:t,componentsPerAttribute:4,componentDatatype:Q.FLOAT,normalize:!1,offsetInBytes:0,strideInBytes:s,instanceDivisor:1},{index:e.attributeIndex++,vertexBuffer:t,componentsPerAttribute:4,componentDatatype:Q.FLOAT,normalize:!1,offsetInBytes:r*4,strideInBytes:s,instanceDivisor:1},{index:e.attributeIndex++,vertexBuffer:t,componentsPerAttribute:4,componentDatatype:Q.FLOAT,normalize:!1,offsetInBytes:r*8,strideInBytes:s,instanceDivisor:1}],c=e.shaderBuilder;c.addAttribute(\"vec4\",`a_instancing${i}Row0`),c.addAttribute(\"vec4\",`a_instancing${i}Row1`),c.addAttribute(\"vec4\",`a_instancing${i}Row2`),n.push.apply(n,a)}function Bz(e,t,n,i,o,r){o.push({index:e.attributeIndex++,vertexBuffer:t,componentsPerAttribute:3,componentDatatype:Q.FLOAT,normalize:!1,offsetInBytes:n,strideInBytes:i,instanceDivisor:1}),e.shaderBuilder.addAttribute(\"vec3\",`a_instance${r}`)}function GUe(e,t,n,i){let o=n.attributes,r=e.shaderBuilder;for(let s=0;s<o.length;s++){let a=o[s];a.semantic===zr.FEATURE_ID&&(a.setIndex>=e.featureIdVertexAttributeSetIndex&&(e.featureIdVertexAttributeSetIndex=a.setIndex+1),i.push({index:e.attributeIndex++,vertexBuffer:a.buffer,componentsPerAttribute:tn.getNumberOfComponents(a.type),componentDatatype:a.componentDatatype,normalize:!1,offsetInBytes:a.byteOffset,strideInBytes:a.byteStride,instanceDivisor:1}),r.addAttribute(\"float\",`a_instanceFeatureId_${a.setIndex}`))}}var NI=qre;var vTn=T(S(),1);var zz={};zz.name=\"ModelMatrixUpdateStage\";zz.update=function(e,t,n){let i=n.mode!==ie.SCENE3D;if(!(i&&t._model._projectTo2D)&&e._transformDirty){let o=i?t._computedModelMatrix2D:t._computedModelMatrix;ose(e,t,o,e.transformToRoot),e._transformDirty=!1}};function ose(e,t,n,i){let o;i=M.multiplyTransformation(i,e.transform,new M),e.updateComputedTransform();let r=e.runtimePrimitives.length;for(o=0;o<r;o++){let c=e.runtimePrimitives[o].drawCommand;c.modelMatrix=M.multiplyTransformation(n,i,c.modelMatrix),c.cullFace=qt.getCullFace(c.modelMatrix,c.primitiveType)}let s=e.children.length;for(o=0;o<s;o++){let a=t._runtimeNodes[e.children[o]];a._transformToRoot=M.clone(i,a._transformToRoot),ose(a,t,n,i),a._transformDirty=!1}}var kI=zz;var ATn=T(S(),1);var rse={name:\"NodeStatisticsPipelineStage\",_countInstancingAttributes:sse,_countGeneratedBuffers:ase};rse.process=function(e,t,n){let i=e.model.statistics,o=t.instances,r=e.runtimeNode;sse(i,o),ase(i,r)};function sse(e,t){if(!l(t))return;let n=t.attributes,i=n.length;for(let o=0;o<i;o++){let r=n[o];l(r.buffer)&&e.addBuffer(r.buffer,!1)}}function ase(e,t){l(t.instancingTransformsBuffer)&&e.addBuffer(t.instancingTransformsBuffer,!1),l(t.instancingTransformsBuffer2D)&&e.addBuffer(t.instancingTransformsBuffer2D,!1),l(t.instancingTranslationBuffer2D)&&e.addBuffer(t.instancingTranslationBuffer2D,!1)}var UI=rse;function AC(e){e=g(e,g.EMPTY_OBJECT);let t=e.node,n=e.transform,i=e.transformToRoot,o=e.sceneGraph,r=e.children;this._node=t,this._name=t.name,this._id=t.index,this._sceneGraph=o,this._children=r,this._originalTransform=M.clone(n,this._originalTransform),this._transform=M.clone(n,this._transform),this._transformToRoot=M.clone(i,this._transformToRoot),this._computedTransform=new M,this._transformDirty=!1,this._transformParameters=void 0,this._morphWeights=[],this._runtimeSkin=void 0,this._computedJointMatrices=[],this.show=!0,this.userAnimated=!1,this.pipelineStages=[],this.runtimePrimitives=[],this.updateStages=[],this.instancingTranslationMin=void 0,this.instancingTranslationMax=void 0,this.instancingTransformsBuffer=void 0,this.instancingTransformsBuffer2D=void 0,this.instancingTranslationBuffer2D=void 0,this.instancingReferencePoint2D=void 0,EUe(this)}Object.defineProperties(AC.prototype,{node:{get:function(){return this._node}},sceneGraph:{get:function(){return this._sceneGraph}},children:{get:function(){return this._children}},transform:{get:function(){return this._transform},set:function(e){this._transformDirty=!0,this._transform=M.clone(e,this._transform)}},transformToRoot:{get:function(){return this._transformToRoot}},computedTransform:{get:function(){return this._computedTransform}},originalTransform:{get:function(){return this._originalTransform}},translation:{get:function(){return l(this._transformParameters)?this._transformParameters.translation:void 0},set:function(e){let t=this._transformParameters,n=t.translation;h.equals(n,e)||(t.translation=h.clone(e,t.translation),Hz(this,t))}},rotation:{get:function(){return l(this._transformParameters)?this._transformParameters.rotation:void 0},set:function(e){let t=this._transformParameters,n=t.rotation;Fe.equals(n,e)||(t.rotation=Fe.clone(e,t.rotation),Hz(this,t))}},scale:{get:function(){return l(this._transformParameters)?this._transformParameters.scale:void 0},set:function(e){let t=this._transformParameters,n=t.scale;h.equals(n,e)||(t.scale=h.clone(e,t.scale),Hz(this,t))}},morphWeights:{get:function(){return this._morphWeights},set:function(e){let t=e.length;for(let n=0;n<t;n++)this._morphWeights[n]=e[n]}},runtimeSkin:{get:function(){return this._runtimeSkin}},computedJointMatrices:{get:function(){return this._computedJointMatrices}}});function EUe(e){let t=e.transform,n=e.transformToRoot,i=e._computedTransform;e._computedTransform=M.multiply(n,t,i);let o=e.node;l(o.matrix)||(e._transformParameters=new kb(o.translation,o.rotation,o.scale)),l(o.morphWeights)&&(e._morphWeights=o.morphWeights.slice());let r=o.articulationName;if(l(r)){let c=e.sceneGraph._runtimeArticulations[r];l(c)&&c.runtimeNodes.push(e)}}function Hz(e,t){e._transformDirty=!0,e._transform=M.fromTranslationRotationScale(t,e._transform)}AC.prototype.getChild=function(e){return this.sceneGraph._runtimeNodes[this.children[e]]};AC.prototype.configurePipeline=function(){let e=this.node,t=this.pipelineStages;t.length=0;let n=this.updateStages;n.length=0,l(e.instances)&&t.push(NI),t.push(UI),n.push(kI)};AC.prototype.updateComputedTransform=function(){this._computedTransform=M.multiply(this._transformToRoot,this._transform,this._computedTransform)};AC.prototype.updateJointMatrices=function(){let e=this._runtimeSkin;if(!l(e))return;e.updateJointMatrices();let t=this._computedJointMatrices,n=e.jointMatrices,i=n.length;for(let o=0;o<i;o++){l(t[o])||(t[o]=new M);let r=M.multiplyTransformation(this.transformToRoot,this.transform,t[o]),s=M.inverseTransformation(r,t[o]);t[o]=M.multiplyTransformation(s,n[o],t[o])}};var DI=AC;var sZn=T(S(),1);var tSn=T(S(),1);var cse={name:\"AlphaPipelineStage\"};cse.process=function(e,t,n){let i=e.alphaOptions,o=e.model;i.pass=g(i.pass,o.opaquePass);let r=e.renderStateOptions;i.pass===Ze.TRANSLUCENT&&(r.cull.enabled=!1,r.depthMask=!1,r.blending=un.ALPHA_BLEND);let s=e.shaderBuilder,a=e.uniformMap;l(i.alphaCutoff)&&(s.addDefine(\"ALPHA_MODE_MASK\",void 0,Ce.FRAGMENT),s.addUniform(\"float\",\"u_alphaCutoff\",Ce.FRAGMENT),a.u_alphaCutoff=function(){return i.alphaCutoff})};var BI=cse;var rSn=T(S(),1);var lse={name:\"BatchTexturePipelineStage\"};lse.process=function(e,t,n){let i=e.shaderBuilder,o={},r=e.model,s=r.featureTables[r.featureTableId],a=s.featuresLength;i.addUniform(\"int\",\"model_featuresLength\"),o.model_featuresLength=function(){return a};let c=s.batchTexture;i.addUniform(\"sampler2D\",\"model_batchTexture\"),o.model_batchTexture=function(){return g(c.batchTexture,c.defaultTexture)},i.addUniform(\"vec4\",\"model_textureStep\"),o.model_textureStep=function(){return c.textureStep},c.textureDimensions.y>1&&(i.addDefine(\"MULTILINE_BATCH_TEXTURE\"),i.addUniform(\"vec2\",\"model_textureDimensions\"),o.model_textureDimensions=function(){return c.textureDimensions}),e.uniformMap=Ct(o,e.uniformMap)};var YI=lse;var mSn=T(S(),1);var dse={name:\"ClassificationPipelineStage\"};dse.process=function(e,t,n){e.shaderBuilder.addDefine(\"HAS_CLASSIFICATION\",void 0,Ce.BOTH);let o=e.runtimePrimitive;l(o.batchLengths)||XUe(t,o)};function XUe(e,t){let n=qt.getAttributeBySemantic(e,St.POSITION);if(!l(n))throw new ue(\"Primitives must have a position attribute to be used for classification.\");let i,o=e.indices,r=l(o);r&&(i=o.typedArray,o.typedArray=void 0);let s=r?o.count:n.count,a=qt.getAttributeBySemantic(e,St.FEATURE_ID,0);if(!l(a)){t.batchLengths=[s],t.batchOffsets=[0];return}let c=a.typedArray;a.typedArray=void 0;let d=[],u=[0],m=r?i[0]:0,p=c[m],b=0;for(let x=1;x<s;x++){let _=r?i[x]:x,C=c[_];if(C!==p){let V=x-b,L=x;d.push(V),u.push(L),b=L,p=C}}let f=s-b;d.push(f),t.batchLengths=d,t.batchOffsets=u}var OI=dse;var LSn=T(S(),1);var fSn=T(S(),1),zI=`void filterByPassType(inout vec3 positionMC, vec4 featureColor) { bool styleTranslucent = (featureColor.a != 1.0); // Only render translucent features in the translucent pass (if the style or the original command has translucency). if (czm_pass == czm_passTranslucent && !styleTranslucent && !model_commandTranslucent) { // If the model has a translucent silhouette, it needs to render during the silhouette color command, // (i.e. the command where model_silhouettePass = true), even if the model isn't translucent. #ifdef HAS_SILHOUETTE positionMC *= float(model_silhouettePass); #else positionMC *= 0.0; #endif } // If the current pass is not the translucent pass and the style is not translucent, don't render the feature. else if (czm_pass != czm_passTranslucent && styleTranslucent) { positionMC *= 0.0; } } void cpuStylingStage(inout vec3 positionMC, inout SelectedFeature feature) { float show = ceil(feature.color.a); positionMC *= show; #if defined(HAS_SELECTED_FEATURE_ID_ATTRIBUTE) && !defined(HAS_CLASSIFICATION) filterByPassType(positionMC, feature.color); #endif } `;var bSn=T(S(),1),HI=`void filterByPassType(vec4 featureColor) { bool styleTranslucent = (featureColor.a != 1.0); // Only render translucent features in the translucent pass (if the style or the original command has translucency). if (czm_pass == czm_passTranslucent && !styleTranslucent && !model_commandTranslucent) { // If the model has a translucent silhouette, it needs to render during the silhouette color command, // (i.e. the command where model_silhouettePass = true), even if the model isn't translucent. #ifdef HAS_SILHOUETTE if(!model_silhouettePass) { discard; } #else discard; #endif } // If the current pass is not the translucent pass and the style is not translucent, don't render the feature. else if (czm_pass != czm_passTranslucent && styleTranslucent) { discard; } } void cpuStylingStage(inout czm_modelMaterial material, SelectedFeature feature) { vec4 featureColor = feature.color; if (featureColor.a == 0.0) { discard; } // If a feature ID vertex attribute is used, the pass type filter is applied in the vertex shader. // So, we only apply in in the fragment shader if the feature ID texture is used. #if defined(HAS_SELECTED_FEATURE_ID_TEXTURE) && !defined(HAS_CLASSIFICATION) filterByPassType(featureColor); #endif featureColor"
}