{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 139,
    "total_chunks": 194,
    "chunk_size": 18863,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.734Z"
  },
  "content": "vec4 shadowMap_lightPositionEC; uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; #ifdef LOG_DEPTH in vec3 v_logPositionEC; #endif vec4 getPositionEC() { ${G}} vec3 getNormalEC() { ${s?` return normalize(${r}); `:` return vec3(1.0); `}} void applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) { ${_.normalOffset&&s?` float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; float normalOffsetScale = 1.0 - nDotL; vec3 offset = normalOffset * normalOffsetScale * normalEC; positionEC.xyz += offset; `:\"\"}} `,R+=`void main() { czm_shadow_receive_main(); vec4 positionEC = getPositionEC(); vec3 normalEC = getNormalEC(); float depth = -positionEC.z; `,R+=` czm_shadowParameters shadowParameters; shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; `,i?R+=` shadowParameters.depthBias *= max(depth * 0.01, 1.0); `:u||(R+=` shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); `),m?R+=` vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; float distance = length(directionEC); directionEC = normalize(directionEC); float radius = shadowMap_lightPositionEC.w; // Stop early if the fragment is beyond the point light radius if (distance > radius) { return; } vec3 directionWC = czm_inverseViewRotation * directionEC; shadowParameters.depth = distance / radius; shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); shadowParameters.texCoords = directionWC; float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); `:p?R+=` vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); applyNormalOffset(positionEC, normalEC, nDotL); vec4 shadowPosition = shadowMap_matrix * positionEC; // Spot light uses a perspective projection, so perform the perspective divide shadowPosition /= shadowPosition.w; // Stop early if the fragment is not in the shadow bounds if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) { return; } shadowParameters.texCoords = shadowPosition.xy; shadowParameters.depth = shadowPosition.z; shadowParameters.nDotL = nDotL; float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); `:b?R+=` float maxDepth = shadowMap_cascadeSplits[1].w; // Stop early if the eye depth exceeds the last cascade if (depth > maxDepth) { return; } // Get the cascade based on the eye-space depth vec4 weights = czm_cascadeWeights(depth); // Apply normal offset float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); applyNormalOffset(positionEC, normalEC, nDotL); // Transform position into the cascade vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; // Get visibility shadowParameters.texCoords = shadowPosition.xy; shadowParameters.depth = shadowPosition.z; shadowParameters.nDotL = nDotL; float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); // Fade out shadows that are far away float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); visibility = mix(visibility, 1.0, fade); ${f?` // Draw cascade colors for debugging out_FragColor *= czm_cascadeColor(weights); `:\"\"}`:R+=` float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); applyNormalOffset(positionEC, normalEC, nDotL); vec4 shadowPosition = shadowMap_matrix * positionEC; // Stop early if the fragment is not in the shadow bounds if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) { return; } shadowParameters.texCoords = shadowPosition.xy; shadowParameters.depth = shadowPosition.z; shadowParameters.nDotL = nDotL; float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); `,R+=` out_FragColor.rgb *= visibility; } `,V.push(R),new Ue({defines:C,sources:V})};var Hf=LT;function Kf(e){e=g(e,g.EMPTY_OBJECT);let t=e.context;this._enabled=g(e.enabled,!0),this._softShadows=g(e.softShadows,!1),this._normalOffset=g(e.normalOffset,!0),this.dirty=!0,this.fromLightSource=g(e.fromLightSource,!0),this.darkness=g(e.darkness,.3),this._darkness=this.darkness,this.fadingEnabled=g(e.fadingEnabled,!0),this.maximumDistance=g(e.maximumDistance,5e3),this._outOfView=!1,this._outOfViewPrevious=!1,this._needsUpdate=!0;let n=!0;(Ut.isInternetExplorer()||Ut.isEdge()||(Ut.isChrome()||Ut.isFirefox())&&Ut.isWindows()&&!t.depthTexture)&&(n=!1),this._polygonOffsetSupported=n,this._terrainBias={polygonOffset:n,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:.5,normalShading:!0,normalShadingSmooth:.3,depthBias:1e-4},this._primitiveBias={polygonOffset:n,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:.1,normalShading:!0,normalShadingSmooth:.05,depthBias:2e-5},this._pointBias={polygonOffset:!1,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:0,normalShading:!0,normalShadingSmooth:.1,depthBias:5e-4},this._depthAttachment=void 0,this._colorAttachment=void 0,this._shadowMapMatrix=new M,this._shadowMapTexture=void 0,this._lightDirectionEC=new h,this._lightPositionEC=new se,this._distance=0,this._lightCamera=e.lightCamera,this._shadowMapCamera=new OD,this._shadowMapCullingVolume=void 0,this._sceneCamera=void 0,this._boundingSphere=new ce,this._isPointLight=g(e.isPointLight,!1),this._pointLightRadius=g(e.pointLightRadius,100),this._cascadesEnabled=this._isPointLight?!1:g(e.cascadesEnabled,!0),this._numberOfCascades=this._cascadesEnabled?g(e.numberOfCascades,4):0,this._fitNearFar=!0,this._maximumCascadeDistances=[25,150,700,Number.MAX_VALUE],this._textureSize=new D,this._isSpotLight=!1,this._cascadesEnabled?this._shadowMapCamera.frustum=new Vr:l(this._lightCamera.frustum.fov)&&(this._isSpotLight=!0),this._cascadeSplits=[new se,new se],this._cascadeMatrices=[new M,new M,new M,new M],this._cascadeDistances=new se;let i;this._isPointLight?i=6:this._cascadesEnabled?i=this._numberOfCascades:i=1,this._passes=new Array(i);for(let o=0;o<i;++o)this._passes[o]=new vdt(t);this.debugShow=!1,this.debugFreezeFrame=!1,this._debugFreezeFrame=!1,this._debugCascadeColors=!1,this._debugLightFrustum=void 0,this._debugCameraFrustum=void 0,this._debugCascadeFrustums=new Array(this._numberOfCascades),this._debugShadowViewCommand=void 0,this._usesDepthTexture=t.depthTexture,this._isPointLight&&(this._usesDepthTexture=!1),this._primitiveRenderState=void 0,this._terrainRenderState=void 0,this._pointRenderState=void 0,uj(this),this._clearCommand=new ei({depth:1,color:new O}),this._clearPassState=new $a(t),this._size=g(e.size,2048),this.size=this._size}Kf.MAXIMUM_DISTANCE=2e4;function vdt(e){this.camera=new OD,this.passState=new $a(e),this.framebuffer=void 0,this.textureOffsets=void 0,this.commandList=[],this.cullingVolume=void 0}function dj(e,t){return Ne.fromCache({cull:{enabled:!0,face:mi.BACK},depthTest:{enabled:!0},colorMask:{red:e,green:e,blue:e,alpha:e},depthMask:!0,polygonOffset:{enabled:t.polygonOffset,factor:t.polygonOffsetFactor,units:t.polygonOffsetUnits}})}function uj(e){let t=!e._usesDepthTexture;e._primitiveRenderState=dj(t,e._primitiveBias),e._terrainRenderState=dj(t,e._terrainBias),e._pointRenderState=dj(t,e._pointBias)}Kf.prototype.debugCreateRenderStates=function(){uj(this)};Object.defineProperties(Kf.prototype,{enabled:{get:function(){return this._enabled},set:function(e){this.dirty=this._enabled!==e,this._enabled=e}},normalOffset:{get:function(){return this._normalOffset},set:function(e){this.dirty=this._normalOffset!==e,this._normalOffset=e,this._terrainBias.normalOffset=e,this._primitiveBias.normalOffset=e,this._pointBias.normalOffset=e}},softShadows:{get:function(){return this._softShadows},set:function(e){this.dirty=this._softShadows!==e,this._softShadows=e}},size:{get:function(){return this._size},set:function(e){kdt(this,e)}},outOfView:{get:function(){return this._outOfView}},shadowMapCullingVolume:{get:function(){return this._shadowMapCullingVolume}},passes:{get:function(){return this._passes}},isPointLight:{get:function(){return this._isPointLight}},debugCascadeColors:{get:function(){return this._debugCascadeColors},set:function(e){this.dirty=this._debugCascadeColors!==e,this._debugCascadeColors=e}}});function mj(e){let t=e._passes.length;for(let n=0;n<t;++n){let i=e._passes[n],o=i.framebuffer;l(o)&&!o.isDestroyed()&&o.destroy(),i.framebuffer=void 0}e._depthAttachment=e._depthAttachment&&e._depthAttachment.destroy(),e._colorAttachment=e._colorAttachment&&e._colorAttachment.destroy()}function wdt(e,t){let n=new rd({context:t,width:e._textureSize.x,height:e._textureSize.y,format:Pc.DEPTH_COMPONENT16}),i=new Ft({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:at.RGBA,pixelDatatype:Qe.UNSIGNED_BYTE,sampler:mn.NEAREST}),o=new $s({context:t,depthRenderbuffer:n,colorTextures:[i],destroyAttachments:!1}),r=e._passes.length;for(let s=0;s<r;++s){let a=e._passes[s];a.framebuffer=o,a.passState.framebuffer=o}e._shadowMapTexture=i,e._depthAttachment=n,e._colorAttachment=i}function Fdt(e,t){let n=new Ft({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:at.DEPTH_STENCIL,pixelDatatype:Qe.UNSIGNED_INT_24_8,sampler:mn.NEAREST}),i=new $s({context:t,depthStencilTexture:n,destroyAttachments:!1}),o=e._passes.length;for(let r=0;r<o;++r){let s=e._passes[r];s.framebuffer=i,s.passState.framebuffer=i}e._shadowMapTexture=n,e._depthAttachment=n}function Adt(e,t){let n=new rd({context:t,width:e._textureSize.x,height:e._textureSize.y,format:Pc.DEPTH_COMPONENT16}),i=new qa({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:at.RGBA,pixelDatatype:Qe.UNSIGNED_BYTE,sampler:mn.NEAREST}),o=[i.negativeX,i.negativeY,i.negativeZ,i.positiveX,i.positiveY,i.positiveZ];for(let r=0;r<6;++r){let s=new $s({context:t,depthRenderbuffer:n,colorTextures:[o[r]],destroyAttachments:!1}),a=e._passes[r];a.framebuffer=s,a.passState.framebuffer=s}e._shadowMapTexture=i,e._depthAttachment=n,e._colorAttachment=i}function zge(e,t){e._isPointLight?Adt(e,t):e._usesDepthTexture?Fdt(e,t):wdt(e,t)}function Mdt(e,t){e._usesDepthTexture&&e._passes[0].framebuffer.status!==ne.FRAMEBUFFER_COMPLETE&&(e._usesDepthTexture=!1,uj(e),mj(e),zge(e,t))}function Ndt(e,t){(!l(e._passes[0].framebuffer)||e._shadowMapTexture.width!==e._textureSize.x)&&(mj(e),zge(e,t),Mdt(e,t),Hge(e,t))}function Hge(e,t,n){n=g(n,0),(e._isPointLight||n===0)&&(e._clearCommand.framebuffer=e._passes[n].framebuffer,e._clearCommand.execute(t,e._clearPassState))}function kdt(e,t){e._size=t;let n=e._passes,i=n.length,o=e._textureSize;if(e._isPointLight){t=Yt.maximumCubeMapSize>=t?t:Yt.maximumCubeMapSize,o.x=t,o.y=t;let r=new ze(0,0,t,t);n[0].passState.viewport=r,n[1].passState.viewport=r,n[2].passState.viewport=r,n[3].passState.viewport=r,n[4].passState.viewport=r,n[5].passState.viewport=r}else i===1?(t=Yt.maximumTextureSize>=t?t:Yt.maximumTextureSize,o.x=t,o.y=t,n[0].passState.viewport=new ze(0,0,t,t)):i===4&&(t=Yt.maximumTextureSize>=t*2?t:Yt.maximumTextureSize/2,o.x=t*2,o.y=t*2,n[0].passState.viewport=new ze(0,0,t,t),n[1].passState.viewport=new ze(t,0,t,t),n[2].passState.viewport=new ze(0,t,t,t),n[3].passState.viewport=new ze(t,t,t,t));e._clearPassState.viewport=new ze(0,0,o.x,o.y);for(let r=0;r<i;++r){let s=n[r],a=s.passState.viewport,c=a.x/o.x,d=a.y/o.y,u=a.width/o.x,m=a.height/o.y;s.textureOffsets=new M(u,0,0,c,0,m,0,d,0,0,1,0,0,0,0,1)}}var Udt=new ze;function Ddt(e,t){let n;e._isPointLight?n=`uniform samplerCube shadowMap_textureCube; in vec2 v_textureCoordinates; void main() { vec2 uv = v_textureCoordinates; vec3 dir; if (uv.y < 0.5) { if (uv.x < 0.333) { dir.x = -1.0; dir.y = uv.x * 6.0 - 1.0; dir.z = uv.y * 4.0 - 1.0; } else if (uv.x < 0.666) { dir.y = -1.0; dir.x = uv.x * 6.0 - 3.0; dir.z = uv.y * 4.0 - 1.0; } else { dir.z = -1.0; dir.x = uv.x * 6.0 - 5.0; dir.y = uv.y * 4.0 - 1.0; } } else { if (uv.x < 0.333) { dir.x = 1.0; dir.y = uv.x * 6.0 - 1.0; dir.z = uv.y * 4.0 - 3.0; } else if (uv.x < 0.666) { dir.y = 1.0; dir.x = uv.x * 6.0 - 3.0; dir.z = uv.y * 4.0 - 3.0; } else { dir.z = 1.0; dir.x = uv.x * 6.0 - 5.0; dir.y = uv.y * 4.0 - 3.0; } } float shadow = czm_unpackDepth(czm_textureCube(shadowMap_textureCube, dir)); out_FragColor = vec4(vec3(shadow), 1.0); } `:n=`uniform sampler2D shadowMap_texture; in vec2 v_textureCoordinates; void main() { ${e._usesDepthTexture?` float shadow = texture(shadowMap_texture, v_textureCoordinates).r; `:` float shadow = czm_unpackDepth(texture(shadowMap_texture, v_textureCoordinates)); `} out_FragColor = vec4(vec3(shadow), 1.0); } `;let i=t.createViewportQuadCommand(n,{uniformMap:{shadowMap_texture:function(){return e._shadowMapTexture},shadowMap_textureCube:function(){return e._shadowMapTexture}}});return i.pass=Ze.OVERLAY,i}function Bdt(e,t){let n=t.context,i=t.context.drawingBufferWidth,o=t.context.drawingBufferHeight,r=Math.min(i,o)*.3,s=Udt;s.x=i-r,s.y=0,s.width=r,s.height=r;let a=e._debugShadowViewCommand;l(a)||(a=Ddt(e,n),e._debugShadowViewCommand=a),(!l(a.renderState)||!ze.equals(a.renderState.viewport,s))&&(a.renderState=Ne.fromCache({viewport:ze.clone(s)})),t.commandList.push(e._debugShadowViewCommand)}var Jf=new Array(8);Jf[0]=new se(-1,-1,-1,1);Jf[1]=new se(1,-1,-1,1);Jf[2]=new se(1,1,-1,1);Jf[3]=new se(-1,1,-1,1);Jf[4]=new se(-1,-1,1,1);Jf[5]=new se(1,-1,1,1);Jf[6]=new se(1,1,1,1);Jf[7]=new se(-1,1,1,1);var xg=new M,hj=new Array(8);for(let e=0;e<8;++e)hj[e]=new se;function Ydt(e,t){let n=new Vt({geometry:new Tm({minimum:new h(-.5,-.5,-.5),maximum:new h(.5,.5,.5)}),attributes:{color:Ot.fromColor(t)}}),i=new Vt({geometry:new p0({radius:.5}),attributes:{color:Ot.fromColor(t)}});return new Rn({geometryInstances:[n,i],appearance:new ln({translucent:!1,flat:!0}),asynchronous:!1,modelMatrix:e})}var Odt=[O.RED,O.GREEN,O.BLUE,O.MAGENTA],zdt=new h;function Hdt(e,t){Bdt(e,t);let n=e.debugFreezeFrame&&!e._debugFreezeFrame;if(e._debugFreezeFrame=e.debugFreezeFrame,e.debugFreezeFrame&&(n&&(e._debugCameraFrustum=e._debugCameraFrustum&&e._debugCameraFrustum.destroy(),e._debugCameraFrustum=new Yf({camera:e._sceneCamera,color:O.CYAN,updateOnChange:!1})),e._debugCameraFrustum.update(t)),e._cascadesEnabled){if(e.debugFreezeFrame){n&&(e._debugLightFrustum=e._debugLightFrustum&&e._debugLightFrustum.destroy(),e._debugLightFrustum=new Yf({camera:e._shadowMapCamera,color:O.YELLOW,updateOnChange:!1})),e._debugLightFrustum.update(t);for(let i=0;i<e._numberOfCascades;++i)n&&(e._debugCascadeFrustums[i]=e._debugCascadeFrustums[i]&&e._debugCascadeFrustums[i].destroy(),e._debugCascadeFrustums[i]=new Yf({camera:e._passes[i].camera,color:Odt[i],updateOnChange:!1})),e._debugCascadeFrustums[i].update(t)}}else if(e._isPointLight){if(!l(e._debugLightFrustum)||e._needsUpdate){let i=e._shadowMapCamera.positionWC,o=Fe.IDENTITY,r=e._pointLightRadius*2,s=h.fromElements(r,r,r,zdt),a=M.fromTranslationQuaternionRotationScale(i,o,s,xg);e._debugLightFrustum=e._debugLightFrustum&&e._debugLightFrustum.destroy(),e._debugLightFrustum=Ydt(a,O.YELLOW)}e._debugLightFrustum.update(t)}else(!l(e._debugLightFrustum)||e._needsUpdate)&&(e._debugLightFrustum=new Yf({camera:e._shadowMapCamera,color:O.YELLOW,updateOnChange:!1})),e._debugLightFrustum.update(t)}function OD(){this.viewMatrix=new M,this.inverseViewMatrix=new M,this.frustum=void 0,this.positionCartographic=new he,this.positionWC=new h,this.directionWC=h.clone(h.UNIT_Z),this.upWC=h.clone(h.UNIT_Y),this.rightWC=h.clone(h.UNIT_X),this.viewProjectionMatrix=new M}OD.prototype.clone=function(e){M.clone(e.viewMatrix,this.viewMatrix),M.clone(e.inverseViewMatrix,this.inverseViewMatrix),this.frustum=e.frustum.clone(this.frustum),he.clone(e.positionCartographic,this.positionCartographic),h.clone(e.positionWC,this.positionWC),h.clone(e.directionWC,this.directionWC),h.clone(e.upWC,this.upWC),h.clone(e.rightWC,this.rightWC)};var Kdt=new M(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);OD.prototype.getViewProjection=function(){let e=this.viewMatrix,t=this.frustum.projectionMatrix;return M.multiply(t,e,this.viewProjectionMatrix),M.multiply(Kdt,this.viewProjectionMatrix,this.viewProjectionMatrix),this.viewProjectionMatrix};var Jdt=new Array(5),Qdt=new _i,jdt=new Array(4),Kge=new h,Jge=new h;function qdt(e,t){let n=e._shadowMapCamera,i=e._sceneCamera,o=i.frustum.near,r=i.frustum.far,s=e._numberOfCascades,a,c=r-o,d=r/o,u=.9,m=!1;t.shadowState.closestObjectSize<200&&(m=!0,u=.9);let p=jdt,b=Jdt;for(b[0]=o,b[s]=r,a=0;a<s;++a){let A=(a+1)/s,y=o*Math.pow(d,A),Z=o+c*A,E=P.lerp(Z,y,u);b[a+1]=E,p[a]=E-b[a]}if(m){for(a=0;a<s;++a)p[a]=Math.min(p[a],e._maximumCascadeDistances[a]);let A=b[0];for(a=0;a<s-1;++a)A+=p[a],b[a+1]=A}se.unpack(b,0,e._cascadeSplits[0]),se.unpack(b,1,e._cascadeSplits[1]),se.unpack(p,0,e._cascadeDistances);let f=n.frustum,x=f.left,_=f.right,C=f.bottom,V=f.top,L=f.near,R=f.far,G=n.positionWC,X=n.directionWC,v=n.upWC,W=i.frustum.clone(Qdt),F=n.getViewProjection();for(a=0;a<s;++a){W.near=b[a],W.far=b[a+1];let A=M.multiply(W.projectionMatrix,i.viewMatrix,xg),y=M.inverse(A,xg),Z=M.multiply(F,y,xg),E=h.fromElements(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Kge),I=h.fromElements(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,Jge);for(let Y=0;Y<8;++Y){let N=se.clone(Jf[Y],hj[Y]);M.multiplyByVector(Z,N,N),h.divideByScalar(N,N.w,N),h.minimumByComponent(N,E,E),h.maximumByComponent(N,I,I)}E.x=Math.max(E.x,0),E.y=Math.max(E.y,0),E.z=0,I.x=Math.min(I.x,1),I.y=Math.min(I.y,1),I.z=Math.min(I.z,1);let w=e._passes[a],k=w.camera;k.clone(n);let B=k.frustum;B.left=x+E.x*(_-x),B.right=x+I.x*(_-x),B.bottom=C+E.y*(V-C),B.top=C+I.y*(V-C),B.near=L+E.z*(R-L),B.far=L+I.z*(R-L),w.cullingVolume=k.frustum.computeCullingVolume(G,X,v);let U=e._cascadeMatrices[a];M.multiply(k.getViewProjection(),i.inverseViewMatrix,U),M.multiply(w.textureOffsets,U,U)}}var $dt=new M,eut=new h,tut=new h,Yge=new h;function nut(e,t){let n=e._shadowMapCamera,i=e._sceneCamera,o=M.multiply(i.frustum.projectionMatrix,i.viewMatrix,xg),r=M.inverse(o,xg),s=n.directionWC,a=i.directionWC;h.equalsEpsilon(s,a,P.EPSILON10)&&(a=i.upWC);let c=h.cross(s,a,eut);a=h.cross(c,s,tut),h.normalize(a,a),h.normalize(c,c);let d=h.fromElements(0,0,0,Yge),u=M.computeView(d,s,a,c,$dt),m=M.multiply(u,r,xg),p=h.fromElements(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Kge),b=h.fromElements(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,Jge);for(let R=0;R<8;++R){let"
}