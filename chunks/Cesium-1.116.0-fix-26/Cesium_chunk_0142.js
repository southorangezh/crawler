{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 142,
    "total_chunks": 194,
    "chunk_size": 8348,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.737Z"
  },
  "content": "fxe(this,e,t,n,i,o,!1,!1)};Js.prototype.pickFromRayMostDetailed=function(e,t,n,i){let o=this;return t=bn.clone(t),n=l(n)?n.slice():n,qD(e,jD(o,e,t,n,i,function(){return zV(o,e,t,n,i,!1,!0)}))};Js.prototype.drillPickFromRayMostDetailed=function(e,t,n,i,o){let r=this;return t=bn.clone(t),i=l(i)?i.slice():i,qD(e,jD(r,e,t,i,o,function(){return fxe(r,e,t,n,i,o,!1,!0)}))};var bmt=new h,ymt=new h,gmt=new bn,pxe=new he;function Sj(e,t){let n=e.globe,i=l(n)?n.ellipsoid:e.mapProjection.ellipsoid,o=ai._defaultMaxTerrainHeight,r=i.geodeticSurfaceNormalCartographic(t,ymt),s=he.toCartesian(t,i,bmt),a=gmt;a.origin=s,a.direction=r;let c=new bn;return bn.getPoint(a,o,c.origin),h.negate(r,c.direction),c}function bxe(e,t){let n=e.globe,i=l(n)?n.ellipsoid:e.mapProjection.ellipsoid,o=he.fromCartesian(t,i,pxe);return Sj(e,o)}function yxe(e,t){let n=e.globe,i=l(n)?n.ellipsoid:e.mapProjection.ellipsoid;return he.fromCartesian(t,i,pxe).height}function xmt(e,t,n,i,o){let r=Sj(t,n);return jD(e,t,r,i,o,function(){let s=zV(e,t,r,i,o,!0,!0);if(l(s))return yxe(t,s.position)})}function _mt(e,t,n,i,o,r){let s=bxe(t,n);return jD(e,t,s,i,o,function(){let a=zV(e,t,s,i,o,!0,!0);if(l(a))return h.clone(a.position,r)})}Js.prototype.sampleHeight=function(e,t,n,i){let o=Sj(e,t),r=zV(this,e,o,n,i,!0,!1);if(l(r))return yxe(e,r.position)};Js.prototype.clampToHeight=function(e,t,n,i,o){let r=bxe(e,t),s=zV(this,e,r,n,i,!0,!1);if(l(s))return h.clone(s.position,o)};Js.prototype.sampleHeightMostDetailed=function(e,t,n,i){n=l(n)?n.slice():n;let o=t.length,r=new Array(o);for(let s=0;s<o;++s)r[s]=xmt(this,e,t[s],n,i);return qD(e,Promise.all(r).then(function(s){let a=s.length;for(let c=0;c<a;++c)t[c].height=s[c];return t}))};Js.prototype.clampToHeightMostDetailed=function(e,t,n,i){n=l(n)?n.slice():n;let o=t.length,r=new Array(o);for(let s=0;s<o;++s)r[s]=_mt(this,e,t[s],n,i,t[s]);return qD(e,Promise.all(r).then(function(s){let a=s.length;for(let c=0;c<a;++c)t[c]=s[c];return t}))};Js.prototype.destroy=function(){this._pickOffscreenView=this._pickOffscreenView&&this._pickOffscreenView.destroy()};var cF=Js;var Kwi=T(S(),1);var Cwi=T(S(),1);var RPi=T(S(),1),lF=`uniform sampler2D colorTexture; in vec2 v_textureCoordinates; #ifdef AUTO_EXPOSURE uniform sampler2D autoExposure; #endif void main() { vec4 fragmentColor = texture(colorTexture, v_textureCoordinates); vec3 color = fragmentColor.rgb; #ifdef AUTO_EXPOSURE color /= texture(autoExposure, vec2(0.5)).r; #endif color = czm_acesTonemapping(color); color = czm_inverseGamma(color); out_FragColor = vec4(color, fragmentColor.a); } `;var EPi=T(S(),1),dF=`uniform sampler2D randomTexture; uniform sampler2D depthTexture; uniform float intensity; uniform float bias; uniform float lengthCap; uniform float stepSize; uniform float frustumLength; in vec2 v_textureCoordinates; vec4 clipToEye(vec2 uv, float depth) { vec2 xy = vec2((uv.x * 2.0 - 1.0), ((1.0 - uv.y) * 2.0 - 1.0)); vec4 posEC = czm_inverseProjection * vec4(xy, depth, 1.0); posEC = posEC / posEC.w; return posEC; } //Reconstruct Normal Without Edge Removation vec3 getNormalXEdge(vec3 posInCamera, float depthU, float depthD, float depthL, float depthR, vec2 pixelSize) { vec4 posInCameraUp = clipToEye(v_textureCoordinates - vec2(0.0, pixelSize.y), depthU); vec4 posInCameraDown = clipToEye(v_textureCoordinates + vec2(0.0, pixelSize.y), depthD); vec4 posInCameraLeft = clipToEye(v_textureCoordinates - vec2(pixelSize.x, 0.0), depthL); vec4 posInCameraRight = clipToEye(v_textureCoordinates + vec2(pixelSize.x, 0.0), depthR); vec3 up = posInCamera.xyz - posInCameraUp.xyz; vec3 down = posInCameraDown.xyz - posInCamera.xyz; vec3 left = posInCamera.xyz - posInCameraLeft.xyz; vec3 right = posInCameraRight.xyz - posInCamera.xyz; vec3 DX = length(left) < length(right) ? left : right; vec3 DY = length(up) < length(down) ? up : down; return normalize(cross(DY, DX)); } void main(void) { float depth = czm_readDepth(depthTexture, v_textureCoordinates); vec4 posInCamera = clipToEye(v_textureCoordinates, depth); if (posInCamera.z > frustumLength) { out_FragColor = vec4(1.0); return; } vec2 pixelSize = czm_pixelRatio / czm_viewport.zw; float depthU = czm_readDepth(depthTexture, v_textureCoordinates - vec2(0.0, pixelSize.y)); float depthD = czm_readDepth(depthTexture, v_textureCoordinates + vec2(0.0, pixelSize.y)); float depthL = czm_readDepth(depthTexture, v_textureCoordinates - vec2(pixelSize.x, 0.0)); float depthR = czm_readDepth(depthTexture, v_textureCoordinates + vec2(pixelSize.x, 0.0)); vec3 normalInCamera = getNormalXEdge(posInCamera.xyz, depthU, depthD, depthL, depthR, pixelSize); float ao = 0.0; vec2 sampleDirection = vec2(1.0, 0.0); float gapAngle = 90.0 * czm_radiansPerDegree; // RandomNoise float randomVal = texture(randomTexture, v_textureCoordinates / pixelSize / 255.0).x; //Loop for each direction for (int i = 0; i < 4; i++) { float newGapAngle = gapAngle * (float(i) + randomVal); float cosVal = cos(newGapAngle); float sinVal = sin(newGapAngle); //Rotate Sampling Direction vec2 rotatedSampleDirection = vec2(cosVal * sampleDirection.x - sinVal * sampleDirection.y, sinVal * sampleDirection.x + cosVal * sampleDirection.y); float localAO = 0.0; float localStepSize = stepSize; //Loop for each step for (int j = 0; j < 6; j++) { vec2 newCoords = v_textureCoordinates + rotatedSampleDirection * localStepSize * pixelSize; //Exception Handling if(newCoords.x > 1.0 || newCoords.y > 1.0 || newCoords.x < 0.0 || newCoords.y < 0.0) { break; } float stepDepthInfo = czm_readDepth(depthTexture, newCoords); vec4 stepPosInCamera = clipToEye(newCoords, stepDepthInfo); vec3 diffVec = stepPosInCamera.xyz - posInCamera.xyz; float len = length(diffVec); if (len > lengthCap) { break; } float dotVal = clamp(dot(normalInCamera, normalize(diffVec)), 0.0, 1.0 ); float weight = len / lengthCap; weight = 1.0 - weight * weight; if (dotVal < bias) { dotVal = 0.0; } localAO = max(localAO, dotVal * weight); localStepSize += stepSize; } ao += localAO; } ao /= 4.0; ao = 1.0 - clamp(ao, 0.0, 1.0); ao = pow(ao, intensity); out_FragColor = vec4(vec3(ao), 1.0); } `;var IPi=T(S(),1),uF=`uniform sampler2D colorTexture; uniform sampler2D ambientOcclusionTexture; uniform bool ambientOcclusionOnly; in vec2 v_textureCoordinates; void main(void) { vec4 color = texture(colorTexture, v_textureCoordinates); vec4 ao = texture(ambientOcclusionTexture, v_textureCoordinates); out_FragColor = ambientOcclusionOnly ? ao : ao * color; } `;var PPi=T(S(),1),mF=`uniform sampler2D colorTexture; uniform float gradations; in vec2 v_textureCoordinates; void main(void) { vec3 rgb = texture(colorTexture, v_textureCoordinates).rgb; #ifdef CZM_SELECTED_FEATURE if (czm_selected()) { out_FragColor = vec4(rgb, 1.0); return; } #endif float luminance = czm_luminance(rgb); float darkness = luminance * gradations; darkness = (darkness - fract(darkness)) / gradations; out_FragColor = vec4(vec3(darkness), 1.0); } `;var wPi=T(S(),1),hF=`uniform sampler2D colorTexture; uniform sampler2D bloomTexture; uniform bool glowOnly; in vec2 v_textureCoordinates; void main(void) { vec4 color = texture(colorTexture, v_textureCoordinates); #ifdef CZM_SELECTED_FEATURE if (czm_selected()) { out_FragColor = color; return; } #endif vec4 bloom = texture(bloomTexture, v_textureCoordinates); out_FragColor = glowOnly ? bloom : bloom + color; } `;var APi=T(S(),1),fF=`uniform sampler2D colorTexture; uniform float brightness; in vec2 v_textureCoordinates; void main(void) { vec3 rgb = texture(colorTexture, v_textureCoordinates).rgb; vec3 target = vec3(0.0); out_FragColor = vec4(mix(target, rgb, brightness), 1.0); } `;var NPi=T(S(),1),pF=`uniform sampler2D colorTexture; uniform float contrast; uniform float brightness; in vec2 v_textureCoordinates; void main(void) { vec3 sceneColor = texture(colorTexture, v_textureCoordinates).xyz; sceneColor = czm_RGBToHSB(sceneColor); sceneColor.z += brightness; sceneColor = czm_HSBToRGB(sceneColor); float factor = (259.0 * (contrast + 255.0)) / (255.0 * (259.0 - contrast)); sceneColor = factor * (sceneColor - vec3(0.5)) + vec3(0.5); out_FragColor = vec4(sceneColor, 1.0); } `;var UPi=T(S(),1),bF=`uniform sampler2D colorTexture; uniform sampler2D blurTexture; uniform sampler2D depthTexture; uniform float focalDistance; in vec2 v_textureCoordinates; vec4 toEye(vec2 uv, float depth) { vec2 xy = vec2((uv.x * 2.0 - 1.0), ((1.0 - uv.y)"
}