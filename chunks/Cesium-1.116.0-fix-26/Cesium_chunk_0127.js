{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 127,
    "total_chunks": 194,
    "chunk_size": 6028,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.727Z"
  },
  "content": "horizon // Value close to 1.0: above in the sky float w_stop_gt_lprl = 0.5 * (1.0 + czm_approximateTanh(x)); // The ray should start from the first intersection with the outer atmopshere, or from the camera position, if it is inside the atmosphere. float start_0 = primaryRayAtmosphereIntersect.start; primaryRayAtmosphereIntersect.start = max(primaryRayAtmosphereIntersect.start, 0.0); // The ray should end at the exit from the atmosphere or at the distance to the vertex, whichever is smaller. primaryRayAtmosphereIntersect.stop = min(primaryRayAtmosphereIntersect.stop, length(primaryRayLength)); // For the number of ray steps, distinguish inside or outside atmosphere (outer space) // (1) from outer space we have to use more ray steps to get a realistic rendering // (2) within atmosphere we need fewer steps for faster rendering float x_o_a = start_0 - ATMOSPHERE_THICKNESS; // ATMOSPHERE_THICKNESS used as an ad-hoc constant, no precise meaning here, only the order of magnitude matters float w_inside_atmosphere = 1.0 - 0.5 * (1.0 + czm_approximateTanh(x_o_a)); int PRIMARY_STEPS = PRIMARY_STEPS_MAX - int(w_inside_atmosphere * 12.0); // Number of times the ray from the camera to the world position (primary ray) is sampled. int LIGHT_STEPS = LIGHT_STEPS_MAX - int(w_inside_atmosphere * 2.0); // Number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray. // Setup for sampling positions along the ray - starting from the intersection with the outer ring of the atmosphere. float rayPositionLength = primaryRayAtmosphereIntersect.start; // (1) Outside the atmosphere: constant rayStepLength // (2) Inside atmosphere: variable rayStepLength to compensate the rough rendering of the smaller number of ray steps float totalRayLength = primaryRayAtmosphereIntersect.stop - rayPositionLength; float rayStepLengthIncrease = w_inside_atmosphere * ((1.0 - w_stop_gt_lprl) * totalRayLength / (float(PRIMARY_STEPS * (PRIMARY_STEPS + 1)) / 2.0)); float rayStepLength = max(1.0 - w_inside_atmosphere, w_stop_gt_lprl) * totalRayLength / max(7.0 * w_inside_atmosphere, float(PRIMARY_STEPS)); vec3 rayleighAccumulation = vec3(0.0); vec3 mieAccumulation = vec3(0.0); vec2 opticalDepth = vec2(0.0); vec2 heightScale = vec2(u_atmosphereRayleighScaleHeight, u_atmosphereMieScaleHeight); // Sample positions on the primary ray. for (int i = 0; i < PRIMARY_STEPS_MAX; ++i) { // The loop should be: for (int i = 0; i < PRIMARY_STEPS; ++i) {...} but WebGL1 cannot // loop with non-constant condition, so it has to break early instead if (i >= PRIMARY_STEPS) { break; } // Calculate sample position along viewpoint ray. vec3 samplePosition = primaryRay.origin + primaryRay.direction * (rayPositionLength + rayStepLength); // Calculate height of sample position above ellipsoid. float sampleHeight = length(samplePosition) - atmosphereInnerRadius; // Calculate and accumulate density of particles at the sample position. vec2 sampleDensity = exp(-sampleHeight / heightScale) * rayStepLength; opticalDepth += sampleDensity; // Generate ray from the sample position segment to the light source, up to the outer ring of the atmosphere. czm_ray lightRay = czm_ray(samplePosition, lightDirection); czm_raySegment lightRayAtmosphereIntersect = czm_raySphereIntersectionInterval(lightRay, origin, atmosphereOuterRadius); float lightStepLength = lightRayAtmosphereIntersect.stop / float(LIGHT_STEPS); float lightPositionLength = 0.0; vec2 lightOpticalDepth = vec2(0.0); // Sample positions along the light ray, to accumulate incidence of light on the latest sample segment. for (int j = 0; j < LIGHT_STEPS_MAX; ++j) { // The loop should be: for (int j = 0; i < LIGHT_STEPS; ++j) {...} but WebGL1 cannot // loop with non-constant condition, so it has to break early instead if (j >= LIGHT_STEPS) { break; } // Calculate sample position along light ray. vec3 lightPosition = samplePosition + lightDirection * (lightPositionLength + lightStepLength * 0.5); // Calculate height of the light sample position above ellipsoid. float lightHeight = length(lightPosition) - atmosphereInnerRadius; // Calculate density of photons at the light sample position. lightOpticalDepth += exp(-lightHeight / heightScale) * lightStepLength; // Increment distance on light ray. lightPositionLength += lightStepLength; } // Compute attenuation via the primary ray and the light ray. vec3 attenuation = exp(-((u_atmosphereMieCoefficient * (opticalDepth.y + lightOpticalDepth.y)) + (u_atmosphereRayleighCoefficient * (opticalDepth.x + lightOpticalDepth.x)))); // Accumulate the scattering. rayleighAccumulation += sampleDensity.x * attenuation; mieAccumulation += sampleDensity.y * attenuation; // Increment distance on primary ray. rayPositionLength += (rayStepLength += rayStepLengthIncrease); } // Compute the scattering amount. rayleighColor = u_atmosphereRayleighCoefficient * rayleighAccumulation; mieColor = u_atmosphereMieCoefficient * mieAccumulation; // Compute the transmittance i.e. how much light is passing through the atmosphere. opacity = length(exp(-((u_atmosphereMieCoefficient * opticalDepth.y) + (u_atmosphereRayleighCoefficient * opticalDepth.x)))); } vec4 computeAtmosphereColor( vec3 positionWC, vec3 lightDirection, vec3 rayleighColor, vec3 mieColor, float opacity ) { // Setup the primary ray: from the camera position to the vertex position. vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC; vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC); float cosAngle = dot(cameraToPositionWCDirection, lightDirection); float cosAngleSq = cosAngle * cosAngle; float G = u_atmosphereMieAnisotropy; float GSq = G * G; // The Rayleigh phase function. float rayleighPhase = 3.0 / (50.2654824574) * (1.0 + cosAngleSq); // The Mie phase function. float miePhase = 3.0 / (25.1327412287) * ((1.0 - GSq) * (cosAngleSq + 1.0)) / (pow(1.0 + GSq - 2.0 * cosAngle * G, 1.5) * (2.0 + GSq)); // The final color is generated by combining the effects of the Rayleigh and Mie"
}