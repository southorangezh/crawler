{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 161,
    "total_chunks": 194,
    "chunk_size": 6127,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.746Z"
  },
  "content": "u_cylinderRenderAngleMinMax); setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE, wedgeIntersect); #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF) RayShapeIntersection wedgeIntersects[2]; intersectFlippedWedge(ray, u_cylinderRenderAngleMinMax, wedgeIntersects); setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]); setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]); #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO) RayShapeIntersection wedgeIntersects[2]; intersectHalfPlane(ray, u_cylinderRenderAngleMinMax.x, wedgeIntersects); setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]); setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]); #endif } `;var VAi=T(S(),1),$F=`// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, INF_HIT, Intersections, // RayShapeIntersection, setSurfaceIntersection, setShapeIntersection // See IntersectLongitude.glsl for the definitions of intersectHalfPlane, // intersectFlippedWedge, intersectRegularWedge /* Ellipsoid defines (set in Scene/VoxelEllipsoidShape.js) #define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE #define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO #define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF #define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF #define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF #define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF #define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF #define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF #define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF #define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF #define ELLIPSOID_INTERSECTION_INDEX_LONGITUDE #define ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX #define ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN #define ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX #define ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN */ #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE) uniform vec2 u_ellipsoidRenderLongitudeMinMax; #endif uniform float u_eccentricitySquared; uniform vec2 u_ellipsoidRenderLatitudeSinMinMax; uniform vec2 u_clipMinMaxHeight; RayShapeIntersection intersectZPlane(in Ray ray, in float z) { float t = -ray.pos.z / ray.dir.z; bool startsOutside = sign(ray.pos.z) == sign(z); bool entry = (t >= 0.0) != startsOutside; vec4 intersect = vec4(0.0, 0.0, z, t); vec4 farSide = vec4(normalize(ray.dir), INF_HIT); if (entry) { return RayShapeIntersection(intersect, farSide); } else { return RayShapeIntersection(-1.0 * farSide, intersect); } } RayShapeIntersection intersectHeight(in Ray ray, in float relativeHeight, in bool convex) { // Scale the ray by the ellipsoid axes to make it a unit sphere // Note: approximating ellipsoid + height as an ellipsoid vec3 radiiCorrection = u_ellipsoidRadiiUv / (u_ellipsoidRadiiUv + relativeHeight); vec3 position = ray.pos * radiiCorrection; vec3 direction = ray.dir * radiiCorrection; float a = dot(direction, direction); // ~ 1.0 (or maybe 4.0 if ray is scaled) float b = dot(direction, position); // roughly inside [-1.0, 1.0] when zoomed in float c = dot(position, position) - 1.0; // ~ 0.0 when zoomed in. float determinant = b * b - a * c; // ~ b * b when zoomed in if (determinant < 0.0) { vec4 miss = vec4(normalize(direction), NO_HIT); return RayShapeIntersection(miss, miss); } determinant = sqrt(determinant); // Compute larger root using standard formula float signB = b < 0.0 ? -1.0 : 1.0; // The other root may suffer from subtractive cancellation in the standard formula. // Compute it from the first root instead. float t1 = (-b - signB * determinant) / a; float t2 = c / (a * t1); float tmin = min(t1, t2); float tmax = max(t1, t2); float directionScale = convex ? 1.0 : -1.0; vec3 d1 = directionScale * normalize(position + tmin * direction); vec3 d2 = directionScale * normalize(position + tmax * direction); return RayShapeIntersection(vec4(d1, tmin), vec4(d2, tmax)); } /** * Given a circular cone around the z-axis, with apex at the origin, * find the parametric distance(s) along a ray where that ray intersects * the cone. * The cone opening angle is described by the squared cosine of * its half-angle (the angle between the Z-axis and the surface) */ vec2 intersectDoubleEndedCone(in Ray ray, in float cosSqrHalfAngle) { vec3 o = ray.pos; vec3 d = ray.dir; float sinSqrHalfAngle = 1.0 - cosSqrHalfAngle; float aSin = d.z * d.z * sinSqrHalfAngle; float aCos = -dot(d.xy, d.xy) * cosSqrHalfAngle; float a = aSin + aCos; float bSin = d.z * o.z * sinSqrHalfAngle; float bCos = -dot(o.xy, d.xy) * cosSqrHalfAngle; float b = bSin + bCos; float cSin = o.z * o.z * sinSqrHalfAngle; float cCos = -dot(o.xy, o.xy) * cosSqrHalfAngle; float c = cSin + cCos; // determinant = b * b - a * c. But bSin * bSin = aSin * cSin. // Avoid subtractive cancellation by expanding to eliminate these terms float determinant = 2.0 * bSin * bCos + bCos * bCos - aSin * cCos - aCos * cSin - aCos * cCos; if (determinant < 0.0) { return vec2(NO_HIT); } else if (a == 0.0) { // Ray is parallel to cone surface return (b == 0.0) ? vec2(NO_HIT) // Ray is on cone surface : vec2(-0.5 * c / b, NO_HIT); } determinant = sqrt(determinant); // Compute larger root using standard formula float signB = b < 0.0 ? -1.0 : 1.0; float t1 = (-b - signB * determinant) / a; // The other root may suffer from subtractive cancellation in the standard formula. // Compute it from the first root instead. float t2 = c / (a * t1); float tmin = min(t1, t2); float tmax = max(t1, t2); return vec2(tmin, tmax); } /** * Given a point on a conical surface, find the surface normal at that point. */ vec3 getConeNormal(in vec3 p, in bool convex) { // Start with radial component pointing toward z-axis vec2 radial = -abs(p.z) * normalize(p.xy); // Z component points toward opening of cone float zSign = (p.z < 0.0) ? -1.0 : 1.0; float z = length(p.xy) * zSign; // Flip normal if shape is convex float flip = (convex) ? -1.0 : 1.0; return normalize(vec3(radial, z) * flip); } /** * Compute the shift between the"
}