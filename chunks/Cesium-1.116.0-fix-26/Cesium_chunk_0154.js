{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 154,
    "total_chunks": 194,
    "chunk_size": 19279,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.743Z"
  },
  "content": "o=e._scene.camera;if(!M.equals(o.transform,M.IDENTITY))return;if(l(n.angleAndHeight)&&(n=n.angleAndHeight),D.equals(t,e._tiltCenterMousePosition)||(e._tiltOnEllipsoid=!1,e._looking=!1),e._looking){let a=e._ellipsoid.geodeticSurfaceNormal(o.position,Qj);Hd(e,t,n,a);return}let s=e._ellipsoid.cartesianToCartographic(o.position,Jj);e._tiltOnEllipsoid||s.height>e._minimumCollisionTerrainHeight?(e._tiltOnEllipsoid=!0,fpt(e,t,n)):ppt(e,t,n)}var hpt=new he;function fpt(e,t,n){let i=e._ellipsoid,o=e._scene,r=o.camera,s=e.minimumZoomDistance*.25,a=i.cartesianToCartographic(r.positionWC,hpt).height;if(a-s-1<P.EPSILON3&&n.endPosition.y-n.startPosition.y<0)return;let c=o.canvas,d=L_e;d.x=c.clientWidth/2,d.y=c.clientHeight/2;let u=r.getPickRay(d,l3),m,p=jn.rayEllipsoid(u,i);if(l(p))m=bn.getPoint(u,p.start,FF);else if(a>e._minimumTrackBallHeight){let V=jn.grazingAltitudeLocation(u,i);if(!l(V))return;let L=i.cartesianToCartographic(V,Jj);L.height=0,m=i.cartographicToCartesian(L,FF)}else{e._looking=!0;let V=e._ellipsoid.geodeticSurfaceNormal(r.position,Qj);Hd(e,t,n,V),D.clone(t,e._tiltCenterMousePosition);return}let b=Wt.eastNorthUpToFixedFrame(m,i,Z_e),f=e._globe,x=e._ellipsoid;e._globe=void 0,e._ellipsoid=oe.UNIT_SPHERE,e._rotateFactor=1,e._rotateRateRangeAdjustment=1;let _=M.clone(r.transform,R_e);r._setTransform(b),zd(e,t,n,h.UNIT_Z),r._setTransform(_),e._globe=f,e._ellipsoid=x;let C=x.maximumRadius;e._rotateFactor=1/C,e._rotateRateRangeAdjustment=C}function ppt(e,t,n){let i=e._ellipsoid,o=e._scene,r=o.camera,s=e._cameraUnderground,a,c,d;if(D.equals(t,e._tiltCenterMousePosition))a=h.clone(e._tiltCenter,FF);else{if(a=ab(e,t,FF),!l(a)){if(c=r.getPickRay(t,l3),d=jn.rayEllipsoid(c,i),!l(d)){if(i.cartesianToCartographic(r.position,Jj).height<=e._minimumTrackBallHeight){e._looking=!0;let Z=e._ellipsoid.geodeticSurfaceNormal(r.position,Qj);Hd(e,t,n,Z),D.clone(t,e._tiltCenterMousePosition)}return}a=bn.getPoint(c,d.start,FF)}s&&(l(c)||(c=r.getPickRay(t,l3)),f_e(e,c,a,a)),D.clone(t,e._tiltCenterMousePosition),h.clone(a,e._tiltCenter)}let u=o.canvas,m=L_e;m.x=u.clientWidth/2,m.y=e._tiltCenterMousePosition.y,c=r.getPickRay(m,l3);let p=h.magnitude(a),b=h.fromElements(p,p,p,Oj),f=oe.fromCartesian3(b,zj);if(d=jn.rayEllipsoid(c,f),!l(d))return;let x=h.magnitude(c.origin)>p?d.start:d.stop,_=bn.getPoint(c,x,cpt),C=Wt.eastNorthUpToFixedFrame(a,i,Z_e),V=Wt.eastNorthUpToFixedFrame(_,f,lpt),L=e._globe,R=e._ellipsoid;e._globe=void 0,e._ellipsoid=oe.UNIT_SPHERE,e._rotateFactor=1,e._rotateRateRangeAdjustment=1;let G=h.UNIT_Z,X=M.clone(r.transform,R_e);r._setTransform(V);let v=h.cross(_,r.positionWC,c3);if(h.dot(r.rightWC,v)<0){let y=n.startPosition.y-n.endPosition.y;(s&&y<0||!s&&y>0)&&(G=void 0);let Z=r.constrainedAxis;r.constrainedAxis=void 0,zd(e,t,n,G,!0,!1),r.constrainedAxis=Z}else zd(e,t,n,G,!0,!1);if(r._setTransform(C),zd(e,t,n,G,!1,!0),l(r.constrainedAxis)){let y=h.cross(r.direction,r.constrainedAxis,c3);h.equalsEpsilon(y,h.ZERO,P.EPSILON6)||(h.dot(y,r.right)<0&&h.negate(y,y),h.cross(y,r.direction,r.up),h.cross(r.direction,r.up,r.right),h.normalize(r.up,r.up),h.normalize(r.right,r.right))}r._setTransform(X),e._globe=L,e._ellipsoid=R;let F=R.maximumRadius;e._rotateFactor=1/F,e._rotateRateRangeAdjustment=F;let A=h.clone(r.positionWC,c3);if(e.enableCollisionDetection&&jj(e,!0),!h.equals(r.positionWC,A)){r._setTransform(V),r.worldToCameraCoordinatesPoint(A,A);let y=h.magnitudeSquared(A);h.magnitudeSquared(r.position)>y&&(h.normalize(r.position,r.position),h.multiplyByScalar(r.position,Math.sqrt(y),r.position));let Z=h.angleBetween(A,r.position),E=h.cross(A,r.position,A);h.normalize(E,E);let I=Fe.fromAxisAngle(E,Z,dpt),w=$.fromQuaternion(I,upt);$.multiplyByVector(w,r.direction,r.direction),$.multiplyByVector(w,r.up,r.up),h.cross(r.direction,r.up,r.right),h.cross(r.right,r.direction,r.up),r._setTransform(X)}}var bpt=new D,ypt=new D,l_e=new bn,d_e=new bn,gpt=new h,xpt=new h;function Hd(e,t,n,i){let r=e._scene.camera,s=bpt;s.x=n.startPosition.x,s.y=0;let a=ypt;a.x=n.endPosition.x,a.y=0;let c=r.getPickRay(s,l_e),d=r.getPickRay(a,d_e),u=0,m,p;r.frustum instanceof rn?(m=c.origin,p=d.origin,h.add(r.direction,m,m),h.add(r.direction,p,p),h.subtract(m,r.position,m),h.subtract(p,r.position,p),h.normalize(m,m),h.normalize(p,p)):(m=c.direction,p=d.direction);let b=h.dot(m,p);b<1&&(u=Math.acos(b)),u=n.startPosition.x>n.endPosition.x?-u:u;let f=e._horizontalRotationAxis;if(l(i)?r.look(i,-u):l(f)?r.look(f,-u):r.lookLeft(u),s.x=0,s.y=n.startPosition.y,a.x=0,a.y=n.endPosition.y,c=r.getPickRay(s,l_e),d=r.getPickRay(a,d_e),u=0,r.frustum instanceof rn?(m=c.origin,p=d.origin,h.add(r.direction,m,m),h.add(r.direction,p,p),h.subtract(m,r.position,m),h.subtract(p,r.position,p),h.normalize(m,m),h.normalize(p,p)):(m=c.direction,p=d.direction),b=h.dot(m,p),b<1&&(u=Math.acos(b)),u=n.startPosition.y>n.endPosition.y?-u:u,i=g(i,f),l(i)){let x=r.direction,_=h.negate(i,gpt),C=h.equalsEpsilon(x,i,P.EPSILON2),V=h.equalsEpsilon(x,_,P.EPSILON2);if(!C&&!V){b=h.dot(x,i);let L=P.acosClamped(b);u>0&&u>L&&(u=L-P.EPSILON4),b=h.dot(x,_),L=P.acosClamped(b),u<0&&-u>L&&(u=-L+P.EPSILON4);let R=h.cross(i,x,xpt);r.look(R,u)}else(C&&u<0||V&&u>0)&&r.look(r.right,-u)}else r.lookUp(u)}function _pt(e){al(e,e.enableRotate,e.rotateEventTypes,ept,e.inertiaSpin,\"_lastInertiaSpinMovement\"),al(e,e.enableZoom,e.zoomEventTypes,V_e,e.inertiaZoom,\"_lastInertiaZoomMovement\"),al(e,e.enableTilt,e.tiltEventTypes,mpt,e.inertiaSpin,\"_lastInertiaTiltMovement\"),al(e,e.enableLook,e.lookEventTypes,Hd)}var Tpt=new M,Spt=new he;function jj(e,t){e._adjustedHeightForTerrain=!0;let n=e._scene,i=n.mode,o=n.globe;if(i===ie.SCENE2D||i===ie.MORPHING)return;let r=n.camera,s=g(o?.ellipsoid,oe.WGS84),a=n.mapProjection,c,d;M.equals(r.transform,M.IDENTITY)||(c=M.clone(r.transform,Tpt),d=h.magnitude(r.position),r._setTransform(M.IDENTITY));let u=Spt;i===ie.SCENE3D?s.cartesianToCartographic(r.position,u):a.unproject(r.position,u);let m=!1;if(u.height<e._minimumCollisionTerrainHeight){let p=e._scene.globeHeight;if(l(p)){let b=p+e.minimumZoomDistance,f=p-e._lastGlobeHeight,x=f/e._lastGlobeHeight;u.height<b&&(t||Math.abs(x)<=.1)&&(u.height=b,i===ie.SCENE3D?s.cartographicToCartesian(u,r.position):a.project(u,r.position),m=!0),t||Math.abs(x)<=.1?e._lastGlobeHeight=p:e._lastGlobeHeight+=f*.1}}l(c)&&(r._setTransform(c),m&&(h.normalize(r.position,r.position),h.negate(r.position,r.direction),h.multiplyByScalar(r.position,Math.max(d,e.minimumZoomDistance),r.position),h.normalize(r.direction,r.direction),h.cross(r.direction,r.up,r.right),h.cross(r.right,r.direction,r.up)))}AF.prototype.onMap=function(){let e=this._scene,t=e.mode,n=e.camera;return t===ie.COLUMBUS_VIEW?Math.abs(n.position.x)-this._maxCoord.x<0&&Math.abs(n.position.y)-this._maxCoord.y<0:!0};var Cpt=new h,Vpt=new h;AF.prototype.update=function(){let e=this._scene,{camera:t,globe:n,mode:i}=e;M.equals(t.transform,M.IDENTITY)?(this._globe=n,this._ellipsoid=l(this._globe)?this._globe.ellipsoid:e.mapProjection.ellipsoid):(this._globe=void 0,this._ellipsoid=oe.UNIT_SPHERE);let{verticalExaggeration:o,verticalExaggerationRelativeHeight:r}=e;this._minimumCollisionTerrainHeight=pr.getHeight(this.minimumCollisionTerrainHeight,o,r),this._minimumPickingTerrainHeight=pr.getHeight(this.minimumPickingTerrainHeight,o,r),this._minimumTrackBallHeight=pr.getHeight(this.minimumTrackBallHeight,o,r),this._cameraUnderground=e.cameraUnderground&&l(this._globe);let s=this._ellipsoid.maximumRadius;this._rotateFactor=1/s,this._rotateRateRangeAdjustment=s,this._adjustedHeightForTerrain=!1;let a=h.clone(t.positionWC,Cpt),c=h.clone(t.directionWC,Vpt);if(i===ie.SCENE2D?Sft(this):i===ie.COLUMBUS_VIEW?(this._horizontalRotationAxis=h.UNIT_Z,zft(this)):i===ie.SCENE3D&&(this._horizontalRotationAxis=void 0,_pt(this)),this.enableCollisionDetection&&!this._adjustedHeightForTerrain){let d=!h.equals(a,t.positionWC)||!h.equals(c,t.directionWC);jj(this,d)}this._aggregator.reset()};AF.prototype.isDestroyed=function(){return!1};AF.prototype.destroy=function(){return this._tweens.removeAll(),this._aggregator=this._aggregator&&this._aggregator.destroy(),me(this)};var MF=AF;var O9i=T(S(),1);var V9i=T(S(),1),NF=`uniform sampler2D colorTexture; uniform sampler2D colorTexture2; uniform vec2 center; uniform float radius; in vec2 v_textureCoordinates; void main() { vec4 color0 = texture(colorTexture, v_textureCoordinates); vec4 color1 = texture(colorTexture2, v_textureCoordinates); float x = length(gl_FragCoord.xy - center) / radius; float t = smoothstep(0.5, 0.8, x); out_FragColor = mix(color0 + color1, color1, t); } `;var Z9i=T(S(),1),kF=`uniform sampler2D colorTexture; uniform float avgLuminance; uniform float threshold; uniform float offset; in vec2 v_textureCoordinates; float key(float avg) { float guess = 1.5 - (1.5 / (avg * 0.1 + 1.0)); return max(0.0, guess) + 0.1; } // See section 9. \"The bright-pass filter\" of Realtime HDR Rendering // http://www.cg.tuwien.ac.at/research/publications/2007/Luksch_2007_RHR/Luksch_2007_RHR-RealtimeHDR%20.pdf void main() { vec4 color = texture(colorTexture, v_textureCoordinates); vec3 xyz = czm_RGBToXYZ(color.rgb); float luminance = xyz.r; float scaledLum = key(avgLuminance) * luminance / avgLuminance; float brightLum = max(scaledLum - threshold, 0.0); float brightness = brightLum / (offset + brightLum); xyz.r = brightness; out_FragColor = vec4(czm_XYZToRGB(xyz), 1.0); } `;function cb(){this._sceneFramebuffer=new RT;let e=.125,t=new Array(6);t[0]=new fo({fragmentShader:Ql,textureScale:e,forcePowerOfTwo:!0,sampleMode:Bd.LINEAR});let n=t[1]=new fo({fragmentShader:kF,uniforms:{avgLuminance:.5,threshold:.25,offset:.1},textureScale:e,forcePowerOfTwo:!0}),i=this;this._delta=1,this._sigma=2,this._blurStep=new D,t[2]=new fo({fragmentShader:Cg,uniforms:{step:function(){return i._blurStep.x=i._blurStep.y=1/n.outputTexture.width,i._blurStep},delta:function(){return i._delta},sigma:function(){return i._sigma},direction:0},textureScale:e,forcePowerOfTwo:!0}),t[3]=new fo({fragmentShader:Cg,uniforms:{step:function(){return i._blurStep.x=i._blurStep.y=1/n.outputTexture.width,i._blurStep},delta:function(){return i._delta},sigma:function(){return i._sigma},direction:1},textureScale:e,forcePowerOfTwo:!0}),t[4]=new fo({fragmentShader:Ql,sampleMode:Bd.LINEAR}),this._uCenter=new D,this._uRadius=void 0,t[5]=new fo({fragmentShader:NF,uniforms:{center:function(){return i._uCenter},radius:function(){return i._uRadius},colorTexture2:function(){return i._sceneFramebuffer.framebuffer.getColorTexture(0)}}}),this._stages=new rl({stages:t});let o=new PT(this),r=t.length;for(let s=0;s<r;++s)t[s]._textureCache=o;this._textureCache=o,this.length=t.length}cb.prototype.get=function(e){return this._stages.get(e)};cb.prototype.getStageByName=function(e){let t=this._stages.length;for(let n=0;n<t;++n){let i=this._stages.get(n);if(i.name===e)return i}};var Lpt=new se,G_e=new D,Zpt=new D,E_e=new M;function Rpt(e,t,n){let i=t.uniformState,o=i.sunPositionWC,r=i.view,s=i.viewProjection,a=i.projection,c=M.computeViewportTransformation(n,0,1,E_e),d=M.multiplyByPoint(r,o,Lpt),u=Wt.pointToGLWindowCoordinates(s,c,o,G_e);d.x+=P.SOLAR_RADIUS;let m=Wt.pointToGLWindowCoordinates(a,c,d,d),p=D.magnitude(D.subtract(m,u,m))*30*2,b=Zpt;b.x=p,b.y=p,e._uCenter=D.clone(u,e._uCenter),e._uRadius=Math.max(b.x,b.y)*.15;let f=t.drawingBufferWidth,x=t.drawingBufferHeight,_=e._stages,C=_.get(0),V=C.outputTexture.width,L=C.outputTexture.height,R=new ze;R.width=V,R.height=L,c=M.computeViewportTransformation(R,0,1,E_e),u=Wt.pointToGLWindowCoordinates(s,c,o,G_e),b.x*=V/f,b.y*=L/x;let G=C.scissorRectangle;G.x=Math.max(u.x-b.x*.5,0),G.y=Math.max(u.y-b.y*.5,0),G.width=Math.min(b.x,f),G.height=Math.min(b.y,x);for(let X=1;X<4;++X)ze.clone(G,_.get(X).scissorRectangle)}cb.prototype.clear=function(e,t,n){this._sceneFramebuffer.clear(e,t,n),this._textureCache.clear(e)};cb.prototype.update=function(e){let t=e.context,n=e.viewport,i=this._sceneFramebuffer;i.update(t,n);let o=i.framebuffer;return this._textureCache.update(t),this._stages.update(t,!1),Rpt(this,t,n),o};cb.prototype.execute=function(e){let t=this._sceneFramebuffer.framebuffer.getColorTexture(0),n=this._stages,i=n.length;n.get(0).execute(e,t);for(let o=1;o<i;++o)n.get(o).execute(e,n.get(o-1).outputTexture)};cb.prototype.copy=function(e,t){if(!l(this._copyColorCommand)){let n=this;this._copyColorCommand=e.createViewportQuadCommand(Ql,{uniformMap:{colorTexture:function(){return n._stages.get(n._stages.length-1).outputTexture}},owner:this})}this._copyColorCommand.framebuffer=t,this._copyColorCommand.execute(e)};cb.prototype.isDestroyed=function(){return!1};cb.prototype.destroy=function(){return this._textureCache.destroy(),this._stages.destroy(),me(this)};var UF=cb;var q9i=T(S(),1);function X_e(){this._cachedShowFrustumsShaders={}}function Gpt(e){let t={},n=e.vertexAttributes;for(let i in n)n.hasOwnProperty(i)&&(t[i]=n[i].index);return t}function Ept(e,t){let n=e.context,i=t,o=i.fragmentShaderSource.clone(),r=[];o.sources=o.sources.map(function(u){u=Ue.replaceMain(u,\"czm_Debug_main\");let m=/out_FragData_(\\d+)/g,p;for(;(p=m.exec(u))!==null;)r.indexOf(p[1])===-1&&r.push(p[1]);return u});let s=r.length,a=\"\";a+=`uniform vec3 debugShowCommandsColor; `,a+=`uniform vec3 debugShowFrustumsColor; `,a+=`void main() { czm_Debug_main(); `;let c;if(s>0)for(c=0;c<s;++c)a+=` out_FragData_${r[c]}.rgb *= debugShowCommandsColor; `,a+=` out_FragData_${r[c]}.rgb *= debugShowFrustumsColor; `;else a+=` out_FragColor.rgb *= debugShowCommandsColor; `,a+=` out_FragColor.rgb *= debugShowFrustumsColor; `;a+=\"}\",o.sources.push(a);let d=Gpt(i);return Ht.fromCache({context:n,vertexShaderSource:i.vertexShaderSource,fragmentShaderSource:o,attributeLocations:d})}var DF=new O;function Xpt(e,t){let n;return l(t.uniformMap)?n=t.uniformMap:n={},l(n.debugShowCommandsColor)||l(n.debugShowFrustumsColor)||(n.debugShowCommandsColor=function(){return e.debugShowCommands?(l(t._debugColor)||(t._debugColor=O.fromRandom()),t._debugColor):O.WHITE},n.debugShowFrustumsColor=function(){return e.debugShowFrustums?(DF.red=t.debugOverlappingFrustums&1?1:0,DF.green=t.debugOverlappingFrustums&2?1:0,DF.blue=t.debugOverlappingFrustums&4?1:0,DF.alpha=1,DF):O.WHITE}),n}var Ipt=new je;X_e.prototype.executeDebugShowFrustumsCommand=function(e,t,n){let i=t.shaderProgram.id,o=this._cachedShowFrustumsShaders[i];l(o)||(o=Ept(e,t.shaderProgram),this._cachedShowFrustumsShaders[i]=o);let r=je.shallowClone(t,Ipt);r.shaderProgram=o,r.uniformMap=Xpt(e,t),r.execute(e.context,n)};var BF=X_e;var oAi=T(S(),1);function NT(e,t,n){this._primitive=e,this._tileIndex=t,this._sampleIndex=n,this._metadata={},this._orientedBoundingBox=new Zn}NT.fromKeyframeNode=function(e,t,n,i){let o=new NT(e,t,n),{spatialNode:r,metadata:s}=i;return o._metadata=Wpt(e,s,n),o._orientedBoundingBox=vpt(e,r,n,o._orientedBoundingBox),o};function Wpt(e,t,n){if(!l(t))return;let{names:i,types:o}=e.provider,r={};for(let s=0;s<i.length;s++){let a=i[s],c=Kt.getComponentCount(o[s]),d=t[s].slice(n*c,(n+1)*c);r[a]=d}return r}var I_e=new h,Ppt=new h;function vpt(e,t,n,i){let o=t.dimensions,r=o.x*o.y,s=Math.floor(n/r),a=n-s*r,c=Math.floor(a/o.x),d=a-c*o.x,u=h.fromElements(d,c,s,I_e),m=h.divideComponents(h.subtract(u,e._paddingBefore,I_e),e.dimensions,Ppt);return e._shape.computeOrientedBoundingBoxForSample(t,e.dimensions,m,i)}Object.defineProperties(NT.prototype,{metadata:{get:function(){return this._metadata}},primitive:{get:function(){return this._primitive}},sampleIndex:{get:function(){return this._sampleIndex}},tileIndex:{get:function(){return this._tileIndex}},orientedBoundingBox:{get:function(){return this._orientedBoundingBox.clone()}}});NT.prototype.hasProperty=function(e){return l(this._metadata[e])};NT.prototype.getNames=function(){return Object.keys(this._metadata)};NT.prototype.getProperty=function(e){return this._metadata[e]};var YF=NT;var rki=T(S(),1);var CMi=T(S(),1);var rMi=T(S(),1);var sAi=T(S(),1),OF=`struct Ray { vec3 pos; vec3 dir; vec3 rawDir; }; #if defined(JITTER) /** * Generate a pseudo-random value for a given 2D screen coordinate. * Similar to https://www.shadertoy.com/view/4djSRW with a modified hashscale. */ float hash(vec2 p) { vec3 p3 = fract(vec3(p.xyx) * 50.0); p3 += dot(p3, p3.yzx + 19.19); return fract((p3.x + p3.y) * p3.z); } #endif float minComponent(in vec3 v) { return min(min(v.x, v.y), v.z); } float maxComponent(in vec3 v) { return max(max(v.x, v.y), v.z); } struct PointJacobianT { vec3 point; mat3 jacobianT; }; `;var cAi=T(S(),1),zF=`// See Intersection.glsl for the definition of intersectScene // See IntersectionUtils.glsl for the definition of nextIntersection // See convertUvToBox.glsl, convertUvToCylinder.glsl, or convertUvToEllipsoid.glsl // for the definition of convertUvToShapeUvSpace. The appropriate function is // selected based on the VoxelPrimitive shape type, and added to the shader in // Scene/VoxelRenderResources.js. // See Octree.glsl for the definitions of TraversalData, SampleData, // traverseOctreeFromBeginning, and traverseOctreeFromExisting // See Megatexture.glsl for the definition of accumulatePropertiesFromMegatexture #define STEP_COUNT_MAX 1000 // Harcoded value because GLSL doesn't like variable length loops #if defined(PICKING_VOXEL) #define ALPHA_ACCUM_MAX 0.1 #else #define ALPHA_ACCUM_MAX 0.98 // Must be > 0.0 and <= 1.0 #endif uniform mat3 u_transformDirectionViewToLocal; uniform vec3 u_cameraPositionUv; uniform float u_stepSize; #if defined(PICKING) uniform vec4 u_pickColor; #endif vec3 getSampleSize(in int level) { vec3 sampleCount = exp2(float(level)) * vec3(u_dimensions); vec3 sampleSizeUv = 1.0 / sampleCount; return scaleShapeUvToShapeSpace(sampleSizeUv); } #define MINIMUM_STEP_SCALAR (0.02) #define SHIFT_FRACTION (0.001) /** * Given a coordinate within a tile, and sample spacings along a ray through * the coordinate, find the distance to the points where the ray entered and * exited the voxel cell, along with the surface normals at those points. * The surface normals are returned in shape space coordinates. */ RayShapeIntersection getVoxelIntersection(in vec3 tileUv, in vec3 sampleSizeAlongRay) { vec3 voxelCoord = tileUv * vec3(u_dimensions); vec3 directions = sign(sampleSizeAlongRay); vec3 positiveDirections = max(directions, 0.0); vec3 entryCoord = mix(ceil(voxelCoord), floor(voxelCoord), positiveDirections); vec3 exitCoord = entryCoord + directions; vec3 distanceFromEntry = -abs((entryCoord - voxelCoord) * sampleSizeAlongRay); float lastEntry = maxComponent(distanceFromEntry); bvec3 isLastEntry = equal(distanceFromEntry, vec3(lastEntry)); vec3 entryNormal = -1.0 * vec3(isLastEntry) * directions; vec4 entry = vec4(entryNormal, lastEntry); vec3 distanceToExit = abs((exitCoord - voxelCoord) * sampleSizeAlongRay); float firstExit = minComponent(distanceToExit); bvec3 isFirstExit = equal(distanceToExit, vec3(firstExit)); vec3 exitNormal = vec3(isFirstExit) * directions; vec4 exit = vec4(exitNormal, firstExit); return RayShapeIntersection(entry, exit); } vec4 getStepSize(in SampleData sampleData, in Ray viewRay, in RayShapeIntersection shapeIntersection, in mat3 jacobianT, in float currentT) { // The Jacobian is computed in a space where the shape spans [-1, 1]. // But the ray is marched in a space where the shape fills [0, 1]. // So we need to scale the Jacobian by"
}