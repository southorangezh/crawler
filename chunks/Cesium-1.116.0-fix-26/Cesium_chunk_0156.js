{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 156,
    "total_chunks": 194,
    "chunk_size": 6825,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.744Z"
  },
  "content": "the tree from the start position TraversalData traversalData; SampleData sampleDatas[SAMPLE_COUNT]; traverseOctreeFromBeginning(pointJacobian.point, traversalData, sampleDatas); vec4 step = getStepSize(sampleDatas[0], viewRayUv, shapeIntersection, pointJacobian.jacobianT, currentT); #if defined(JITTER) float noise = hash(screenCoord); // [0,1] currentT += noise * step.w; positionUv += noise * step.w * viewDirUv; #endif FragmentInput fragmentInput; #if defined(STATISTICS) setStatistics(fragmentInput.metadata.statistics); #endif vec4 colorAccum = vec4(0.0); for (int stepCount = 0; stepCount < STEP_COUNT_MAX; ++stepCount) { // Read properties from the megatexture based on the traversal state Properties properties = accumulatePropertiesFromMegatexture(sampleDatas); // Prepare the custom shader inputs copyPropertiesToMetadata(properties, fragmentInput.metadata); fragmentInput.voxel.positionUv = positionUv; fragmentInput.voxel.positionShapeUv = pointJacobian.point; fragmentInput.voxel.positionUvLocal = sampleDatas[0].tileUv; fragmentInput.voxel.viewDirUv = viewDirUv; fragmentInput.voxel.viewDirWorld = viewDirWorld; fragmentInput.voxel.surfaceNormal = step.xyz; fragmentInput.voxel.travelDistance = step.w; fragmentInput.voxel.stepCount = stepCount; fragmentInput.voxel.tileIndex = sampleDatas[0].megatextureIndex; fragmentInput.voxel.sampleIndex = getSampleIndex(sampleDatas[0].tileUv); // Run the custom shader czm_modelMaterial materialOutput; fragmentMain(fragmentInput, materialOutput); // Sanitize the custom shader output vec4 color = vec4(materialOutput.diffuse, materialOutput.alpha); color.rgb = max(color.rgb, vec3(0.0)); color.a = clamp(color.a, 0.0, 1.0); // Pre-multiplied alpha blend colorAccum += (1.0 - colorAccum.a) * vec4(color.rgb * color.a, color.a); // Stop traversing if the alpha has been fully saturated if (colorAccum.a > ALPHA_ACCUM_MAX) { colorAccum.a = ALPHA_ACCUM_MAX; break; } if (step.w == 0.0) { // Shape is infinitely thin. The ray may have hit the edge of a // foreground voxel. Step ahead slightly to check for more voxels step.w == 0.00001; } // Keep raymarching currentT += step.w; positionUv = viewPosUv + currentT * viewDirUv; // Check if there's more intersections. if (currentT > endT) { #if (INTERSECTION_COUNT == 1) break; #else shapeIntersection = nextIntersection(ix); if (shapeIntersection.entry.w == NO_HIT) { break; } else { // Found another intersection. Resume raymarching there currentT = shapeIntersection.entry.w; endT = shapeIntersection.exit.w; positionUv = viewPosUv + currentT * viewDirUv; } #endif } // Traverse the tree from the current ray position. // This is similar to traverseOctreeFromBeginning but is faster when the ray is in the same tile as the previous step. pointJacobian = convertUvToShapeUvSpaceDerivative(positionUv); traverseOctreeFromExisting(pointJacobian.point, traversalData, sampleDatas); step = getStepSize(sampleDatas[0], viewRayUv, shapeIntersection, pointJacobian.jacobianT, currentT); } // Convert the alpha from [0,ALPHA_ACCUM_MAX] to [0,1] colorAccum.a /= ALPHA_ACCUM_MAX; #if defined(PICKING) // If alpha is 0.0 there is nothing to pick if (colorAccum.a == 0.0) { discard; } out_FragColor = u_pickColor; #elif defined(PICKING_VOXEL) // If alpha is 0.0 there is nothing to pick if (colorAccum.a == 0.0) { discard; } vec2 megatextureId = packIntToVec2(sampleDatas[0].megatextureIndex); vec2 sampleIndex = packIntToVec2(getSampleIndex(sampleDatas[0].tileUv)); out_FragColor = vec4(megatextureId, sampleIndex); #else out_FragColor = colorAccum; #endif } `;var dAi=T(S(),1),HF=`in vec2 position; uniform vec4 u_ndcSpaceAxisAlignedBoundingBox; void main() { vec2 aabbMin = u_ndcSpaceAxisAlignedBoundingBox.xy; vec2 aabbMax = u_ndcSpaceAxisAlignedBoundingBox.zw; vec2 translation = 0.5 * (aabbMax + aabbMin); vec2 scale = 0.5 * (aabbMax - aabbMin); gl_Position = vec4(position * scale + translation, 0.0, 1.0); } `;var mAi=T(S(),1),KF=`/* Intersection defines #define INTERSECTION_COUNT ### */ #define NO_HIT (-czm_infinity) #define INF_HIT (czm_infinity * 0.5) struct RayShapeIntersection { vec4 entry; vec4 exit; }; vec4 intersectionMin(in vec4 intersect0, in vec4 intersect1) { if (intersect0.w == NO_HIT) { return intersect1; } else if (intersect1.w == NO_HIT) { return intersect0; } return (intersect0.w <= intersect1.w) ? intersect0 : intersect1; } vec4 intersectionMax(in vec4 intersect0, in vec4 intersect1) { return (intersect0.w >= intersect1.w) ? intersect0 : intersect1; } RayShapeIntersection intersectIntersections(in Ray ray, in RayShapeIntersection intersect0, in RayShapeIntersection intersect1) { bool missed = (intersect0.entry.w == NO_HIT) || (intersect1.entry.w == NO_HIT) || (intersect0.exit.w < intersect1.entry.w) || (intersect0.entry.w > intersect1.exit.w); if (missed) { vec4 miss = vec4(normalize(ray.dir), NO_HIT); return RayShapeIntersection(miss, miss); } vec4 entry = intersectionMax(intersect0.entry, intersect1.entry); vec4 exit = intersectionMin(intersect0.exit, intersect1.exit); return RayShapeIntersection(entry, exit); } struct Intersections { // Don't access these member variables directly - call the functions instead. // Store an array of ray-surface intersections. Each intersection is composed of: // .xyz for the surface normal at the intersection point // .w for the T value // The scale of the normal encodes the shape intersection type: // length(intersection.xyz) = 1: positive shape entry // length(intersection.xyz) = 2: positive shape exit // length(intersection.xyz) = 3: negative shape entry // length(intersection.xyz) = 4: negative shape exit // INTERSECTION_COUNT is the number of ray-*shape* (volume) intersections, // so we need twice as many to track ray-*surface* intersections vec4 intersections[INTERSECTION_COUNT * 2]; #if (INTERSECTION_COUNT > 1) // Maintain state for future nextIntersection calls int index; int surroundCount; bool surroundIsPositive; #endif }; RayShapeIntersection getFirstIntersection(in Intersections ix) { return RayShapeIntersection(ix.intersections[0], ix.intersections[1]); } vec4 encodeIntersectionType(vec4 intersection, int index, bool entry) { float scale = float(index > 0) * 2.0 + float(!entry) + 1.0; return vec4(intersection.xyz * scale, intersection.w); } // Use defines instead of real functions because WebGL1 cannot access array with non-constant index. #define setIntersection(/*inout Intersections*/ ix, /*int*/ index, /*float*/ t, /*bool*/ positive, /*bool*/ enter) (ix).intersections[(index)] = vec4(0.0, float(!positive) * 2.0 + float(!enter) + 1.0, 0.0, (t)) #define setIntersectionPair(/*inout Intersections*/ ix, /*int*/ index, /*vec2*/ entryExit) (ix).intersections[(index) * 2 + 0] = vec4(0.0, float((index) > 0) * 2.0 + 1.0, 0.0, (entryExit).x); (ix).intersections[(index) * 2 + 1] = vec4(0.0, float((index) > 0) * 2.0"
}