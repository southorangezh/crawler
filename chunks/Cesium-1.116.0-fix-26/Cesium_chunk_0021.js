{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 21,
    "total_chunks": 194,
    "chunk_size": 5862,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.658Z"
  },
  "content": "* @param {bool} comparison A comparison statement * @param {vec3} a Value to return if the comparison is true. * @param {vec3} b Value to return if the comparison is false. * * @returns {vec3} equivalent of comparison ? a : b */ vec4 czm_branchFreeTernary(bool comparison, vec4 a, vec4 b) { float useA = float(comparison); return a * useA + b * (1.0 - useA); } `;var sPt=T(S(),1),dR=` vec4 czm_cascadeColor(vec4 weights) { return vec4(1.0, 0.0, 0.0, 1.0) * weights.x + vec4(0.0, 1.0, 0.0, 1.0) * weights.y + vec4(0.0, 0.0, 1.0, 1.0) * weights.z + vec4(1.0, 0.0, 1.0, 1.0) * weights.w; } `;var cPt=T(S(),1),uR=` uniform vec4 shadowMap_cascadeDistances; float czm_cascadeDistance(vec4 weights) { return dot(shadowMap_cascadeDistances, weights); } `;var dPt=T(S(),1),mR=` uniform mat4 shadowMap_cascadeMatrices[4]; mat4 czm_cascadeMatrix(vec4 weights) { return shadowMap_cascadeMatrices[0] * weights.x + shadowMap_cascadeMatrices[1] * weights.y + shadowMap_cascadeMatrices[2] * weights.z + shadowMap_cascadeMatrices[3] * weights.w; } `;var mPt=T(S(),1),hR=` uniform vec4 shadowMap_cascadeSplits[2]; vec4 czm_cascadeWeights(float depthEye) { // One component is set to 1.0 and all others set to 0.0. vec4 near = step(shadowMap_cascadeSplits[0], vec4(depthEye)); vec4 far = step(depthEye, shadowMap_cascadeSplits[1]); return near * far; } `;var fPt=T(S(),1),fR=`/** * DOC_TBA * * @name czm_columbusViewMorph * @glslFunction */ vec4 czm_columbusViewMorph(vec4 position2D, vec4 position3D, float time) { // Just linear for now. vec3 p = mix(position2D.xyz, position3D.xyz, time); return vec4(p, 1.0); } `;var bPt=T(S(),1),pR=`/** * Compute the atmosphere color, applying Rayleigh and Mie scattering. This * builtin uses automatic uniforms so the atmophere settings are synced with the * state of the Scene, even in other contexts like Model. * * @name czm_computeAtmosphereColor * @glslFunction * * @param {vec3} positionWC Position of the fragment in world coords (low precision) * @param {vec3} lightDirection Light direction from the sun or other light source. * @param {vec3} rayleighColor The Rayleigh scattering color computed by a scattering function * @param {vec3} mieColor The Mie scattering color computed by a scattering function * @param {float} opacity The opacity computed by a scattering function. */ vec4 czm_computeAtmosphereColor( vec3 positionWC, vec3 lightDirection, vec3 rayleighColor, vec3 mieColor, float opacity ) { // Setup the primary ray: from the camera position to the vertex position. vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC; vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC); float cosAngle = dot(cameraToPositionWCDirection, lightDirection); float cosAngleSq = cosAngle * cosAngle; float G = czm_atmosphereMieAnisotropy; float GSq = G * G; // The Rayleigh phase function. float rayleighPhase = 3.0 / (50.2654824574) * (1.0 + cosAngleSq); // The Mie phase function. float miePhase = 3.0 / (25.1327412287) * ((1.0 - GSq) * (cosAngleSq + 1.0)) / (pow(1.0 + GSq - 2.0 * cosAngle * G, 1.5) * (2.0 + GSq)); // The final color is generated by combining the effects of the Rayleigh and Mie scattering. vec3 rayleigh = rayleighPhase * rayleighColor; vec3 mie = miePhase * mieColor; vec3 color = (rayleigh + mie) * czm_atmosphereLightIntensity; return vec4(color, opacity); } `;var gPt=T(S(),1),bR=`/** * Compute atmosphere scattering for the ground atmosphere and fog. This method * uses automatic uniforms so it is always synced with the scene settings. * * @name czm_computeGroundAtmosphereScattering * @glslfunction * * @param {vec3} positionWC The position of the fragment in world coordinates. * @param {vec3} lightDirection The direction of the light to calculate the scattering from. * @param {vec3} rayleighColor The variable the Rayleigh scattering will be written to. * @param {vec3} mieColor The variable the Mie scattering will be written to. * @param {float} opacity The variable the transmittance will be written to. */ void czm_computeGroundAtmosphereScattering(vec3 positionWC, vec3 lightDirection, out vec3 rayleighColor, out vec3 mieColor, out float opacity) { vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC; vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC); czm_ray primaryRay = czm_ray(czm_viewerPositionWC, cameraToPositionWCDirection); float atmosphereInnerRadius = length(positionWC); czm_computeScattering( primaryRay, length(cameraToPositionWC), lightDirection, atmosphereInnerRadius, rayleighColor, mieColor, opacity ); } `;var _Pt=T(S(),1),yR=`/** * Returns a position in model coordinates relative to eye taking into * account the current scene mode: 3D, 2D, or Columbus view. * <p> * This uses standard position attributes, <code>position3DHigh</code>, * <code>position3DLow</code>, <code>position2DHigh</code>, and <code>position2DLow</code>, * and should be used when writing a vertex shader for an {@link Appearance}. * </p> * * @name czm_computePosition * @glslFunction * * @returns {vec4} The position relative to eye. * * @example * vec4 p = czm_computePosition(); * v_positionEC = (czm_modelViewRelativeToEye * p).xyz; * gl_Position = czm_modelViewProjectionRelativeToEye * p; * * @see czm_translateRelativeToEye */ vec4 czm_computePosition(); `;var SPt=T(S(),1),gR=`/** * This function computes the colors contributed by Rayliegh and Mie scattering on a given ray, as well as * the transmittance value for the ray. This function uses automatic uniforms * so the atmosphere settings are always synced with the current scene. * * @name czm_computeScattering * @glslfunction * * @param {czm_ray} primaryRay The ray from the camera to the position. * @param {float} primaryRayLength The length of the primary ray. * @param {vec3} lightDirection The direction of the light to calculate the scattering from. * @param {vec3} rayleighColor The variable"
}