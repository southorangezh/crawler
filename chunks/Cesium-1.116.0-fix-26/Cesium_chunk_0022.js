{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 22,
    "total_chunks": 194,
    "chunk_size": 5765,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.659Z"
  },
  "content": "primaryRay, length(cameraToPositionWC), lightDirection, atmosphereInnerRadius, rayleighColor, mieColor, opacity ); } `;var _Pt=T(S(),1),yR=`/** * Returns a position in model coordinates relative to eye taking into * account the current scene mode: 3D, 2D, or Columbus view. * <p> * This uses standard position attributes, <code>position3DHigh</code>, * <code>position3DLow</code>, <code>position2DHigh</code>, and <code>position2DLow</code>, * and should be used when writing a vertex shader for an {@link Appearance}. * </p> * * @name czm_computePosition * @glslFunction * * @returns {vec4} The position relative to eye. * * @example * vec4 p = czm_computePosition(); * v_positionEC = (czm_modelViewRelativeToEye * p).xyz; * gl_Position = czm_modelViewProjectionRelativeToEye * p; * * @see czm_translateRelativeToEye */ vec4 czm_computePosition(); `;var SPt=T(S(),1),gR=`/** * This function computes the colors contributed by Rayliegh and Mie scattering on a given ray, as well as * the transmittance value for the ray. This function uses automatic uniforms * so the atmosphere settings are always synced with the current scene. * * @name czm_computeScattering * @glslfunction * * @param {czm_ray} primaryRay The ray from the camera to the position. * @param {float} primaryRayLength The length of the primary ray. * @param {vec3} lightDirection The direction of the light to calculate the scattering from. * @param {vec3} rayleighColor The variable the Rayleigh scattering will be written to. * @param {vec3} mieColor The variable the Mie scattering will be written to. * @param {float} opacity The variable the transmittance will be written to. */ void czm_computeScattering( czm_ray primaryRay, float primaryRayLength, vec3 lightDirection, float atmosphereInnerRadius, out vec3 rayleighColor, out vec3 mieColor, out float opacity ) { const float ATMOSPHERE_THICKNESS = 111e3; // The thickness of the atmosphere in meters. const int PRIMARY_STEPS_MAX = 16; // Maximum number of times the ray from the camera to the world position (primary ray) is sampled. const int LIGHT_STEPS_MAX = 4; // Maximum number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray. // Initialize the default scattering amounts to 0. rayleighColor = vec3(0.0); mieColor = vec3(0.0); opacity = 0.0; float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS; vec3 origin = vec3(0.0); // Calculate intersection from the camera to the outer ring of the atmosphere. czm_raySegment primaryRayAtmosphereIntersect = czm_raySphereIntersectionInterval(primaryRay, origin, atmosphereOuterRadius); // Return empty colors if no intersection with the atmosphere geometry. if (primaryRayAtmosphereIntersect == czm_emptyRaySegment) { rayleighColor = vec3(1.0, 0.0, 1.0); return; } // To deal with smaller values of PRIMARY_STEPS (e.g. 4) // we implement a split strategy: sky or horizon. // For performance reasons, instead of a if/else branch // a soft choice is implemented through a weight 0.0 <= w_stop_gt_lprl <= 1.0 float x = 1e-7 * primaryRayAtmosphereIntersect.stop / length(primaryRayLength); // Value close to 0.0: close to the horizon // Value close to 1.0: above in the sky float w_stop_gt_lprl = 0.5 * (1.0 + czm_approximateTanh(x)); // The ray should start from the first intersection with the outer atmopshere, or from the camera position, if it is inside the atmosphere. float start_0 = primaryRayAtmosphereIntersect.start; primaryRayAtmosphereIntersect.start = max(primaryRayAtmosphereIntersect.start, 0.0); // The ray should end at the exit from the atmosphere or at the distance to the vertex, whichever is smaller. primaryRayAtmosphereIntersect.stop = min(primaryRayAtmosphereIntersect.stop, length(primaryRayLength)); // For the number of ray steps, distinguish inside or outside atmosphere (outer space) // (1) from outer space we have to use more ray steps to get a realistic rendering // (2) within atmosphere we need fewer steps for faster rendering float x_o_a = start_0 - ATMOSPHERE_THICKNESS; // ATMOSPHERE_THICKNESS used as an ad-hoc constant, no precise meaning here, only the order of magnitude matters float w_inside_atmosphere = 1.0 - 0.5 * (1.0 + czm_approximateTanh(x_o_a)); int PRIMARY_STEPS = PRIMARY_STEPS_MAX - int(w_inside_atmosphere * 12.0); // Number of times the ray from the camera to the world position (primary ray) is sampled. int LIGHT_STEPS = LIGHT_STEPS_MAX - int(w_inside_atmosphere * 2.0); // Number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray. // Setup for sampling positions along the ray - starting from the intersection with the outer ring of the atmosphere. float rayPositionLength = primaryRayAtmosphereIntersect.start; // (1) Outside the atmosphere: constant rayStepLength // (2) Inside atmosphere: variable rayStepLength to compensate the rough rendering of the smaller number of ray steps float totalRayLength = primaryRayAtmosphereIntersect.stop - rayPositionLength; float rayStepLengthIncrease = w_inside_atmosphere * ((1.0 - w_stop_gt_lprl) * totalRayLength / (float(PRIMARY_STEPS * (PRIMARY_STEPS + 1)) / 2.0)); float rayStepLength = max(1.0 - w_inside_atmosphere, w_stop_gt_lprl) * totalRayLength / max(7.0 * w_inside_atmosphere, float(PRIMARY_STEPS)); vec3 rayleighAccumulation = vec3(0.0); vec3 mieAccumulation = vec3(0.0); vec2 opticalDepth = vec2(0.0); vec2 heightScale = vec2(czm_atmosphereRayleighScaleHeight, czm_atmosphereMieScaleHeight); // Sample positions on the primary ray. for (int i = 0; i < PRIMARY_STEPS_MAX; ++i) { // The loop should be: for (int i = 0; i < PRIMARY_STEPS; ++i) {...} but WebGL1 cannot // loop with non-constant condition, so it"
}