{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 62,
    "total_chunks": 194,
    "chunk_size": 15960,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.683Z"
  },
  "content": "= floor(angle / czm_piOverFour + 0.5) * czm_piOverFour; #endif vec4 clippedPrevWC, clippedPrevEC; bool prevSegmentClipped, prevSegmentCulled; clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC); vec4 clippedNextWC, clippedNextEC; bool nextSegmentClipped, nextSegmentCulled; clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC); bool segmentClipped, segmentCulled; vec4 clippedPositionWC, clippedPositionEC; clipLineSegmentToNearPlane(positionEC.xyz, usePrevious ? prevEC.xyz : nextEC.xyz, clippedPositionWC, segmentClipped, segmentCulled, clippedPositionEC); if (segmentCulled) { return vec4(0.0, 0.0, 0.0, 1.0); } vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy); vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy); // If a segment was culled, we can't use the corresponding direction // computed above. We should never see both of these be true without // \\`segmentCulled\\` above also being true. if (prevSegmentCulled) { directionToPrevWC = -directionToNextWC; } else if (nextSegmentCulled) { directionToNextWC = -directionToPrevWC; } vec2 thisSegmentForwardWC, otherSegmentForwardWC; if (usePrevious) { thisSegmentForwardWC = -directionToPrevWC; otherSegmentForwardWC = directionToNextWC; } else { thisSegmentForwardWC = directionToNextWC; otherSegmentForwardWC = -directionToPrevWC; } vec2 thisSegmentLeftWC = vec2(-thisSegmentForwardWC.y, thisSegmentForwardWC.x); vec2 leftWC = thisSegmentLeftWC; float expandWidth = width * 0.5; // When lines are split at the anti-meridian, the position may be at the // same location as the next or previous position, and we need to handle // that to avoid producing NaNs. if (!czm_equalsEpsilon(prevEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1) && !czm_equalsEpsilon(nextEC.xyz - positionEC.xyz, vec3(0.0), czm_epsilon1)) { vec2 otherSegmentLeftWC = vec2(-otherSegmentForwardWC.y, otherSegmentForwardWC.x); vec2 leftSumWC = thisSegmentLeftWC + otherSegmentLeftWC; float leftSumLength = length(leftSumWC); leftWC = leftSumLength < czm_epsilon6 ? thisSegmentLeftWC : (leftSumWC / leftSumLength); // The sine of the angle between the two vectors is given by the formula // |a x b| = |a||b|sin(theta) // which is // float sinAngle = length(cross(vec3(leftWC, 0.0), vec3(-thisSegmentForwardWC, 0.0))); // Because the z components of both vectors are zero, the x and y coordinate will be zero. // Therefore, the sine of the angle is just the z component of the cross product. vec2 u = -thisSegmentForwardWC; vec2 v = leftWC; float sinAngle = abs(u.x * v.y - u.y * v.x); expandWidth = clamp(expandWidth / sinAngle, 0.0, width * 2.0); } vec2 offset = leftWC * expandDirection * expandWidth * czm_pixelRatio; return vec4(clippedPositionWC.xy + offset, -clippedPositionWC.z, 1.0) * (czm_projection * clippedPositionEC).w; } vec4 getPolylineWindowCoordinates(vec4 position, vec4 previous, vec4 next, float expandDirection, float width, bool usePrevious, out float angle) { vec4 positionEC = czm_modelViewRelativeToEye * position; vec4 prevEC = czm_modelViewRelativeToEye * previous; vec4 nextEC = czm_modelViewRelativeToEye * next; return getPolylineWindowCoordinatesEC(positionEC, prevEC, nextEC, expandDirection, width, usePrevious, angle); } `;var wO=`${dd} ${OE}`,sPe=YE;Ut.isInternetExplorer()||(wO=`#define CLIP_POLYLINE ${wO}`);function Sx(e){e=g(e,g.EMPTY_OBJECT);let t=!0,n=!1,i=Sx.VERTEX_FORMAT;this.material=void 0,this.translucent=t,this._vertexShaderSource=g(e.vertexShaderSource,wO),this._fragmentShaderSource=g(e.fragmentShaderSource,sPe),this._renderState=eo.getDefaultRenderState(t,n,e.renderState),this._closed=n,this._vertexFormat=i}Object.defineProperties(Sx.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}},vertexFormat:{get:function(){return this._vertexFormat}}});Sx.VERTEX_FORMAT=Pe.POSITION_AND_ST;Sx.prototype.getFragmentShaderSource=eo.prototype.getFragmentShaderSource;Sx.prototype.isTranslucent=eo.prototype.isTranslucent;Sx.prototype.getRenderState=eo.prototype.getRenderState;var Br=Sx;var xjt=T(S(),1);var sjt=T(S(),1),zE=`in vec3 position3DHigh; in vec3 position3DLow; in vec3 prevPosition3DHigh; in vec3 prevPosition3DLow; in vec3 nextPosition3DHigh; in vec3 nextPosition3DLow; in vec2 expandAndWidth; in vec2 st; in float batchId; out float v_width; // @uranus change \\u65B0\\u589E\\u53D8\\u91CF\\u7528\\u6765\\u8BA1\\u7B97\\u8FB9\\u7F18\\u6297\\u952F\\u9F7F out float v_aa_width; out float v_aa_out; out vec2 v_st; out float v_polylineAngle; void main() { // @uranus change: \\u8BA1\\u7B97\\u5916\\u6269\\u53D8\\u91CF v_aa_out = 1.0 / czm_pixelRatio; // \\u7EBF\\u6BB5\\u9876\\u70B9\\u5916\\u6269\\u4E24\\u4E2A\\u50CF\\u7D20 float width_out = v_aa_out * 2.0; // @uranus change end float expandDir = expandAndWidth.x; // @uranus change \\u5BBD\\u5EA6\\u5916\\u6269 float width = abs(expandAndWidth.y) + 0.5 + width_out; bool usePrev = expandAndWidth.y < 0.0; vec4 p = czm_computePosition(); vec4 prev = czm_computePrevPosition(); vec4 next = czm_computeNextPosition(); float angle; vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle); gl_Position = czm_viewportOrthographic * positionWC; // @uranus change: \\u8BA1\\u7B97\\u5916\\u6269\\u53D8\\u91CF v_width = width - width_out; v_aa_width = width; // @uranus change end v_st.s = st.s; v_st.t = czm_writeNonPerspective(st.t, gl_Position.w); v_polylineAngle = angle; } `;var cjt=T(S(),1),Cx=`#ifdef VECTOR_TILE uniform vec4 u_highlightColor; #endif in vec2 v_st; // @uranus change \\u65B0\\u589E\\u53D8\\u91CF\\u7528\\u6765\\u8BA1\\u7B97\\u8FB9\\u7F18\\u6297\\u952F\\u9F7F in float v_aa_width; in float v_aa_out; void main() { czm_materialInput materialInput; vec2 st = v_st; st.t = czm_readNonPerspective(st.t, gl_FragCoord.w); // @uranus change start: \\u8FB9\\u7F18\\u6297\\u952F\\u9F7F\\u8BA1\\u7B97\\uFF0C\\u9700\\u8981\\u628A\\u7EB9\\u7406\\u5BBD\\u5EA6\\u7F29\\u5C0F\\uFF0C\\u8FB9\\u7F18\\u586B\\u5145 float width_out = v_aa_out * 2.0; // \\u8FB9\\u7F18\\u6297\\u952F\\u9F7F\\u989D\\u5916\\u589E\\u52A0\\u7684\\u5BBD\\u5EA6 float m_width = v_aa_width - width_out; // \\u5B9E\\u9645\\u7EBF\\u6BB5\\u5BBD\\u5EA6 float dist = (abs(st.t - 0.5)) * v_aa_width * 2.0; // t - 0.5 \\u8DDD\\u79BB\\u4E2D\\u5FC3\\u70B9\\u7684\\u4F4D\\u7F6E\\uFF08\\u4E24\\u500D\\u5316\\uFF09 float t = (st.t * v_aa_width - v_aa_out) / m_width; // [-1, x - 1] st.t = clamp(t, 0.0, 1.0); // \\u5B9E\\u9645\\u7EB9\\u7406\\u5BBD\\u5EA6 float alpha = clamp((v_aa_width - dist - (1.0 / czm_pixelRatio)) / width_out, 0.0, 1.0); // \\u6297\\u952F\\u9F7F\\u586B\\u5145\\u900F\\u660E\\u5EA6 // @uranus change end materialInput.s = st.s; materialInput.st = st; materialInput.str = vec3(st, 0.0); czm_material material = czm_getMaterial(materialInput); out_FragColor = vec4(material.diffuse + material.emission, material.alpha); #ifdef VECTOR_TILE out_FragColor *= u_highlightColor; #endif // @uranus change: \\u8FB9\\u7F18\\u6297\\u952F\\u9F7F\\u900F\\u660E\\u5EA6\\u8BA1\\u7B97 out_FragColor.a *= alpha; czm_writeLogDepth(); } `;var FO=`${dd} ${zE}`,aPe=Cx;Ut.isInternetExplorer()||(FO=`#define CLIP_POLYLINE ${FO}`);function Vx(e){e=g(e,g.EMPTY_OBJECT);let t=g(e.translucent,!0),n=!1,i=Vx.VERTEX_FORMAT;this.material=l(e.material)?e.material:ki.fromType(ki.ColorType),this.translucent=t,this._vertexShaderSource=g(e.vertexShaderSource,FO),this._fragmentShaderSource=g(e.fragmentShaderSource,aPe),this._renderState=eo.getDefaultRenderState(t,n,e.renderState),this._closed=n,this._vertexFormat=i}Object.defineProperties(Vx.prototype,{vertexShaderSource:{get:function(){let e=this._vertexShaderSource;return this.material.shaderSource.search(/in\\s+float\\s+v_polylineAngle;/g)!==-1&&(e=`#define POLYLINE_DASH ${e}`),e}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}},vertexFormat:{get:function(){return this._vertexFormat}}});Vx.VERTEX_FORMAT=Pe.POSITION_AND_ST;Vx.prototype.getFragmentShaderSource=eo.prototype.getFragmentShaderSource;Vx.prototype.isTranslucent=eo.prototype.isTranslucent;Vx.prototype.getRenderState=eo.prototype.getRenderState;var ta=Vx;function Zp(e){e=g(e,g.EMPTY_OBJECT),this.geometryInstances=e.geometryInstances,this._hasPerInstanceColors=!0;let t=e.appearance;l(t)||(t=new ta),this.appearance=t,this.show=g(e.show,!0),this.classificationType=g(e.classificationType,Un.BOTH),this.debugShowBoundingVolume=g(e.debugShowBoundingVolume,!1),this._debugShowShadowVolume=g(e.debugShowShadowVolume,!1),this._primitiveOptions={geometryInstances:void 0,appearance:void 0,vertexCacheOptimize:!1,interleave:g(e.interleave,!1),releaseGeometryInstances:g(e.releaseGeometryInstances,!0),allowPicking:g(e.allowPicking,!0),asynchronous:g(e.asynchronous,!0),compressVertices:!1,_createShaderProgramFunction:void 0,_createCommandsFunction:void 0,_updateAndQueueCommandsFunction:void 0},this._zIndex=void 0,this._ready=!1,this._primitive=void 0,this._sp=void 0,this._sp2D=void 0,this._spMorph=void 0,this._renderState=pie(!1),this._renderState3DTiles=pie(!0),this._renderStateMorph=Ne.fromCache({cull:{enabled:!0,face:mi.FRONT},depthTest:{enabled:!0},blending:un.PRE_MULTIPLIED_ALPHA_BLEND,depthMask:!1})}Object.defineProperties(Zp.prototype,{interleave:{get:function(){return this._primitiveOptions.interleave}},releaseGeometryInstances:{get:function(){return this._primitiveOptions.releaseGeometryInstances}},allowPicking:{get:function(){return this._primitiveOptions.allowPicking}},asynchronous:{get:function(){return this._primitiveOptions.asynchronous}},ready:{get:function(){return this._ready}},debugShowShadowVolume:{get:function(){return this._debugShowShadowVolume}}});Zp.initializeTerrainHeights=function(){return ai.initialize()};function cPe(e,t,n){let i=t.context,o=e._primitive,r=o._attributeLocations,s=o._batchTable.getVertexShaderCallback()(BE);s=Rn._appendShowToShader(o,s),s=Rn._appendDistanceDisplayConditionToShader(o,s),s=Rn._modifyShaderPosition(e,s,t.scene3DOnly);let a=o._batchTable.getVertexShaderCallback()(DE);a=Rn._appendShowToShader(o,a),a=Rn._appendDistanceDisplayConditionToShader(o,a),a=Rn._modifyShaderPosition(e,a,t.scene3DOnly);let c=o._batchTable.getVertexShaderCallback()(kE),d=[`GLOBE_MINIMUM_ALTITUDE ${t.mapProjection.ellipsoid.minimumRadius.toFixed(1)}`],u=\"\",m=\"\";l(n.material)?(m=l(n.material)?n.material.shaderSource:\"\",m.search(/in\\s+float\\s+v_polylineAngle;/g)!==-1&&d.push(\"ANGLE_VARYING\"),m.search(/in\\s+float\\s+v_width;/g)!==-1&&d.push(\"WIDTH_VARYING\")):u=\"PER_INSTANCE_COLOR\",d.push(u);let p=e.debugShowShadowVolume?[\"DEBUG_SHOW_VOLUME\",u]:[u],b=new Ue({defines:d,sources:[s]}),f=new Ue({defines:p,sources:[m,c]});e._sp=Ht.replaceCache({context:i,shaderProgram:o._sp,vertexShaderSource:b,fragmentShaderSource:f,attributeLocations:r});let x=i.shaderCache.getDerivedShaderProgram(e._sp,\"2dColor\");if(!l(x)){let C=new Ue({defines:d.concat([\"COLUMBUS_VIEW_2D\"]),sources:[s]});x=i.shaderCache.createDerivedShaderProgram(e._sp,\"2dColor\",{context:i,shaderProgram:e._sp2D,vertexShaderSource:C,fragmentShaderSource:f,attributeLocations:r})}e._sp2D=x;let _=i.shaderCache.getDerivedShaderProgram(e._sp,\"MorphColor\");if(!l(_)){let C=new Ue({defines:d.concat([`MAX_TERRAIN_HEIGHT ${ai._defaultMaxTerrainHeight.toFixed(1)}`]),sources:[a]});c=o._batchTable.getVertexShaderCallback()(UE);let V=new Ue({defines:p,sources:[m,c]});_=i.shaderCache.createDerivedShaderProgram(e._sp,\"MorphColor\",{context:i,shaderProgram:e._spMorph,vertexShaderSource:C,fragmentShaderSource:V,attributeLocations:r})}e._spMorph=_}function pie(e){return Ne.fromCache({cull:{enabled:!0},blending:un.PRE_MULTIPLIED_ALPHA_BLEND,depthMask:!1,stencilTest:{enabled:e,frontFunction:vn.EQUAL,frontOperation:{fail:dt.KEEP,zFail:dt.KEEP,zPass:dt.KEEP},backFunction:vn.EQUAL,backOperation:{fail:dt.KEEP,zFail:dt.KEEP,zPass:dt.KEEP},reference:Mt.CESIUM_3D_TILE_MASK,mask:Mt.CESIUM_3D_TILE_MASK}})}function lPe(e,t,n,i,o,r){let s=e._primitive,a=s._va.length;o.length=a,r.length=a;let d=t instanceof Br?{}:n._uniforms,u=s._batchTable.getUniformMapCallback()(d);for(let m=0;m<a;m++){let p=s._va[m],b=o[m];l(b)||(b=o[m]=new je({owner:e,primitiveType:s._primitiveType})),b.vertexArray=p,b.renderState=e._renderState,b.shaderProgram=e._sp,b.uniformMap=u,b.pass=Ze.TERRAIN_CLASSIFICATION,b.pickId=\"czm_batchTable_pickColor(v_endPlaneNormalEcAndBatchId.w)\";let f=je.shallowClone(b,b.derivedCommands.tileset);f.renderState=e._renderState3DTiles,f.pass=Ze.CESIUM_3D_TILE_CLASSIFICATION,b.derivedCommands.tileset=f;let x=je.shallowClone(b,b.derivedCommands.color2D);x.shaderProgram=e._sp2D,b.derivedCommands.color2D=x;let _=je.shallowClone(f,f.derivedCommands.color2D);_.shaderProgram=e._sp2D,f.derivedCommands.color2D=_;let C=je.shallowClone(b,b.derivedCommands.colorMorph);C.renderState=e._renderStateMorph,C.shaderProgram=e._spMorph,C.pickId=\"czm_batchTable_pickColor(v_batchId)\",b.derivedCommands.colorMorph=C}}function bie(e,t,n,i,o,r,s){n.mode===ie.MORPHING?t=t.derivedCommands.colorMorph:n.mode!==ie.SCENE3D&&(t=t.derivedCommands.color2D),t.modelMatrix=i,t.boundingVolume=r,t.cull=o,t.debugShowBoundingVolume=s,n.commandList.push(t)}function dPe(e,t,n,i,o,r,s){let a=e._primitive;Rn._updateBoundingVolumes(a,t,o);let c;t.mode===ie.SCENE3D?c=a._boundingSphereWC:t.mode===ie.COLUMBUS_VIEW?c=a._boundingSphereCV:t.mode===ie.SCENE2D&&l(a._boundingSphere2D)?c=a._boundingSphere2D:l(a._boundingSphereMorph)&&(c=a._boundingSphereMorph);let d=t.mode===ie.MORPHING,u=e.classificationType,m=u!==Un.CESIUM_3D_TILE,p=u!==Un.TERRAIN&&!d,b,f=t.passes;if(f.render||f.pick&&a.allowPicking){let x=n.length;for(let _=0;_<x;++_){let C=c[_];m&&(b=n[_],bie(e,b,t,o,r,C,s)),p&&(b=n[_].derivedCommands.tileset,bie(e,b,t,o,r,C,s))}}}Zp.prototype.update=function(e){if(!l(this._primitive)&&!l(this.geometryInstances))return;if(!ai.initialized){Zp.initializeTerrainHeights();return}let t,n=this,i=this._primitiveOptions;if(!l(this._primitive)){let o=Array.isArray(this.geometryInstances)?this.geometryInstances:[this.geometryInstances],r=o.length,s=new Array(r),a;for(t=0;t<r;++t)if(a=o[t].attributes,!l(a)||!l(a.color)){this._hasPerInstanceColors=!1;break}for(t=0;t<r;++t){let c=o[t];a={};let d=c.attributes;for(let u in d)d.hasOwnProperty(u)&&(a[u]=d[u]);l(a.width)||(a.width=new nc({componentDatatype:Q.UNSIGNED_BYTE,componentsPerAttribute:1,value:[c.geometry.width]})),c.geometry._scene3DOnly=e.scene3DOnly,Tx.setProjectionAndEllipsoid(c.geometry,e.mapProjection),s[t]=new Vt({geometry:c.geometry,attributes:a,id:c.id,pickPrimitive:n})}i.geometryInstances=s,i.appearance=this.appearance,i._createShaderProgramFunction=function(c,d,u){cPe(n,d,u)},i._createCommandsFunction=function(c,d,u,m,p,b,f){lPe(n,d,u,m,b,f)},i._updateAndQueueCommandsFunction=function(c,d,u,m,p,b,f,x){dPe(n,d,u,m,p,b,f)},this._primitive=new Rn(i)}if(this.appearance instanceof Br&&!this._hasPerInstanceColors)throw new fe(\"All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.\");this._primitive.appearance=this.appearance,this._primitive.show=this.show,this._primitive.debugShowBoundingVolume=this.debugShowBoundingVolume,this._primitive.update(e),e.afterRender.push(()=>{!this._ready&&l(this._primitive)&&this._primitive.ready&&(this._ready=!0,this.releaseGeometryInstances&&(this.geometryInstances=void 0))})};Zp.prototype.getGeometryInstanceAttributes=function(e){return this._primitive.getGeometryInstanceAttributes(e)};Zp.isSupported=function(e){return e.frameState.context.depthTexture};Zp.prototype.isDestroyed=function(){return!1};Zp.prototype.destroy=function(){return this._primitive=this._primitive&&this._primitive.destroy(),this._sp=this._sp&&this._sp.destroy(),this._sp2D=void 0,this._spMorph=void 0,me(this)};var"
}