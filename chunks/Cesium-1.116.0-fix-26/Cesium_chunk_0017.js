{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 17,
    "total_chunks": 194,
    "chunk_size": 5180,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.656Z"
  },
  "content": "the fragment to the eye in eye coordinates. The magnitude is the distance in meters from the fragment to the eye. * @property {float} height The height of the terrain in meters above or below the WGS84 ellipsoid. Only available for globe materials. * @property {float} slope The slope of the terrain in radians. 0 is flat; pi/2 is vertical. Only available for globe materials. * @property {float} aspect The aspect of the terrain in radians. 0 is East, pi/2 is North, pi is West, 3pi/2 is South. Only available for globe materials. */ struct czm_materialInput { float s; vec2 st; vec3 str; vec3 normalEC; mat3 tangentToEyeMatrix; vec3 positionToEyeEC; float height; float slope; float aspect; }; `;var _2t=T(S(),1),YZ=`/** * Struct for representing a material for a {@link Model}. The model * rendering pipeline will pass this struct between material, custom shaders, * and lighting stages. This is not to be confused with {@link czm_material} * which is used by the older Fabric materials system, although they are similar. * <p> * All color values (diffuse, specular, emissive) are in linear color space. * </p> * * @name czm_modelMaterial * @glslStruct * * @property {vec3} diffuse Incoming light that scatters evenly in all directions. * @property {float} alpha Alpha of this material. 0.0 is completely transparent; 1.0 is completely opaque. * @property {vec3} specular Color of reflected light at normal incidence in PBR materials. This is sometimes referred to as f0 in the literature. * @property {float} roughness A number from 0.0 to 1.0 representing how rough the surface is. Values near 0.0 produce glossy surfaces, while values near 1.0 produce rough surfaces. * @property {vec3} normalEC Surface's normal in eye coordinates. It is used for effects such as normal mapping. The default is the surface's unmodified normal. * @property {float} occlusion Ambient occlusion recieved at this point on the material. 1.0 means fully lit, 0.0 means fully occluded. * @property {vec3} emissive Light emitted by the material equally in all directions. The default is vec3(0.0), which emits no light. */ struct czm_modelMaterial { vec3 diffuse; float alpha; vec3 specular; float roughness; vec3 normalEC; float occlusion; vec3 emissive; }; `;var S2t=T(S(),1),OZ=`/** * Struct for representing the output of a custom vertex shader. * * @name czm_modelVertexOutput * @glslStruct * * @see {@link CustomShader} * @see {@link Model} * * @property {vec3} positionMC The position of the vertex in model coordinates * @property {float} pointSize A custom value for gl_PointSize. This is only used for point primitives. */ struct czm_modelVertexOutput { vec3 positionMC; float pointSize; }; `;var V2t=T(S(),1),zZ=`/** * Parameters for {@link czm_pbrLighting} * * @name czm_material * @glslStruct * * @property {vec3} diffuseColor the diffuse color of the material for the lambert term of the rendering equation * @property {float} roughness a value from 0.0 to 1.0 that indicates how rough the surface of the material is. * @property {vec3} f0 The reflectance of the material at normal incidence */ struct czm_pbrParameters { vec3 diffuseColor; float roughness; vec3 f0; }; `;var Z2t=T(S(),1),HZ=`/** * DOC_TBA * * @name czm_ray * @glslStruct */ struct czm_ray { vec3 origin; vec3 direction; }; `;var G2t=T(S(),1),KZ=`/** * DOC_TBA * * @name czm_raySegment * @glslStruct */ struct czm_raySegment { float start; float stop; }; /** * DOC_TBA * * @name czm_emptyRaySegment * @glslConstant */ const czm_raySegment czm_emptyRaySegment = czm_raySegment(-czm_infinity, -czm_infinity); /** * DOC_TBA * * @name czm_fullRaySegment * @glslConstant */ const czm_raySegment czm_fullRaySegment = czm_raySegment(0.0, czm_infinity); `;var X2t=T(S(),1),JZ=`struct czm_shadowParameters { #ifdef USE_CUBE_MAP_SHADOW vec3 texCoords; #else vec2 texCoords; #endif float depthBias; float depth; float nDotL; vec2 texelStepSize; float normalShadingSmooth; float darkness; }; `;var W2t=T(S(),1),QZ=`/** * Converts an HSB color (hue, saturation, brightness) to RGB * HSB <-> RGB conversion with minimal branching: {@link http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl} * * @name czm_HSBToRGB * @glslFunction * * @param {vec3} hsb The color in HSB. * * @returns {vec3} The color in RGB. * * @example * vec3 hsb = czm_RGBToHSB(rgb); * hsb.z *= 0.1; * rgb = czm_HSBToRGB(hsb); */ const vec4 K_HSB2RGB = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 czm_HSBToRGB(vec3 hsb) { vec3 p = abs(fract(hsb.xxx + K_HSB2RGB.xyz) * 6.0 - K_HSB2RGB.www); return hsb.z * mix(K_HSB2RGB.xxx, clamp(p - K_HSB2RGB.xxx, 0.0, 1.0), hsb.y); } `;var v2t=T(S(),1),jZ=`/** * Converts an HSL color (hue, saturation, lightness) to RGB * HSL <-> RGB conversion: {@link http://www.chilliant.com/rgb2hsv.html} * * @name czm_HSLToRGB * @glslFunction * * @param {vec3} rgb The color in HSL. * * @returns {vec3} The color in RGB. * * @example * vec3 hsl = czm_RGBToHSL(rgb); * hsl.z *= 0.1; * rgb = czm_HSLToRGB(hsl); */ vec3 hueToRGB(float hue) { float r = abs(hue * 6.0 - 3.0) - 1.0; float g = 2.0 - abs(hue * 6.0 - 2.0); float b = 2.0 - abs(hue * 6.0 - 4.0); return clamp(vec3(r, g, b), 0.0, 1.0); } vec3 czm_HSLToRGB(vec3 hsl) { vec3 rgb ="
}