{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 46,
    "total_chunks": 194,
    "chunk_size": 9409,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.673Z"
  },
  "content": "= st; gl_Position = czm_modelViewProjectionRelativeToEye * p; } `;var G3t=T(S(),1);var y3t=T(S(),1);var d3t=T(S(),1);var VEe={ADD:ne.FUNC_ADD,SUBTRACT:ne.FUNC_SUBTRACT,REVERSE_SUBTRACT:ne.FUNC_REVERSE_SUBTRACT,MIN:ne.MIN,MAX:ne.MAX},La=Object.freeze(VEe);var h3t=T(S(),1);var LEe={ZERO:ne.ZERO,ONE:ne.ONE,SOURCE_COLOR:ne.SRC_COLOR,ONE_MINUS_SOURCE_COLOR:ne.ONE_MINUS_SRC_COLOR,DESTINATION_COLOR:ne.DST_COLOR,ONE_MINUS_DESTINATION_COLOR:ne.ONE_MINUS_DST_COLOR,SOURCE_ALPHA:ne.SRC_ALPHA,ONE_MINUS_SOURCE_ALPHA:ne.ONE_MINUS_SRC_ALPHA,DESTINATION_ALPHA:ne.DST_ALPHA,ONE_MINUS_DESTINATION_ALPHA:ne.ONE_MINUS_DST_ALPHA,CONSTANT_COLOR:ne.CONSTANT_COLOR,ONE_MINUS_CONSTANT_COLOR:ne.ONE_MINUS_CONSTANT_COLOR,CONSTANT_ALPHA:ne.CONSTANT_ALPHA,ONE_MINUS_CONSTANT_ALPHA:ne.ONE_MINUS_CONSTANT_ALPHA,SOURCE_ALPHA_SATURATE:ne.SRC_ALPHA_SATURATE},xo=Object.freeze(LEe);var ZEe={DISABLED:Object.freeze({enabled:!1}),ALPHA_BLEND:Object.freeze({enabled:!0,equationRgb:La.ADD,equationAlpha:La.ADD,functionSourceRgb:xo.SOURCE_ALPHA,functionSourceAlpha:xo.ONE,functionDestinationRgb:xo.ONE_MINUS_SOURCE_ALPHA,functionDestinationAlpha:xo.ONE_MINUS_SOURCE_ALPHA}),PRE_MULTIPLIED_ALPHA_BLEND:Object.freeze({enabled:!0,equationRgb:La.ADD,equationAlpha:La.ADD,functionSourceRgb:xo.ONE,functionSourceAlpha:xo.ONE,functionDestinationRgb:xo.ONE_MINUS_SOURCE_ALPHA,functionDestinationAlpha:xo.ONE_MINUS_SOURCE_ALPHA}),ADDITIVE_BLEND:Object.freeze({enabled:!0,equationRgb:La.ADD,equationAlpha:La.ADD,functionSourceRgb:xo.SOURCE_ALPHA,functionSourceAlpha:xo.ONE,functionDestinationRgb:xo.ONE,functionDestinationAlpha:xo.ONE})},un=Object.freeze(ZEe);var _3t=T(S(),1);var REe={FRONT:ne.FRONT,BACK:ne.BACK,FRONT_AND_BACK:ne.FRONT_AND_BACK},mi=Object.freeze(REe);function OS(e){e=g(e,g.EMPTY_OBJECT),this.material=e.material,this.translucent=g(e.translucent,!0),this._vertexShaderSource=e.vertexShaderSource,this._fragmentShaderSource=e.fragmentShaderSource,this._renderState=e.renderState,this._closed=g(e.closed,!1)}Object.defineProperties(OS.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}}});OS.prototype.getFragmentShaderSource=function(){let e=[];return this.flat&&e.push(\"#define FLAT\"),this.faceForward&&e.push(\"#define FACE_FORWARD\"),l(this.material)&&e.push(this.material.shaderSource),e.push(this.fragmentShaderSource),e.join(` `)};OS.prototype.isTranslucent=function(){return l(this.material)&&this.material.isTranslucent()||!l(this.material)&&this.translucent};OS.prototype.getRenderState=function(){let e=this.isTranslucent(),t=Oe(this.renderState,!1);return e?(t.depthMask=!1,t.blending=un.ALPHA_BLEND):t.depthMask=!0,t};OS.getDefaultRenderState=function(e,t,n){let i={depthTest:{enabled:!0}};return e&&(i.depthMask=!1,i.blending=un.ALPHA_BLEND),t&&(i.cull={enabled:!0,face:mi.BACK}),l(n)&&(i=Ct(n,i,!0)),i};var eo=OS;var KBt=T(S(),1);var X3t=T(S(),1),tE=`uniform sampler2D image; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec4 rampColor = texture(image, vec2(materialInput.aspect / (2.0 * czm_pi), 0.5)); rampColor = czm_gammaCorrect(rampColor); material.diffuse = rampColor.rgb; material.alpha = rampColor.a; return material; } `;var W3t=T(S(),1),nE=`uniform sampler2D image; uniform float strength; uniform vec2 repeat; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st; vec2 centerPixel = fract(repeat * st); float centerBump = texture(image, centerPixel).channel; float imageWidth = float(imageDimensions.x); vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0))); float rightBump = texture(image, rightPixel).channel; float imageHeight = float(imageDimensions.y); vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight))); float topBump = texture(image, leftPixel).channel; vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0))); vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace; material.normal = normalEC; material.diffuse = vec3(0.01); return material; } `;var v3t=T(S(),1),iE=`uniform vec4 lightColor; uniform vec4 darkColor; uniform vec2 repeat; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st; // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0); // 0.0 or 1.0 // Find the distance from the closest separator (region between two colors) float scaledWidth = fract(repeat.s * st.s); scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5)); float scaledHeight = fract(repeat.t * st.t); scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5)); float value = min(scaledWidth, scaledHeight); vec4 currentColor = mix(lightColor, darkColor, b); vec4 color = czm_antialias(lightColor, darkColor, currentColor, value, 0.03); color = czm_gammaCorrect(color); material.diffuse = color.rgb; material.alpha = color.a; return material; } `;var F3t=T(S(),1),oE=`uniform vec4 lightColor; uniform vec4 darkColor; uniform vec2 repeat; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); // From Stefan Gustavson's Procedural Textures in GLSL in OpenGL Insights float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5)); // 0.0 or 1.0 vec4 color = mix(lightColor, darkColor, b); color = czm_gammaCorrect(color); material.diffuse = color.rgb; material.alpha = color.a; return material; } `;var M3t=T(S(),1),rE=`uniform sampler2D heights; uniform sampler2D colors; // This material expects heights to be sorted from lowest to highest. float getHeight(int idx, float invTexSize) { vec2 uv = vec2((float(idx) + 0.5) * invTexSize, 0.5); #ifdef OES_texture_float return texture(heights, uv).x; #else return czm_unpackFloat(texture(heights, uv)); #endif } czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); float height = materialInput.height; float invTexSize = 1.0 / float(heightsDimensions.x); float minHeight = getHeight(0, invTexSize); float maxHeight = getHeight(heightsDimensions.x - 1, invTexSize); // early-out when outside the height range if (height < minHeight || height > maxHeight) { material.diffuse = vec3(0.0); material.alpha = 0.0; return material; } // Binary search to find heights above and below. int idxBelow = 0; int idxAbove = heightsDimensions.x; float heightBelow = minHeight; float heightAbove = maxHeight; // while loop not allowed, so use for loop with max iterations. // maxIterations of 16 supports a texture size up to 65536 (2^16). const int maxIterations = 16; for (int i = 0; i < maxIterations; i++) { if (idxBelow >= idxAbove - 1) { break; } int idxMid = (idxBelow + idxAbove) / 2; float heightTex = getHeight(idxMid, invTexSize); if (height > heightTex) { idxBelow = idxMid; heightBelow = heightTex; } else { idxAbove = idxMid; heightAbove = heightTex; } } float lerper = heightBelow == heightAbove ? 1.0 : (height - heightBelow) / (heightAbove - heightBelow); vec2 colorUv = vec2(invTexSize * (float(idxBelow) + 0.5 + lerper), 0.5); vec4 color = texture(colors, colorUv); // undo preumultiplied alpha if (color.a > 0.0) { color.rgb /= color.a; } color.rgb = czm_gammaCorrect(color.rgb); material.diffuse = color.rgb; material.alpha = color.a; return material; } `;var k3t=T(S(),1),sE=`uniform vec4 color; uniform float spacing; uniform float width; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); float distanceToContour = mod(materialInput.height, spacing); #if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives)) float dxc = abs(dFdx(materialInput.height)); float dyc = abs(dFdy(materialInput.height)); float dF = max(dxc, dyc) * czm_pixelRatio * width; float alpha = (distanceToContour < dF) ? 1.0 : 0.0; #else // If no derivatives available (IE 10?), use pixel ratio float alpha = (distanceToContour < (czm_pixelRatio * width)) ? 1.0 : 0.0; #endif vec4 outColor = czm_gammaCorrect(vec4(color.rgb, alpha * color.a)); material.diffuse = outColor.rgb; material.alpha = outColor.a; return material; } `;var D3t=T(S(),1),aE=`uniform sampler2D image; uniform float minimumHeight; uniform float maximumHeight; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); float scaledHeight = clamp((materialInput.height - minimumHeight) / (maximumHeight - minimumHeight), 0.0, 1.0); vec4 rampColor = texture(image, vec2(scaledHeight, 0.5)); rampColor = czm_gammaCorrect(rampColor); material.diffuse = rampColor.rgb; material.alpha = rampColor.a; return material; } `;var Y3t=T(S(),1),cE=`uniform vec4 fadeInColor; uniform vec4 fadeOutColor; uniform float maximumDistance; uniform bool repeat; uniform vec2 fadeDirection; uniform vec2 time; float getTime(float t, float coord) { float scalar = 1.0 / maximumDistance; float q = distance(t, coord) * scalar; if (repeat) { float r"
}