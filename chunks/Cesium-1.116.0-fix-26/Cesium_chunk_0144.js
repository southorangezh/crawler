{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 144,
    "total_chunks": 194,
    "chunk_size": 5788,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.738Z"
  },
  "content": "const float E = 0.01; // toe numerator const float F = 0.30; // toe denominator const float white = 11.2; // linear white point value vec3 c = ((color * (A * color + C * B) + D * E) / (color * ( A * color + B) + D * F)) - E / F; float w = ((white * (A * white + C * B) + D * E) / (white * ( A * white + B) + D * F)) - E / F; c = czm_inverseGamma(c / w); out_FragColor = vec4(c, fragmentColor.a); } `;var JPi=T(S(),1),_F=`in vec2 v_textureCoordinates; uniform sampler2D colorTexture; const float fxaaQualitySubpix = 0.5; const float fxaaQualityEdgeThreshold = 0.125; const float fxaaQualityEdgeThresholdMin = 0.0833; void main() { vec2 fxaaQualityRcpFrame = vec2(1.0) / czm_viewport.zw; vec4 color = FxaaPixelShader( v_textureCoordinates, colorTexture, fxaaQualityRcpFrame, fxaaQualitySubpix, fxaaQualityEdgeThreshold, fxaaQualityEdgeThresholdMin); float alpha = texture(colorTexture, v_textureCoordinates).a; out_FragColor = vec4(color.rgb, alpha); } `;var jPi=T(S(),1),Cg=`#define SAMPLES 8 uniform float delta; uniform float sigma; uniform float direction; // 0.0 for x direction, 1.0 for y direction uniform sampler2D colorTexture; #ifdef USE_STEP_SIZE uniform float stepSize; #else uniform vec2 step; #endif in vec2 v_textureCoordinates; // Incremental Computation of the Gaussian: // https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch40.html void main() { vec2 st = v_textureCoordinates; vec2 dir = vec2(1.0 - direction, direction); #ifdef USE_STEP_SIZE vec2 step = vec2(stepSize * (czm_pixelRatio / czm_viewport.zw)); #else vec2 step = step; #endif vec3 g; g.x = 1.0 / (sqrt(czm_twoPi) * sigma); g.y = exp((-0.5 * delta * delta) / (sigma * sigma)); g.z = g.y * g.y; vec4 result = texture(colorTexture, st) * g.x; for (int i = 1; i < SAMPLES; ++i) { g.xy *= g.yz; vec2 offset = float(i) * dir * step; result += texture(colorTexture, st - offset) * g.x; result += texture(colorTexture, st + offset) * g.x; } out_FragColor = result; } `;var $Pi=T(S(),1),TF=`uniform sampler2D colorTexture; uniform sampler2D dirtTexture; uniform sampler2D starTexture; uniform vec2 dirtTextureDimensions; uniform float distortion; uniform float ghostDispersal; uniform float haloWidth; uniform float dirtAmount; uniform float earthRadius; uniform float intensity; in vec2 v_textureCoordinates; // whether it is in space or not // 6500000.0 is empirical value #define DISTANCE_TO_SPACE 6500000.0 // return ndc from world coordinate biased earthRadius vec4 getNDCFromWC(vec3 WC, float earthRadius) { vec4 positionEC = czm_view * vec4(WC, 1.0); positionEC = vec4(positionEC.x + earthRadius, positionEC.y, positionEC.z, 1.0); vec4 positionWC = czm_eyeToWindowCoordinates(positionEC); return czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0); } // Check if current pixel is included Earth // if then mask it gradually float isInEarth(vec2 texcoord, vec2 sceneSize) { vec2 NDC = texcoord * 2.0 - 1.0; vec4 earthPosSC = getNDCFromWC(vec3(0.0), 0.0); vec4 earthPosSCEdge = getNDCFromWC(vec3(0.0), earthRadius * 1.5); NDC.xy -= earthPosSC.xy; float X = abs(NDC.x) * sceneSize.x; float Y = abs(NDC.y) * sceneSize.y; return clamp(0.0, 1.0, max(sqrt(X * X + Y * Y) / max(abs(earthPosSCEdge.x * sceneSize.x), 1.0) - 0.8 , 0.0)); } // For Chromatic effect vec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion, bool isSpace) { vec2 sceneSize = czm_viewport.zw; vec3 color; if(isSpace) { color.r = isInEarth(texcoord + direction * distortion.r, sceneSize) * texture(tex, texcoord + direction * distortion.r).r; color.g = isInEarth(texcoord + direction * distortion.g, sceneSize) * texture(tex, texcoord + direction * distortion.g).g; color.b = isInEarth(texcoord + direction * distortion.b, sceneSize) * texture(tex, texcoord + direction * distortion.b).b; } else { color.r = texture(tex, texcoord + direction * distortion.r).r; color.g = texture(tex, texcoord + direction * distortion.g).g; color.b = texture(tex, texcoord + direction * distortion.b).b; } return vec4(clamp(color, 0.0, 1.0), 0.0); } void main(void) { vec4 originalColor = texture(colorTexture, v_textureCoordinates); vec3 rgb = originalColor.rgb; bool isSpace = length(czm_viewerPositionWC.xyz) > DISTANCE_TO_SPACE; // Sun position vec4 sunPos = czm_morphTime == 1.0 ? vec4(czm_sunPositionWC, 1.0) : vec4(czm_sunPositionColumbusView.zxy, 1.0); vec4 sunPositionEC = czm_view * sunPos; vec4 sunPositionWC = czm_eyeToWindowCoordinates(sunPositionEC); sunPos = czm_viewportOrthographic * vec4(sunPositionWC.xy, -sunPositionWC.z, 1.0); // If sun is not in the screen space, use original color. if(!isSpace || !((sunPos.x >= -1.1 && sunPos.x <= 1.1) && (sunPos.y >= -1.1 && sunPos.y <= 1.1))) { // Lens flare is disabled when not in space until #5932 is fixed. // https://github.com/CesiumGS/cesium/issues/5932 out_FragColor = originalColor; return; } vec2 texcoord = vec2(1.0) - v_textureCoordinates; vec2 pixelSize = czm_pixelRatio / czm_viewport.zw; vec2 invPixelSize = 1.0 / pixelSize; vec3 distortionVec = pixelSize.x * vec3(-distortion, 0.0, distortion); // ghost vector to image centre: vec2 ghostVec = (vec2(0.5) - texcoord) * ghostDispersal; vec3 direction = normalize(vec3(ghostVec, 0.0)); // sample ghosts: vec4 result = vec4(0.0); vec4 ghost = vec4(0.0); for (int i = 0; i < 4; ++i) { vec2 offset = fract(texcoord + ghostVec * float(i)); // Only bright spots from the centre of the source image ghost += textureDistorted(colorTexture, offset, direction.xy, distortionVec, isSpace); } result += ghost; // sample halo vec2 haloVec = normalize(ghostVec) * haloWidth; float weightForHalo = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5)); weightForHalo = pow(1.0 - weightForHalo, 5.0); result += textureDistorted(colorTexture, texcoord + haloVec, direction.xy, distortionVec,"
}