{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 157,
    "total_chunks": 194,
    "chunk_size": 6324,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.744Z"
  },
  "content": "intersection point // .w for the T value // The scale of the normal encodes the shape intersection type: // length(intersection.xyz) = 1: positive shape entry // length(intersection.xyz) = 2: positive shape exit // length(intersection.xyz) = 3: negative shape entry // length(intersection.xyz) = 4: negative shape exit // INTERSECTION_COUNT is the number of ray-*shape* (volume) intersections, // so we need twice as many to track ray-*surface* intersections vec4 intersections[INTERSECTION_COUNT * 2]; #if (INTERSECTION_COUNT > 1) // Maintain state for future nextIntersection calls int index; int surroundCount; bool surroundIsPositive; #endif }; RayShapeIntersection getFirstIntersection(in Intersections ix) { return RayShapeIntersection(ix.intersections[0], ix.intersections[1]); } vec4 encodeIntersectionType(vec4 intersection, int index, bool entry) { float scale = float(index > 0) * 2.0 + float(!entry) + 1.0; return vec4(intersection.xyz * scale, intersection.w); } // Use defines instead of real functions because WebGL1 cannot access array with non-constant index. #define setIntersection(/*inout Intersections*/ ix, /*int*/ index, /*float*/ t, /*bool*/ positive, /*bool*/ enter) (ix).intersections[(index)] = vec4(0.0, float(!positive) * 2.0 + float(!enter) + 1.0, 0.0, (t)) #define setIntersectionPair(/*inout Intersections*/ ix, /*int*/ index, /*vec2*/ entryExit) (ix).intersections[(index) * 2 + 0] = vec4(0.0, float((index) > 0) * 2.0 + 1.0, 0.0, (entryExit).x); (ix).intersections[(index) * 2 + 1] = vec4(0.0, float((index) > 0) * 2.0 + 2.0, 0.0, (entryExit).y) #define setSurfaceIntersection(/*inout Intersections*/ ix, /*int*/ index, /*vec4*/ intersection, /*bool*/ positive, /*bool*/ enter) (ix).intersections[(index)] = encodeIntersectionType((intersection), int(!positive), (enter)) #define setShapeIntersection(/*inout Intersections*/ ix, /*int*/ index, /*RayShapeIntersection*/ intersection) (ix).intersections[(index) * 2 + 0] = encodeIntersectionType((intersection).entry, (index), true); (ix).intersections[(index) * 2 + 1] = encodeIntersectionType((intersection).exit, (index), false) #if (INTERSECTION_COUNT > 1) void initializeIntersections(inout Intersections ix) { // Sort the intersections from min T to max T with bubble sort. // Note: If this sorting function changes, some of the intersection test may // need to be updated. Search for \"bubble sort\" to find those areas. const int sortPasses = INTERSECTION_COUNT * 2 - 1; for (int n = sortPasses; n > 0; --n) { for (int i = 0; i < sortPasses; ++i) { // The loop should be: for (i = 0; i < n; ++i) {...} but WebGL1 cannot // loop with non-constant condition, so it has to break early instead if (i >= n) { break; } vec4 intersect0 = ix.intersections[i + 0]; vec4 intersect1 = ix.intersections[i + 1]; bool inOrder = intersect0.w <= intersect1.w; ix.intersections[i + 0] = inOrder ? intersect0 : intersect1; ix.intersections[i + 1] = inOrder ? intersect1 : intersect0; } } // Prepare initial state for nextIntersection ix.index = 0; ix.surroundCount = 0; ix.surroundIsPositive = false; } #endif #if (INTERSECTION_COUNT > 1) RayShapeIntersection nextIntersection(inout Intersections ix) { vec4 surfaceIntersection = vec4(0.0, 0.0, 0.0, NO_HIT); RayShapeIntersection shapeIntersection = RayShapeIntersection(surfaceIntersection, surfaceIntersection); const int passCount = INTERSECTION_COUNT * 2; if (ix.index == passCount) { return shapeIntersection; } for (int i = 0; i < passCount; ++i) { // The loop should be: for (i = ix.index; i < passCount; ++i) {...} but WebGL1 cannot // loop with non-constant condition, so it has to continue instead. if (i < ix.index) { continue; } ix.index = i + 1; surfaceIntersection = ix.intersections[i]; int intersectionType = int(length(surfaceIntersection.xyz) - 0.5); bool currShapeIsPositive = intersectionType < 2; bool enter = intMod(intersectionType, 2) == 0; ix.surroundCount += enter ? +1 : -1; ix.surroundIsPositive = currShapeIsPositive ? enter : ix.surroundIsPositive; // entering positive or exiting negative if (ix.surroundCount == 1 && ix.surroundIsPositive && enter == currShapeIsPositive) { shapeIntersection.entry = surfaceIntersection; } // exiting positive or entering negative after being inside positive bool exitPositive = !enter && currShapeIsPositive && ix.surroundCount == 0; bool enterNegativeFromPositive = enter && !currShapeIsPositive && ix.surroundCount == 2 && ix.surroundIsPositive; if (exitPositive || enterNegativeFromPositive) { shapeIntersection.exit = surfaceIntersection; // entry and exit have been found, so the loop can stop if (exitPositive) { // After exiting positive shape there is nothing left to intersect, so jump to the end index. ix.index = passCount; } break; } } return shapeIntersection; } #endif // NOTE: initializeIntersections, nextIntersection aren't even declared unless INTERSECTION_COUNT > 1 `;var fAi=T(S(),1),JF=`// See IntersectionUtils.glsl for the definitions of Ray, Intersections, // setIntersectionPair, INF_HIT, NO_HIT /* intersectDepth defines (set in Scene/VoxelRenderResources.js) #define DEPTH_INTERSECTION_INDEX ### */ uniform mat4 u_transformPositionViewToUv; void intersectDepth(in vec2 screenCoord, in Ray ray, inout Intersections ix) { float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, screenCoord)); if (logDepthOrDepth != 0.0) { // Calculate how far the ray must travel before it hits the depth buffer. vec4 eyeCoordinateDepth = czm_screenToEyeCoordinates(screenCoord, logDepthOrDepth); eyeCoordinateDepth /= eyeCoordinateDepth.w; vec3 depthPositionUv = vec3(u_transformPositionViewToUv * eyeCoordinateDepth); float t = dot(depthPositionUv - ray.pos, ray.dir); setIntersectionPair(ix, DEPTH_INTERSECTION_INDEX, vec2(t, +INF_HIT)); } else { // There's no depth at this location. setIntersectionPair(ix, DEPTH_INTERSECTION_INDEX, vec2(NO_HIT)); } } `;var bAi=T(S(),1),QF=`// See IntersectionUtils.glsl for the definitions of Ray, Intersections, INF_HIT, // NO_HIT, setShapeIntersection /* Clipping plane defines (set in Scene/VoxelRenderResources.js) #define CLIPPING_PLANES_UNION #define CLIPPING_PLANES_COUNT #define CLIPPING_PLANES_INTERSECTION_INDEX */ uniform sampler2D u_clippingPlanesTexture; uniform mat4 u_clippingPlanesMatrix; // Plane is in Hessian Normal Form vec4 intersectPlane(in Ray ray, in"
}