{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 54,
    "total_chunks": 194,
    "chunk_size": 23666,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.678Z"
  },
  "content": "*= czm_batchTable_show(batchId); }`:t};yr._updateColorAttribute=function(e,t,n){if(!l(e._batchTableAttributeIndices.color)&&!l(e._batchTableAttributeIndices.depthFailColor)||t.search(/in\\s+vec4\\s+color;/g)===-1)return t;let i=t;return i=i.replace(/in\\s+vec4\\s+color;/g,\"\"),n?i=i.replace(/(\\b)color(\\b)/g,\"$1czm_batchTable_depthFailColor(batchId)$2\"):i=i.replace(/(\\b)color(\\b)/g,\"$1czm_batchTable_color(batchId)$2\"),i};function ane(e){return`${Ue.replaceMain(e,\"czm_non_pick_main\")} out vec4 v_pickColor; void main() { czm_non_pick_main(); v_pickColor = czm_batchTable_pickColor(batchId); }`}function cne(e){return`in vec4 v_pickColor; ${e}`}yr._updatePickColorAttribute=function(e){let t=e.replace(/in\\s+vec4\\s+pickColor;/g,\"\");return t=t.replace(/(\\b)pickColor(\\b)/g,\"$1czm_batchTable_pickColor(batchId)$2\"),t};yr._appendOffsetToShader=function(e,t){if(!l(e._batchTableAttributeIndices.offset))return t;let n=`in float batchId; `;n+=\"in float applyOffset;\";let i=t.replace(/in\\s+float\\s+batchId;/g,n),o=`vec4 $1 = czm_computePosition(); `;return o+=` if (czm_sceneMode == czm_sceneMode3D) `,o+=` { `,o+=\" $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);\",o+=` } `,o+=` else `,o+=` { `,o+=\" $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);\",o+=` } `,i=i.replace(/vec4\\s+([A-Za-z0-9_]+)\\s+=\\s+czm_computePosition\\(\\);/g,o),i};yr._appendDistanceDisplayConditionToShader=function(e,t,n){if(!l(e._batchTableAttributeIndices.distanceDisplayCondition))return t;let i=Ue.replaceMain(t,\"czm_non_distanceDisplayCondition_main\"),o=`void main() { czm_non_distanceDisplayCondition_main(); vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId); vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId); vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId); float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId); `;return n?o+=` vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow); `:o+=` vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId); vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId); vec4 centerRTE; if (czm_morphTime == 1.0) { centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow); } else if (czm_morphTime == 0.0) { centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy); } else { centerRTE = czm_columbusViewMorph( czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy), czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow), czm_morphTime); } `,o+=` float radiusSq = boundingSphereRadius * boundingSphereRadius; float distanceSq; if (czm_sceneMode == czm_sceneMode2D) { distanceSq = czm_eyeHeight2D.y - radiusSq; } else { distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; } distanceSq = max(distanceSq, 0.0); float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; gl_Position *= show; }`,`${i} ${o}`};function lne(e,t){if(!e.compressVertices)return t;let n=t.search(/in\\s+vec3\\s+normal;/g)!==-1,i=t.search(/in\\s+vec2\\s+st;/g)!==-1;if(!n&&!i)return t;let o=t.search(/in\\s+vec3\\s+tangent;/g)!==-1,r=t.search(/in\\s+vec3\\s+bitangent;/g)!==-1,s=i&&n?2:1;s+=o||r?1:0;let a=s>1?`vec${s}`:\"float\",c=\"compressedAttributes\",d=`in ${a} ${c};`,u=\"\",m=\"\";if(i){u+=`vec2 st; `;let f=s>1?`${c}.x`:c;m+=` st = czm_decompressTextureCoordinates(${f}); `}n&&o&&r?(u+=`vec3 normal; vec3 tangent; vec3 bitangent; `,m+=` czm_octDecode(${c}.${i?\"yz\":\"xy\"}, normal, tangent, bitangent); `):(n&&(u+=`vec3 normal; `,m+=` normal = czm_octDecode(${c}${s>1?`.${i?\"y\":\"x\"}`:\"\"}); `),o&&(u+=`vec3 tangent; `,m+=` tangent = czm_octDecode(${c}.${i&&n?\"z\":\"y\"}); `),r&&(u+=`vec3 bitangent; `,m+=` bitangent = czm_octDecode(${c}.${i&&n?\"z\":\"y\"}); `));let p=t;p=p.replace(/in\\s+vec3\\s+normal;/g,\"\"),p=p.replace(/in\\s+vec2\\s+st;/g,\"\"),p=p.replace(/in\\s+vec3\\s+tangent;/g,\"\"),p=p.replace(/in\\s+vec3\\s+bitangent;/g,\"\"),p=Ue.replaceMain(p,\"czm_non_compressed_main\");let b=`void main() { ${m} czm_non_compressed_main(); }`;return[d,u,p,b].join(` `)}function cWe(e){let t=Ue.replaceMain(e,\"czm_non_depth_clamp_main\");return t+=`void main() { czm_non_depth_clamp_main(); gl_Position = czm_depthClamp(gl_Position);} `,t}function lWe(e){let t=Ue.replaceMain(e,\"czm_non_depth_clamp_main\");return t+=`void main() { czm_non_depth_clamp_main(); #if defined(LOG_DEPTH) czm_writeLogDepth(); #else czm_writeDepthClamp(); #endif } `,t}function dne(e,t){let n=e.vertexAttributes}function dWe(e,t){return function(){return e[t]}}var yO=Math.max(Ut.hardwareConcurrency-1,1),L5,uWe=new di(\"combineGeometry\");function mWe(e,t){let n,i,o,r,s=e._instanceIds;if(e._state===br.READY){n=Array.isArray(e.geometryInstances)?e.geometryInstances:[e.geometryInstances];let a=e._numberOfInstances=n.length,c=[],d=[];for(o=0;o<a;++o)i=n[o].geometry,s.push(n[o].id),d.push({moduleName:i._workerName,modulePath:i._workerPath,geometry:i});if(!l(L5))for(L5=new Array(yO),o=0;o<yO;o++)L5[o]=new di(\"createGeometry\");let u;for(d=EE(d,yO),o=0;o<d.length;o++){let m=0,p=d[o],b=p.length;for(r=0;r<b;++r)u=p[r],i=u.geometry,l(i.constructor.pack)&&(u.offset=m,m+=g(i.constructor.packedLength,i.packedLength));let f;if(m>0){let x=new Float64Array(m);for(f=[x.buffer],r=0;r<b;++r)u=p[r],i=u.geometry,l(i.constructor.pack)&&(i.constructor.pack(i,x,u.offset),u.geometry=x)}c.push(L5[o].scheduleTask({subTasks:d[o]},f))}e._state=br.CREATING,Promise.all(c).then(function(m){e._createGeometryResults=m,e._state=br.CREATED}).catch(function(m){AE(e,t,br.FAILED,m)})}else if(e._state===br.CREATED){let a=[];n=Array.isArray(e.geometryInstances)?e.geometryInstances:[e.geometryInstances];let c=t.scene3DOnly,d=t.mapProjection,u=uWe.scheduleTask(gx.packCombineGeometryParameters({createGeometryResults:e._createGeometryResults,instances:n,ellipsoid:d.ellipsoid,projection:d,elementIndexUintSupported:t.context.elementIndexUint,scene3DOnly:c,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e._createPickOffsets},a),a);e._createGeometryResults=void 0,e._state=br.COMBINING,Promise.resolve(u).then(function(m){let p=gx.unpackCombineGeometryResults(m);e._geometries=p.geometries,e._attributeLocations=p.attributeLocations,e.modelMatrix=M.clone(p.modelMatrix,e.modelMatrix),e._pickOffsets=p.pickOffsets,e._offsetInstanceExtend=p.offsetInstanceExtend,e._instanceBoundingSpheres=p.boundingSpheres,e._instanceBoundingSpheresCV=p.boundingSpheresCV,l(e._geometries)&&e._geometries.length>0?(e._recomputeBoundingSpheres=!0,e._state=br.COMBINED):AE(e,t,br.FAILED,void 0)}).catch(function(m){AE(e,t,br.FAILED,m)})}}function hWe(e,t){let n=Array.isArray(e.geometryInstances)?e.geometryInstances:[e.geometryInstances],i=e._numberOfInstances=n.length,o=new Array(i),r=e._instanceIds,s,a,c=0;for(a=0;a<i;a++){s=n[a];let p=s.geometry,b;l(p.attributes)&&l(p.primitiveType)?b=rWe(p):b=p.constructor.createGeometry(p),o[c++]=sWe(s,b),r.push(s.id)}o.length=c;let d=t.scene3DOnly,u=t.mapProjection,m=gx.combineGeometry({instances:o,ellipsoid:u.ellipsoid,projection:u,elementIndexUintSupported:t.context.elementIndexUint,scene3DOnly:d,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e._createPickOffsets});e._geometries=m.geometries,e._attributeLocations=m.attributeLocations,e.modelMatrix=M.clone(m.modelMatrix,e.modelMatrix),e._pickOffsets=m.pickOffsets,e._offsetInstanceExtend=m.offsetInstanceExtend,e._instanceBoundingSpheres=m.boundingSpheres,e._instanceBoundingSpheresCV=m.boundingSpheresCV,l(e._geometries)&&e._geometries.length>0?(e._recomputeBoundingSpheres=!0,e._state=br.COMBINED):AE(e,t,br.FAILED,void 0)}function fWe(e,t){let n=e._batchTableAttributeIndices.offset;if(!e._recomputeBoundingSpheres||!l(n)){e._recomputeBoundingSpheres=!1;return}let i,o=e._offsetInstanceExtend,r=e._instanceBoundingSpheres,s=r.length,a=e._tempBoundingSpheres;if(!l(a)){for(a=new Array(s),i=0;i<s;i++)a[i]=new ce;e._tempBoundingSpheres=a}for(i=0;i<s;++i){let x=a[i],_=e._batchTable.getBatchedAttribute(i,n,new h);x=r[i].clone(x),_ne(x,_,o[i])}let c=[],d=[],u=[];for(i=0;i<s;++i){let x=a[i];x.center.x-x.radius>0||ce.intersectPlane(x,an.ORIGIN_ZX_PLANE)!==nn.INTERSECTING?c.push(x):(d.push(x),u.push(x))}let m=c[0],p=u[0],b=d[0];for(i=1;i<c.length;i++)m=ce.union(m,c[i]);for(i=1;i<u.length;i++)p=ce.union(p,u[i]);for(i=1;i<d.length;i++)b=ce.union(b,d[i]);let f=[];for(l(m)&&f.push(m),l(p)&&f.push(p),l(b)&&f.push(b),i=0;i<f.length;i++){let x=f[i].clone(e._boundingSpheres[i]);e._boundingSpheres[i]=x,e._boundingSphereCV[i]=ce.projectTo2D(x,t.mapProjection,e._boundingSphereCV[i])}yr._updateBoundingVolumes(e,t,e.modelMatrix,!0),e._recomputeBoundingSpheres=!1}var une=new Yn,yne=new he,gne=new h,xne=new ce;function pWe(e,t){if(!l(e._batchTableAttributeIndices.distanceDisplayCondition)||e._batchTableBoundingSpheresUpdated)return;let i=e._batchTableBoundingSphereAttributeIndices,o=i.center3DHigh,r=i.center3DLow,s=i.center2DHigh,a=i.center2DLow,c=i.radius,d=t.mapProjection,u=d.ellipsoid,m=e._batchTable,p=e._instanceBoundingSpheres,b=p.length;for(let f=0;f<b;++f){let x=p[f];if(!l(x))continue;let _=e.modelMatrix;l(_)&&(x=ce.transform(x,_,xne));let C=x.center,V=x.radius,L=Yn.fromCartesian(C,une);if(m.setBatchedAttribute(f,o,L.high),m.setBatchedAttribute(f,r,L.low),!t.scene3DOnly){let R=u.cartesianToCartographic(C,yne),G=d.project(R,gne);L=Yn.fromCartesian(G,une),m.setBatchedAttribute(f,s,L.high),m.setBatchedAttribute(f,a,L.low)}m.setBatchedAttribute(f,c,V)}e._batchTableBoundingSpheresUpdated=!0}var gO=new h,bWe=new h;function mne(e,t){if(!l(e._batchTableAttributeIndices.offset)||e._batchTableOffsetsUpdated||t.scene3DOnly)return;let i=e._batchTableOffsetAttribute2DIndex,o=t.mapProjection,r=o.ellipsoid,s=e._batchTable,a=e._instanceBoundingSpheres,c=a.length;for(let d=0;d<c;++d){let u=a[d];if(!l(u))continue;let m=s.getBatchedAttribute(d,e._batchTableAttributeIndices.offset);if(h.equals(m,h.ZERO)){s.setBatchedAttribute(d,i,h.ZERO);continue}let p=e.modelMatrix;l(p)&&(u=ce.transform(u,p,xne));let b=u.center;b=r.scaleToGeodeticSurface(b,bWe);let f=r.cartesianToCartographic(b,yne),x=o.project(f,gne),_=h.add(m,b,gO);f=r.cartesianToCartographic(_,f);let C=o.project(f,gO),V=h.subtract(C,x,gO),L=V.x;V.x=V.z,V.z=V.y,V.y=L,s.setBatchedAttribute(d,i,V)}e._batchTableOffsetsUpdated=!0}function yWe(e,t){let n=e._attributeLocations,i=e._geometries,o=t.scene3DOnly,r=t.context,s=[],a=i.length;for(let c=0;c<a;++c){let d=i[c];if(s.push(ti.fromGeometry({context:r,geometry:d,attributeLocations:n,bufferUsage:Me.STATIC_DRAW,interleave:e._interleave})),l(e._createBoundingVolumeFunction))e._createBoundingVolumeFunction(t,d);else if(e._boundingSpheres.push(ce.clone(d.boundingSphere)),e._boundingSphereWC.push(new ce),!o){let u=d.boundingSphereCV.center,m=u.x,p=u.y,b=u.z;u.x=b,u.y=m,u.z=p,e._boundingSphereCV.push(ce.clone(d.boundingSphereCV)),e._boundingSphere2D.push(new ce),e._boundingSphereMorph.push(new ce)}}e._va=s,e._primitiveType=i[0].primitiveType,e.releaseGeometryInstances&&(e.geometryInstances=void 0),e._geometries=void 0,AE(e,t,br.COMPLETE,void 0)}function gWe(e,t,n,i){let o=n.getRenderState(),r;i?(r=Oe(o,!1),r.cull={enabled:!0,face:mi.BACK},e._frontFaceRS=Ne.fromCache(r),r.cull.face=mi.FRONT,e._backFaceRS=Ne.fromCache(r)):(e._frontFaceRS=Ne.fromCache(o),e._backFaceRS=e._frontFaceRS),r=Oe(o,!1),l(e._depthFailAppearance)&&(r.depthTest.enabled=!1),l(e._depthFailAppearance)&&(o=e._depthFailAppearance.getRenderState(),r=Oe(o,!1),r.depthTest.func=tc.GREATER,i?(r.cull={enabled:!0,face:mi.BACK},e._frontFaceDepthFailRS=Ne.fromCache(r),r.cull.face=mi.FRONT,e._backFaceDepthFailRS=Ne.fromCache(r)):(e._frontFaceDepthFailRS=Ne.fromCache(r),e._backFaceDepthFailRS=e._frontFaceRS))}function xWe(e,t,n){let i=t.context,o=e._attributeLocations,r=e._batchTable.getVertexShaderCallback()(n.vertexShaderSource);r=yr._appendOffsetToShader(e,r),r=yr._appendShowToShader(e,r),r=yr._appendDistanceDisplayConditionToShader(e,r,t.scene3DOnly),r=ane(r),r=yr._updateColorAttribute(e,r,!1),r=lne(e,r),r=yr._modifyShaderPosition(e,r,t.scene3DOnly);let s=n.getFragmentShaderSource();s=cne(s),e._sp=Ht.replaceCache({context:i,shaderProgram:e._sp,vertexShaderSource:r,fragmentShaderSource:s,attributeLocations:o}),dne(e._sp,o),l(e._depthFailAppearance)&&(r=e._batchTable.getVertexShaderCallback()(e._depthFailAppearance.vertexShaderSource),r=yr._appendShowToShader(e,r),r=yr._appendDistanceDisplayConditionToShader(e,r,t.scene3DOnly),r=ane(r),r=yr._updateColorAttribute(e,r,!0),r=lne(e,r),r=yr._modifyShaderPosition(e,r,t.scene3DOnly),r=cWe(r),s=e._depthFailAppearance.getFragmentShaderSource(),s=cne(s),s=lWe(s),e._spDepthFail=Ht.replaceCache({context:i,shaderProgram:e._spDepthFail,vertexShaderSource:r,fragmentShaderSource:s,attributeLocations:o}),dne(e._spDepthFail,o))}var FE=new M,hne=new h;function fne(e,t,n,i){let o=l(n)?n._uniforms:void 0,r={},s=t.uniforms;if(l(s))for(let c in s)s.hasOwnProperty(c)&&(r[c]=dWe(s,c));let a=Ct(r,o);return a=e._batchTable.getUniformMapCallback()(a),l(e.rtcCenter)&&(a.u_modifiedModelView=function(){let c=i.context.uniformState.view;return M.multiply(c,e._modelMatrix,FE),M.multiplyByPoint(FE,e.rtcCenter,hne),M.setTranslation(FE,hne,FE),FE}),a}function _We(e,t,n,i,o,r,s,a){let c=fne(e,t,n,a),d;l(e._depthFailAppearance)&&(d=fne(e,e._depthFailAppearance,e._depthFailAppearance.material,a));let u=i?Ze.TRANSLUCENT:Ze.OPAQUE,m=o?2:1;m*=l(e._depthFailAppearance)?2:1,r.length=e._va.length*m;let p=r.length,b=0;for(let f=0;f<p;++f){let x;o&&(x=r[f],l(x)||(x=r[f]=new je({owner:e,primitiveType:e._primitiveType})),x.vertexArray=e._va[b],x.renderState=e._backFaceRS,x.shaderProgram=e._sp,x.uniformMap=c,x.pass=u,++f),x=r[f],l(x)||(x=r[f]=new je({owner:e,primitiveType:e._primitiveType})),x.vertexArray=e._va[b],x.renderState=e._frontFaceRS,x.shaderProgram=e._sp,x.uniformMap=c,x.pass=u,l(e._depthFailAppearance)&&(o&&(++f,x=r[f],l(x)||(x=r[f]=new je({owner:e,primitiveType:e._primitiveType})),x.vertexArray=e._va[b],x.renderState=e._backFaceDepthFailRS,x.shaderProgram=e._spDepthFail,x.uniformMap=d,x.pass=u),++f,x=r[f],l(x)||(x=r[f]=new je({owner:e,primitiveType:e._primitiveType})),x.vertexArray=e._va[b],x.renderState=e._frontFaceDepthFailRS,x.shaderProgram=e._spDepthFail,x.uniformMap=d,x.pass=u),++b}}yr._updateBoundingVolumes=function(e,t,n,i){let o,r,s;if(i||!M.equals(n,e._modelMatrix))for(M.clone(n,e._modelMatrix),r=e._boundingSpheres.length,o=0;o<r;++o)s=e._boundingSpheres[o],l(s)&&(e._boundingSphereWC[o]=ce.transform(s,n,e._boundingSphereWC[o]),t.scene3DOnly||(e._boundingSphere2D[o]=ce.clone(e._boundingSphereCV[o],e._boundingSphere2D[o]),e._boundingSphere2D[o].center.x=0,e._boundingSphereMorph[o]=ce.union(e._boundingSphereWC[o],e._boundingSphereCV[o])));let a=e.appearance.pixelSize;if(l(a))for(r=e._boundingSpheres.length,o=0;o<r;++o){s=e._boundingSpheres[o];let c=e._boundingSphereWC[o],u=t.camera.getPixelSize(s,t.context.drawingBufferWidth,t.context.drawingBufferHeight)*a;c.radius=s.radius+u}};function TWe(e,t,n,i,o,r,s,a){yr._updateBoundingVolumes(e,t,o);let c;t.mode===ie.SCENE3D?c=e._boundingSphereWC:t.mode===ie.COLUMBUS_VIEW?c=e._boundingSphereCV:t.mode===ie.SCENE2D&&l(e._boundingSphere2D)?c=e._boundingSphere2D:l(e._boundingSphereMorph)&&(c=e._boundingSphereMorph);let d=t.commandList,u=t.passes;if(u.render||u.pick){let m=e.allowPicking,p=_n.castShadows(e.shadows),b=_n.receiveShadows(e.shadows),f=n.length,x=a?2:1;x*=l(e._depthFailAppearance)?2:1;for(let _=0;_<f;++_){let C=Math.floor(_/x),V=n[_];V.modelMatrix=o,V.boundingVolume=c[C],V.cull=r,V.debugShowBoundingVolume=s,V.castShadows=p,V.receiveShadows=b,m?V.pickId=\"v_pickColor\":V.pickId=void 0,d.push(V)}}}yr.prototype.update=function(e){if(!l(this.geometryInstances)&&this._va.length===0||l(this.geometryInstances)&&Array.isArray(this.geometryInstances)&&this.geometryInstances.length===0||!l(this.appearance)||e.mode!==ie.SCENE3D&&e.scene3DOnly||!e.passes.render&&!e.passes.pick)return;if(l(this._error))throw this._error;if(this._state===br.FAILED)return;let t=e.context;if(l(this._batchTable)||iWe(this,t),this._batchTable.attributes.length>0){if(Yt.maximumVertexTextureImageUnits===0)throw new ue(\"Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\");this._batchTable.update(e)}if(this._state!==br.COMPLETE&&this._state!==br.COMBINED&&(this.asynchronous?mWe(this,e):hWe(this,e)),this._state===br.COMBINED&&(pWe(this,e),mne(this,e),yWe(this,e)),!this.show||this._state!==br.COMPLETE)return;this._batchTableOffsetsUpdated||mne(this,e),this._recomputeBoundingSpheres&&fWe(this,e);let n=this.appearance,i=n.material,o=!1,r=!1;this._appearance!==n?(this._appearance=n,this._material=i,o=!0,r=!0):this._material!==i&&(this._material=i,r=!0);let s=this.depthFailAppearance,a=l(s)?s.material:void 0;this._depthFailAppearance!==s?(this._depthFailAppearance=s,this._depthFailMaterial=a,o=!0,r=!0):this._depthFailMaterial!==a&&(this._depthFailMaterial=a,r=!0);let c=this._appearance.isTranslucent();this._translucent!==c&&(this._translucent=c,o=!0),l(this._material)&&this._material.update(t);let d=n.closed&&c;o&&g(this._createRenderStatesFunction,gWe)(this,t,n,d),r&&g(this._createShaderProgramFunction,xWe)(this,e,n),(o||r)&&g(this._createCommandsFunction,_We)(this,n,i,c,d,this._colorCommands,this._pickCommands,e),g(this._updateAndQueueCommandsFunction,TWe)(this,e,this._colorCommands,this._pickCommands,this.modelMatrix,this.cull,this.debugShowBoundingVolume,d)};var SWe=new ce,CWe=new ce;function _ne(e,t,n){if(n===cn.TOP){let i=ce.clone(e,SWe),o=ce.clone(e,CWe);o.center=h.add(o.center,t,o.center),e=ce.union(i,o,e)}else n===cn.ALL&&(e.center=h.add(e.center,t,e.center));return e}function VWe(e,t,n){return function(){let i=e.getBatchedAttribute(t,n),o=e.attributes[n],r=o.componentsPerAttribute,s=Q.createTypedArray(o.componentDatatype,r);return l(i.constructor.pack)?i.constructor.pack(i,s,0):s[0]=i,s}}function LWe(e,t,n,i,o){return function(r){let s=bne(r);e.setBatchedAttribute(t,n,s),o===\"offset\"&&(i._recomputeBoundingSpheres=!0,i._batchTableOffsetsUpdated=!1)}}var ZWe=new h;function RWe(e,t,n){t.boundingSphere={get:function(){let i=e._instanceBoundingSpheres[n];if(l(i)){i=i.clone();let o=e.modelMatrix,r=t.offset;l(r)&&_ne(i,h.fromArray(r.get(),0,ZWe),e._offsetInstanceExtend[n]),l(o)&&(i=ce.transform(i,o))}return i}},t.boundingSphereCV={get:function(){return e._instanceBoundingSpheresCV[n]}}}function GWe(e,t,n){t.pickId={get:function(){return e._pickIds[n]}}}yr.prototype.getGeometryInstanceAttributes=function(e){let t=this._perInstanceAttributeCache.get(e);if(l(t))return t;let n=-1,i=this._lastPerInstanceAttributeIndex,o=this._instanceIds,r=o.length;for(let d=0;d<r;++d){let u=(i+d)%r;if(e===o[u]){n=u;break}}if(n===-1)return;let s=this._batchTable,a=this._batchTableAttributeIndices;t={};let c={};for(let d in a)if(a.hasOwnProperty(d)){let u=a[d];c[d]={get:VWe(s,n,u),set:LWe(s,n,u,this,d)}}return RWe(this,c,n),GWe(this,c,n),Object.defineProperties(t,c),this._lastPerInstanceAttributeIndex=n,this._perInstanceAttributeCache.set(e,t),t};yr.prototype.isDestroyed=function(){return!1};yr.prototype.destroy=function(){let e,t;this._sp=this._sp&&this._sp.destroy(),this._spDepthFail=this._spDepthFail&&this._spDepthFail.destroy();let n=this._va;for(e=n.length,t=0;t<e;++t)n[t].destroy();this._va=void 0;let i=this._pickIds;for(e=i.length,t=0;t<e;++t)i[t].destroy();return this._pickIds=void 0,this._batchTable=this._batchTable&&this._batchTable.destroy(),this._instanceIds=void 0,this._perInstanceAttributeCache=void 0,this._attributeLocations=void 0,me(this)};function AE(e,t,n,i){e._error=i,e._state=n,t.afterRender.push(function(){if(e._ready=e._state===br.COMPLETE||e._state===br.FAILED,!l(i))return!0})}var Rn=yr;var TJt=T(S(),1);var nJt=T(S(),1);function EWe(e){e=g(e,g.EMPTY_OBJECT),this.componentDatatype=e.componentDatatype,this.componentsPerAttribute=e.componentsPerAttribute,this.normalize=g(e.normalize,!1),this.value=e.value}var nc=EWe;var oJt=T(S(),1),jS=`#ifdef TEXTURE_COORDINATES #ifdef SPHERICAL in vec4 v_sphericalExtents; #else // SPHERICAL in vec2 v_inversePlaneExtents; in vec4 v_westPlane; in vec4 v_southPlane; #endif // SPHERICAL in vec3 v_uvMinAndSphericalLongitudeRotation; in vec3 v_uMaxAndInverseDistance; in vec3 v_vMaxAndInverseDistance; #endif // TEXTURE_COORDINATES #ifdef PER_INSTANCE_COLOR in vec4 v_color; #endif #ifdef NORMAL_EC vec3 getEyeCoordinate3FromWindowCoordinate(vec2 fragCoord, float logDepthOrDepth) { vec4 eyeCoordinate = czm_windowToEyeCoordinates(fragCoord, logDepthOrDepth); return eyeCoordinate.xyz / eyeCoordinate.w; } vec3 vectorFromOffset(vec4 eyeCoordinate, vec2 positiveOffset) { vec2 glFragCoordXY = gl_FragCoord.xy; // Sample depths at both offset and negative offset float upOrRightLogDepth = czm_unpackDepth(texture(czm_globeDepthTexture, (glFragCoordXY + positiveOffset) / czm_viewport.zw)); float downOrLeftLogDepth = czm_unpackDepth(texture(czm_globeDepthTexture, (glFragCoordXY - positiveOffset) / czm_viewport.zw)); // Explicitly evaluate both paths // Necessary for multifrustum and for edges of the screen bvec2 upOrRightInBounds = lessThan(glFragCoordXY + positiveOffset, czm_viewport.zw); float useUpOrRight = float(upOrRightLogDepth > 0.0 && upOrRightInBounds.x && upOrRightInBounds.y); float useDownOrLeft = float(useUpOrRight == 0.0); vec3 upOrRightEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY + positiveOffset, upOrRightLogDepth); vec3 downOrLeftEC = getEyeCoordinate3FromWindowCoordinate(glFragCoordXY - positiveOffset, downOrLeftLogDepth); return (upOrRightEC - (eyeCoordinate.xyz / eyeCoordinate.w)) * useUpOrRight + ((eyeCoordinate.xyz / eyeCoordinate.w) - downOrLeftEC) * useDownOrLeft; } #endif // NORMAL_EC void main(void) { #ifdef REQUIRES_EC float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, gl_FragCoord.xy / czm_viewport.zw)); vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); #endif #ifdef REQUIRES_WC vec4 worldCoordinate4 = czm_inverseView * eyeCoordinate; vec3 worldCoordinate = worldCoordinate4.xyz / worldCoordinate4.w; #endif #ifdef TEXTURE_COORDINATES vec2 uv; #ifdef SPHERICAL // Treat world coords as a sphere normal for spherical coordinates vec2 sphericalLatLong = czm_approximateSphericalCoordinates(worldCoordinate); sphericalLatLong.y += v_uvMinAndSphericalLongitudeRotation.z; sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi); uv.x = (sphericalLatLong.y - v_sphericalExtents.y) * v_sphericalExtents.w; uv.y = (sphericalLatLong.x - v_sphericalExtents.x) * v_sphericalExtents.z; #else // SPHERICAL // Unpack planes and transform to eye space uv.x = czm_planeDistance(v_westPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.x; uv.y = czm_planeDistance(v_southPlane, eyeCoordinate.xyz / eyeCoordinate.w) * v_inversePlaneExtents.y; #endif // SPHERICAL #endif // TEXTURE_COORDINATES #ifdef PICK #ifdef CULL_FRAGMENTS // When classifying translucent geometry, logDepthOrDepth == 0.0 // indicates a region that should not be classified, possibly due to there // being opaque pixels there in another buffer. // Check for logDepthOrDepth != 0.0 to make sure this"
}