{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 124,
    "total_chunks": 194,
    "chunk_size": 7487,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.725Z"
  },
  "content": "the length of segment of the ray inside the atmosphere. // This value is larger near the \"circumference\", as it is further away from the camera. We use it to // brighten up that area of the ground atmosphere. const float transmittanceModifier = 0.5; float transmittance = transmittanceModifier + clamp(1.0 - groundAtmosphereColor.a, 0.0, 1.0); vec3 finalAtmosphereColor = finalColor.rgb + groundAtmosphereColor.rgb * transmittance; #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING)) float fadeInDist = u_nightFadeDistance.x; float fadeOutDist = u_nightFadeDistance.y; float sunlitAtmosphereIntensity = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.05, 1.0); float darken = clamp(dot(normalize(positionWC), atmosphereLightDirection), 0.0, 1.0); vec3 darkenendGroundAtmosphereColor = mix(groundAtmosphereColor.rgb, finalAtmosphereColor.rgb, darken); finalAtmosphereColor = mix(darkenendGroundAtmosphereColor, finalAtmosphereColor, sunlitAtmosphereIntensity); #endif #ifndef HDR finalAtmosphereColor.rgb = vec3(1.0) - exp(-fExposure * finalAtmosphereColor.rgb); #else finalAtmosphereColor.rgb = czm_saturation(finalAtmosphereColor.rgb, 1.6); #endif finalColor.rgb = mix(finalColor.rgb, finalAtmosphereColor.rgb, fade); #endif } #endif #ifdef UNDERGROUND_COLOR if (czm_backFacing()) { float distanceFromEllipsoid = max(czm_eyeHeight, 0.0); float distance = max(v_distance - distanceFromEllipsoid, 0.0); float blendAmount = interpolateByDistance(u_undergroundColorAlphaByDistance, distance); vec4 undergroundColor = vec4(u_undergroundColor.rgb, u_undergroundColor.a * blendAmount); finalColor = alphaBlend(undergroundColor, finalColor); } #endif #ifdef TRANSLUCENT if (inTranslucencyRectangle()) { vec4 alphaByDistance = gl_FrontFacing ? u_frontFaceAlphaByDistance : u_backFaceAlphaByDistance; finalColor.a *= interpolateByDistance(alphaByDistance, v_distance); } #endif out_FragColor = finalColor; } #ifdef SHOW_REFLECTIVE_OCEAN float waveFade(float edge0, float edge1, float x) { float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0); return pow(1.0 - y, 5.0); } float linearFade(float edge0, float edge1, float x) { return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0); } // Based on water rendering by Jonas Wagner: // http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog // low altitude wave settings const float oceanFrequencyLowAltitude = 825000.0; const float oceanAnimationSpeedLowAltitude = 0.004; const float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0; const float oceanSpecularIntensity = 0.5; // high altitude wave settings const float oceanFrequencyHighAltitude = 125000.0; const float oceanAnimationSpeedHighAltitude = 0.008; const float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0; vec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float maskValue, float fade) { vec3 positionToEyeEC = -positionEyeCoordinates; float positionToEyeECLength = length(positionToEyeEC); // The double normalize below works around a bug in Firefox on Android devices. vec3 normalizedPositionToEyeEC = normalize(normalize(positionToEyeEC)); // Fade out the waves as the camera moves far from the surface. float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength); #ifdef SHOW_OCEAN_WAVES // high altitude waves float time = czm_frameNumber * oceanAnimationSpeedHighAltitude; vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0); vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude); // low altitude waves time = czm_frameNumber * oceanAnimationSpeedLowAltitude; noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0); vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude); // blend the 2 wave layers based on distance to surface float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength); float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength); vec3 normalTangentSpace = (highAltitudeFade * normalTangentSpaceHighAltitude) + (lowAltitudeFade * normalTangentSpaceLowAltitude); normalTangentSpace = normalize(normalTangentSpace); // fade out the normal perturbation as we move farther from the water surface normalTangentSpace.xy *= waveIntensity; normalTangentSpace = normalize(normalTangentSpace); #else vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0); #endif vec3 normalEC = enuToEye * normalTangentSpace; const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6); // Use diffuse light to highlight the waves float diffuseIntensity = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * maskValue; vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity * (1.0 - fade); #ifdef SHOW_OCEAN_WAVES // Where diffuse light is low or non-existent, use wave highlights based solely on // the wave bumpiness and no particular light direction. float tsPerturbationRatio = normalTangentSpace.z; vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity); #else vec3 nonDiffuseHighlight = vec3(0.0); #endif // Add specular highlights in 3D, and in all modes when zoomed in. float specularIntensity = czm_getSpecular(czm_lightDirectionEC, normalizedPositionToEyeEC, normalEC, 10.0); float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), maskValue); float specular = specularIntensity * surfaceReflectance; #ifdef HDR specular *= 1.4; float e = 0.2; float d = 3.3; float c = 1.7; vec3 color = imageryColor.rgb + (c * (vec3(e) + imageryColor.rgb * d) * (diffuseHighlight + nonDiffuseHighlight + specular)); #else vec3 color = imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular; #endif return vec4(color, imageryColor.a); } #endif // #ifdef SHOW_REFLECTIVE_OCEAN `;var bbi=T(S(),1),Mv=`#ifdef QUANTIZATION_BITS12 in vec4 compressed0; in float compressed1; #else in vec4 position3DAndHeight; in vec4 textureCoordAndEncodedNormals; #endif #ifdef GEODETIC_SURFACE_NORMALS in vec3 geodeticSurfaceNormal; #endif #ifdef EXAGGERATION uniform vec2 u_verticalExaggerationAndRelativeHeight; #endif uniform vec3 u_center3D; uniform mat4 u_modifiedModelView; uniform mat4 u_modifiedModelViewProjection; uniform vec4 u_tileRectangle; // Uniforms for 2D Mercator projection uniform vec2 u_southAndNorthLatitude; uniform vec2 u_southMercatorYAndOneOverHeight; out vec3 v_positionMC; out vec3 v_positionEC; out vec3 v_textureCoordinates; out vec3 v_normalMC; out vec3 v_normalEC; #ifdef APPLY_MATERIAL out float v_slope; out float v_aspect; out float v_height; #endif #if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) out float v_distance; #endif #if defined(FOG) || defined(GROUND_ATMOSPHERE) out vec3 v_atmosphereRayleighColor; out vec3 v_atmosphereMieColor; out float v_atmosphereOpacity; #endif // These functions are generated at runtime. vec4 getPosition(vec3 position, float height, vec2 textureCoordinates); float get2DYPositionFraction(vec2 textureCoordinates); vec4 getPosition3DMode(vec3 position, float height, vec2 textureCoordinates) { return u_modifiedModelViewProjection * vec4(position, 1.0); } float get2DMercatorYPositionFraction(vec2 textureCoordinates) { // The width of a tile at level 11, in radians and assuming a"
}