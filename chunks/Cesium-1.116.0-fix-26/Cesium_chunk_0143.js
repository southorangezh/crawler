{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 143,
    "total_chunks": 194,
    "chunk_size": 6119,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.737Z"
  },
  "content": "CZM_SELECTED_FEATURE if (czm_selected()) { out_FragColor = vec4(rgb, 1.0); return; } #endif float luminance = czm_luminance(rgb); float darkness = luminance * gradations; darkness = (darkness - fract(darkness)) / gradations; out_FragColor = vec4(vec3(darkness), 1.0); } `;var wPi=T(S(),1),hF=`uniform sampler2D colorTexture; uniform sampler2D bloomTexture; uniform bool glowOnly; in vec2 v_textureCoordinates; void main(void) { vec4 color = texture(colorTexture, v_textureCoordinates); #ifdef CZM_SELECTED_FEATURE if (czm_selected()) { out_FragColor = color; return; } #endif vec4 bloom = texture(bloomTexture, v_textureCoordinates); out_FragColor = glowOnly ? bloom : bloom + color; } `;var APi=T(S(),1),fF=`uniform sampler2D colorTexture; uniform float brightness; in vec2 v_textureCoordinates; void main(void) { vec3 rgb = texture(colorTexture, v_textureCoordinates).rgb; vec3 target = vec3(0.0); out_FragColor = vec4(mix(target, rgb, brightness), 1.0); } `;var NPi=T(S(),1),pF=`uniform sampler2D colorTexture; uniform float contrast; uniform float brightness; in vec2 v_textureCoordinates; void main(void) { vec3 sceneColor = texture(colorTexture, v_textureCoordinates).xyz; sceneColor = czm_RGBToHSB(sceneColor); sceneColor.z += brightness; sceneColor = czm_HSBToRGB(sceneColor); float factor = (259.0 * (contrast + 255.0)) / (255.0 * (259.0 - contrast)); sceneColor = factor * (sceneColor - vec3(0.5)) + vec3(0.5); out_FragColor = vec4(sceneColor, 1.0); } `;var UPi=T(S(),1),bF=`uniform sampler2D colorTexture; uniform sampler2D blurTexture; uniform sampler2D depthTexture; uniform float focalDistance; in vec2 v_textureCoordinates; vec4 toEye(vec2 uv, float depth) { vec2 xy = vec2((uv.x * 2.0 - 1.0), ((1.0 - uv.y) * 2.0 - 1.0)); vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0); posInCamera = posInCamera / posInCamera.w; return posInCamera; } float computeDepthBlur(float depth) { float f; if (depth < focalDistance) { f = (focalDistance - depth) / (focalDistance - czm_currentFrustum.x); } else { f = (depth - focalDistance) / (czm_currentFrustum.y - focalDistance); f = pow(f, 0.1); } f *= f; f = clamp(f, 0.0, 1.0); return pow(f, 0.5); } void main(void) { float depth = czm_readDepth(depthTexture, v_textureCoordinates); vec4 posInCamera = toEye(v_textureCoordinates, depth); float d = computeDepthBlur(-posInCamera.z); out_FragColor = mix(texture(colorTexture, v_textureCoordinates), texture(blurTexture, v_textureCoordinates), d); } `;var BPi=T(S(),1),yF=`uniform sampler2D depthTexture; in vec2 v_textureCoordinates; void main(void) { float depth = czm_readDepth(depthTexture, v_textureCoordinates); out_FragColor = vec4(vec3(depth), 1.0); } `;var OPi=T(S(),1),gF=`uniform sampler2D depthTexture; uniform float length; uniform vec4 color; in vec2 v_textureCoordinates; void main(void) { float directions[3]; directions[0] = -1.0; directions[1] = 0.0; directions[2] = 1.0; float scalars[3]; scalars[0] = 3.0; scalars[1] = 10.0; scalars[2] = 3.0; float padx = czm_pixelRatio / czm_viewport.z; float pady = czm_pixelRatio / czm_viewport.w; #ifdef CZM_SELECTED_FEATURE bool selected = false; for (int i = 0; i < 3; ++i) { float dir = directions[i]; selected = selected || czm_selected(vec2(-padx, dir * pady)); selected = selected || czm_selected(vec2(padx, dir * pady)); selected = selected || czm_selected(vec2(dir * padx, -pady)); selected = selected || czm_selected(vec2(dir * padx, pady)); if (selected) { break; } } if (!selected) { out_FragColor = vec4(color.rgb, 0.0); return; } #endif float horizEdge = 0.0; float vertEdge = 0.0; for (int i = 0; i < 3; ++i) { float dir = directions[i]; float scale = scalars[i]; horizEdge -= texture(depthTexture, v_textureCoordinates + vec2(-padx, dir * pady)).x * scale; horizEdge += texture(depthTexture, v_textureCoordinates + vec2(padx, dir * pady)).x * scale; vertEdge -= texture(depthTexture, v_textureCoordinates + vec2(dir * padx, -pady)).x * scale; vertEdge += texture(depthTexture, v_textureCoordinates + vec2(dir * padx, pady)).x * scale; } float len = sqrt(horizEdge * horizEdge + vertEdge * vertEdge); out_FragColor = vec4(color.rgb, len > length ? color.a : 0.0); } `;var HPi=T(S(),1),xF=`uniform sampler2D colorTexture; in vec2 v_textureCoordinates; #ifdef AUTO_EXPOSURE uniform sampler2D autoExposure; #endif // See slides 142 and 143: // http://www.gdcvault.com/play/1012459/Uncharted_2__HDR_Lighting void main() { vec4 fragmentColor = texture(colorTexture, v_textureCoordinates); vec3 color = fragmentColor.rgb; #ifdef AUTO_EXPOSURE float exposure = texture(autoExposure, vec2(0.5)).r; color /= exposure; #endif const float A = 0.22; // shoulder strength const float B = 0.30; // linear strength const float C = 0.10; // linear angle const float D = 0.20; // toe strength const float E = 0.01; // toe numerator const float F = 0.30; // toe denominator const float white = 11.2; // linear white point value vec3 c = ((color * (A * color + C * B) + D * E) / (color * ( A * color + B) + D * F)) - E / F; float w = ((white * (A * white + C * B) + D * E) / (white * ( A * white + B) + D * F)) - E / F; c = czm_inverseGamma(c / w); out_FragColor = vec4(c, fragmentColor.a); } `;var JPi=T(S(),1),_F=`in vec2 v_textureCoordinates; uniform sampler2D colorTexture; const float fxaaQualitySubpix = 0.5; const float fxaaQualityEdgeThreshold = 0.125; const float fxaaQualityEdgeThresholdMin = 0.0833; void main() { vec2 fxaaQualityRcpFrame = vec2(1.0) / czm_viewport.zw; vec4 color = FxaaPixelShader( v_textureCoordinates, colorTexture, fxaaQualityRcpFrame, fxaaQualitySubpix, fxaaQualityEdgeThreshold, fxaaQualityEdgeThresholdMin); float alpha = texture(colorTexture, v_textureCoordinates).a; out_FragColor = vec4(color.rgb, alpha); } `;var jPi=T(S(),1),Cg=`#define SAMPLES 8 uniform float delta; uniform float sigma; uniform float direction; // 0.0 for x direction, 1.0 for y direction uniform sampler2D colorTexture; #ifdef USE_STEP_SIZE uniform float stepSize; #else uniform vec2 step; #endif in vec2 v_textureCoordinates; // Incremental Computation of the Gaussian: // https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch40.html void"
}