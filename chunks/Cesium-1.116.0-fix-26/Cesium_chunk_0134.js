{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 134,
    "total_chunks": 194,
    "chunk_size": 16837,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.731Z"
  },
  "content": "= normalize(positionMC / u_radii); vec3 normalMC = geodeticNormal * side; // normalized surface normal (always facing the viewer) in model coordinates vec3 normalEC = normalize(czm_normal * normalMC); // normalized surface normal in eye coordinates vec2 st = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal); vec3 positionToEyeEC = -positionEC; czm_materialInput materialInput; materialInput.s = st.s; materialInput.st = st; materialInput.str = (positionMC + u_radii) / u_radii; materialInput.normalEC = normalEC; materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC); materialInput.positionToEyeEC = positionToEyeEC; czm_material material = czm_getMaterial(materialInput); #ifdef ONLY_SUN_LIGHTING return czm_private_phong(normalize(positionToEyeEC), material, czm_sunDirectionEC); #else return czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC); #endif } void main() { // PERFORMANCE_TODO: When dynamic branching is available, compute ratio of maximum and minimum radii // in the vertex shader. Only when it is larger than some constant, march along the ray. // Otherwise perform one intersection test which will be the common case. // Test if the ray intersects a sphere with the ellipsoid's maximum radius. // For very oblate ellipsoids, using the ellipsoid's radii for an intersection test // may cause false negatives. This will discard fragments before marching the ray forward. float maxRadius = max(u_radii.x, max(u_radii.y, u_radii.z)) * 1.5; vec3 direction = normalize(v_positionEC); vec3 ellipsoidCenter = czm_modelView[3].xyz; float t1 = -1.0; float t2 = -1.0; float b = -2.0 * dot(direction, ellipsoidCenter); float c = dot(ellipsoidCenter, ellipsoidCenter) - maxRadius * maxRadius; float discriminant = b * b - 4.0 * c; if (discriminant >= 0.0) { t1 = (-b - sqrt(discriminant)) * 0.5; t2 = (-b + sqrt(discriminant)) * 0.5; } if (t1 < 0.0 && t2 < 0.0) { discard; } float t = min(t1, t2); if (t < 0.0) { t = 0.0; } // March ray forward to intersection with larger sphere and find czm_ray ray = czm_ray(t * direction, direction); vec3 ellipsoid_inverseRadii = vec3(1.0 / u_radii.x, 1.0 / u_radii.y, 1.0 / u_radii.z); czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoidCenter, ellipsoid_inverseRadii); if (czm_isEmpty(intersection)) { discard; } // If the viewer is outside, compute outsideFaceColor, with normals facing outward. vec4 outsideFaceColor = (intersection.start != 0.0) ? computeEllipsoidColor(ray, intersection.start, 1.0) : vec4(0.0); // If the viewer either is inside or can see inside, compute insideFaceColor, with normals facing inward. vec4 insideFaceColor = (outsideFaceColor.a < 1.0) ? computeEllipsoidColor(ray, intersection.stop, -1.0) : vec4(0.0); out_FragColor = mix(insideFaceColor, outsideFaceColor, outsideFaceColor.a); out_FragColor.a = 1.0 - (1.0 - insideFaceColor.a) * (1.0 - outsideFaceColor.a); #if (defined(WRITE_DEPTH) && (__VERSION__ == 300 || defined(GL_EXT_frag_depth))) t = (intersection.start != 0.0) ? intersection.start : intersection.stop; vec3 positionEC = czm_pointAlongRay(ray, t); vec4 positionCC = czm_projection * vec4(positionEC, 1.0); #ifdef LOG_DEPTH czm_writeLogDepth(1.0 + positionCC.w); #else float z = positionCC.z / positionCC.w; float n = czm_depthRange.near; float f = czm_depthRange.far; gl_FragDepth = (z * (f - n) + f + n) * 0.5; #endif #endif } `;var aLi=T(S(),1),NV=`in vec3 position; uniform vec3 u_radii; out vec3 v_positionEC; void main() { // In the vertex data, the cube goes from (-1.0, -1.0, -1.0) to (1.0, 1.0, 1.0) in model coordinates. // Scale to consider the radii. We could also do this once on the CPU when using the BoxGeometry, // but doing it here allows us to change the radii without rewriting the vertex data, and // allows all ellipsoids to reuse the same vertex data. vec4 p = vec4(u_radii * position, 1.0); v_positionEC = (czm_modelView * p).xyz; // position in eye coordinates gl_Position = czm_modelViewProjection * p; // position in clip coordinates // With multi-frustum, when the ellipsoid primitive is positioned on the intersection of two frustums // and close to terrain, the terrain (writes depth) in the closest frustum can overwrite part of the // ellipsoid (does not write depth) that was rendered in the farther frustum. // // Here, we clamp the depth in the vertex shader to avoid being overwritten; however, this creates // artifacts since some fragments can be alpha blended twice. This is solved by only rendering // the ellipsoid in the closest frustum to the viewer. gl_Position.z = clamp(gl_Position.z, czm_depthRange.near, czm_depthRange.far); czm_vertexLogDepth(); } `;var k4={position:0};function VD(e){e=g(e,g.EMPTY_OBJECT),this.center=h.clone(g(e.center,h.ZERO)),this._center=new h,this.radii=h.clone(e.radii),this._radii=new h,this._oneOverEllipsoidRadiiSquared=new h,this._boundingSphere=new ce,this.modelMatrix=M.clone(g(e.modelMatrix,M.IDENTITY)),this._modelMatrix=new M,this._computedModelMatrix=new M,this.show=g(e.show,!0),this.material=g(e.material,ki.fromType(ki.ColorType)),this._material=void 0,this._translucent=void 0,this.id=e.id,this._id=void 0,this.debugShowBoundingVolume=g(e.debugShowBoundingVolume,!1),this.onlySunLighting=g(e.onlySunLighting,!1),this._onlySunLighting=!1,this._depthTestEnabled=g(e.depthTestEnabled,!0),this._useLogDepth=!1,this._sp=void 0,this._rs=void 0,this._va=void 0,this._pickSP=void 0,this._pickId=void 0,this._colorCommand=new je({owner:g(e._owner,this)}),this._pickCommand=new je({owner:g(e._owner,this),pickOnly:!0});let t=this;this._uniforms={u_radii:function(){return t.radii},u_oneOverEllipsoidRadiiSquared:function(){return t._oneOverEllipsoidRadiiSquared}},this._pickUniforms={czm_pickColor:function(){return t._pickId.color}}}function oat(e){let t=e.cache.ellipsoidPrimitive_vertexArray;if(l(t))return t;let n=Tl.createGeometry(Tl.fromDimensions({dimensions:new h(2,2,2),vertexFormat:Pe.POSITION_ONLY}));return t=ti.fromGeometry({context:e,geometry:n,attributeLocations:k4,bufferUsage:Me.STATIC_DRAW,interleave:!0}),e.cache.ellipsoidPrimitive_vertexArray=t,t}VD.prototype.update=function(e){if(!this.show||e.mode!==ie.SCENE3D||!l(this.center)||!l(this.radii))return;let t=e.context,n=this.material.isTranslucent(),i=this._translucent!==n;(!l(this._rs)||i)&&(this._translucent=n,this._rs=Ne.fromCache({cull:{enabled:!0,face:mi.FRONT},depthTest:{enabled:this._depthTestEnabled},depthMask:!n&&t.fragmentDepth,blending:n?un.ALPHA_BLEND:void 0})),l(this._va)||(this._va=oat(t));let o=!1,r=this.radii;if(!h.equals(this._radii,r)){h.clone(r,this._radii);let x=this._oneOverEllipsoidRadiiSquared;x.x=1/(r.x*r.x),x.y=1/(r.y*r.y),x.z=1/(r.z*r.z),o=!0}(!M.equals(this.modelMatrix,this._modelMatrix)||!h.equals(this.center,this._center))&&(M.clone(this.modelMatrix,this._modelMatrix),h.clone(this.center,this._center),M.multiplyByTranslation(this.modelMatrix,this.center,this._computedModelMatrix),o=!0),o&&(h.clone(h.ZERO,this._boundingSphere.center),this._boundingSphere.radius=h.maximumComponent(r),ce.transform(this._boundingSphere,this._computedModelMatrix,this._boundingSphere));let s=this._material!==this.material;this._material=this.material,this._material.update(t);let a=this.onlySunLighting!==this._onlySunLighting;this._onlySunLighting=this.onlySunLighting;let c=e.useLogDepth,d=this._useLogDepth!==c;this._useLogDepth=c;let u=this._colorCommand,m,p;(s||a||i||d)&&(m=new Ue({sources:[NV]}),p=new Ue({sources:[this.material.shaderSource,MV]}),this.onlySunLighting&&p.defines.push(\"ONLY_SUN_LIGHTING\"),!n&&t.fragmentDepth&&p.defines.push(\"WRITE_DEPTH\"),this._useLogDepth&&(m.defines.push(\"LOG_DEPTH\"),p.defines.push(\"LOG_DEPTH\")),this._sp=Ht.replaceCache({context:t,shaderProgram:this._sp,vertexShaderSource:m,fragmentShaderSource:p,attributeLocations:k4}),u.vertexArray=this._va,u.renderState=this._rs,u.shaderProgram=this._sp,u.uniformMap=Ct(this._uniforms,this.material._uniforms),u.executeInClosestFrustum=n);let b=e.commandList,f=e.passes;if(f.render&&(u.boundingVolume=this._boundingSphere,u.debugShowBoundingVolume=this.debugShowBoundingVolume,u.modelMatrix=this._computedModelMatrix,u.pass=n?Ze.TRANSLUCENT:Ze.OPAQUE,b.push(u)),f.pick){let x=this._pickCommand;(!l(this._pickId)||this._id!==this.id)&&(this._id=this.id,this._pickId=this._pickId&&this._pickId.destroy(),this._pickId=t.createPickId({primitive:this,id:this.id})),(s||a||!l(this._pickSP)||d)&&(m=new Ue({sources:[NV]}),p=new Ue({sources:[this.material.shaderSource,MV],pickColorQualifier:\"uniform\"}),this.onlySunLighting&&p.defines.push(\"ONLY_SUN_LIGHTING\"),!n&&t.fragmentDepth&&p.defines.push(\"WRITE_DEPTH\"),this._useLogDepth&&(m.defines.push(\"LOG_DEPTH\"),p.defines.push(\"LOG_DEPTH\")),this._pickSP=Ht.replaceCache({context:t,shaderProgram:this._pickSP,vertexShaderSource:m,fragmentShaderSource:p,attributeLocations:k4}),x.vertexArray=this._va,x.renderState=this._rs,x.shaderProgram=this._pickSP,x.uniformMap=Ct(Ct(this._uniforms,this._pickUniforms),this.material._uniforms),x.executeInClosestFrustum=n),x.boundingVolume=this._boundingSphere,x.modelMatrix=this._computedModelMatrix,x.pass=n?Ze.TRANSLUCENT:Ze.OPAQUE,b.push(x)}};VD.prototype.isDestroyed=function(){return!1};VD.prototype.destroy=function(){return this._sp=this._sp&&this._sp.destroy(),this._pickSP=this._pickSP&&this._pickSP.destroy(),this._pickId=this._pickId&&this._pickId.destroy(),me(this)};var Tw=VD;function Sw(e){e=g(e,g.EMPTY_OBJECT);let t=e.textureUrl;l(t)||(t=on(\"Assets/Textures/moonSmall.jpg\")),this.show=g(e.show,!0),this.textureUrl=t,this._ellipsoid=g(e.ellipsoid,oe.MOON),this.onlySunLighting=g(e.onlySunLighting,!0),this._ellipsoidPrimitive=new Tw({radii:this.ellipsoid.radii,material:ki.fromType(ki.ImageType),depthTestEnabled:!1,_owner:this}),this._ellipsoidPrimitive.material.translucent=!1,this._axes=new _w}Object.defineProperties(Sw.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}});var LD=new $,rat=new $,sat=new h,ZD=[];Sw.prototype.update=function(e){if(!this.show)return;let t=this._ellipsoidPrimitive;t.material.uniforms.image=this.textureUrl,t.onlySunLighting=this.onlySunLighting;let n=e.time;l(Wt.computeIcrfToFixedMatrix(n,LD))||Wt.computeTemeToPseudoFixedMatrix(n,LD);let i=this._axes.evaluate(n,rat);$.transpose(i,i),$.multiply(LD,i,i);let o=Eb.computeMoonPositionInEarthInertialFrame(n,sat);$.multiplyByVector(LD,o,o),M.fromRotationTranslation(i,o,t.modelMatrix);let r=e.commandList;return e.commandList=ZD,ZD.length=0,t.update(e),e.commandList=r,ZD.length===1?ZD[0]:void 0};Sw.prototype.isDestroyed=function(){return!1};Sw.prototype.destroy=function(){return this._ellipsoidPrimitive=this._ellipsoidPrimitive&&this._ellipsoidPrimitive.destroy(),me(this)};var Cw=Sw;var IUi=T(S(),1);var KLi=T(S(),1);var U4=[],D4=[];function aat(e,t,n,i,o,r){let s=o-i+1,a=r-o,c=U4,d=D4,u,m;for(u=0;u<s;++u)c[u]=e[i+u];for(m=0;m<a;++m)d[m]=e[o+m+1];u=0,m=0;for(let p=i;p<=r;++p){let b=c[u],f=d[m];u<s&&(m>=a||t(b,f,n)<=0)?(e[p]=b,++u):m<a&&(e[p]=f,++m)}}function B4(e,t,n,i,o){if(i>=o)return;let r=Math.floor((i+o)*.5);B4(e,t,n,i,r),B4(e,t,n,r+1,o),aat(e,t,n,i,r,o)}function cat(e,t,n){let i=e.length,o=Math.ceil(i*.5);U4.length=o,D4.length=o,B4(e,t,n,0,i-1),U4.length=0,D4.length=0}var eb=cat;var oZi=T(S(),1);function _c(e,t){this._occluderPosition=h.clone(e.center),this._occluderRadius=e.radius,this._horizonDistance=0,this._horizonPlaneNormal=void 0,this._horizonPlanePosition=void 0,this._cameraPosition=void 0,this.cameraPosition=t}var RD=new h;Object.defineProperties(_c.prototype,{position:{get:function(){return this._occluderPosition}},radius:{get:function(){return this._occluderRadius}},cameraPosition:{set:function(e){e=h.clone(e,this._cameraPosition);let t=h.subtract(this._occluderPosition,e,RD),n=h.magnitudeSquared(t),i=this._occluderRadius*this._occluderRadius,o,r,s;if(n>i){o=Math.sqrt(n-i),n=1/Math.sqrt(n),r=h.multiplyByScalar(t,n,RD);let a=o*o*n;s=h.add(e,h.multiplyByScalar(r,a,RD),RD)}else o=Number.MAX_VALUE;this._horizonDistance=o,this._horizonPlaneNormal=r,this._horizonPlanePosition=s,this._cameraPosition=e}}});_c.fromBoundingSphere=function(e,t,n){return l(n)?(h.clone(e.center,n._occluderPosition),n._occluderRadius=e.radius,n.cameraPosition=t,n):new _c(e,t)};var Nye=new h;_c.prototype.isPointVisible=function(e){if(this._horizonDistance!==Number.MAX_VALUE){let t=h.subtract(e,this._occluderPosition,Nye),n=this._occluderRadius;if(n=h.magnitudeSquared(t)-n*n,n>0)return n=Math.sqrt(n)+this._horizonDistance,t=h.subtract(e,this._cameraPosition,t),n*n>h.magnitudeSquared(t)}return!1};var lat=new h;_c.prototype.isBoundingSphereVisible=function(e){let t=h.clone(e.center,lat),n=e.radius;if(this._horizonDistance!==Number.MAX_VALUE){let i=h.subtract(t,this._occluderPosition,Nye),o=this._occluderRadius-n;if(o=h.magnitudeSquared(i)-o*o,n<this._occluderRadius)return o>0?(o=Math.sqrt(o)+this._horizonDistance,i=h.subtract(t,this._cameraPosition,i),o*o+n*n>h.magnitudeSquared(i)):!1;if(o>0){i=h.subtract(t,this._cameraPosition,i);let r=h.magnitudeSquared(i),s=this._occluderRadius*this._occluderRadius,a=n*n;return(this._horizonDistance*this._horizonDistance+s)*a>r*s?!0:(o=Math.sqrt(o)+this._horizonDistance,o*o+a>r)}return!0}return!1};var dat=new h;_c.prototype.computeVisibility=function(e){let t=h.clone(e.center),n=e.radius;if(n>this._occluderRadius)return lr.FULL;if(this._horizonDistance!==Number.MAX_VALUE){let i=h.subtract(t,this._occluderPosition,dat),o=this._occluderRadius-n,r=h.magnitudeSquared(i);if(o=r-o*o,o>0){o=Math.sqrt(o)+this._horizonDistance,i=h.subtract(t,this._cameraPosition,i);let s=h.magnitudeSquared(i);return o*o+n*n<s?lr.NONE:(o=this._occluderRadius+n,o=r-o*o,o>0?(o=Math.sqrt(o)+this._horizonDistance,s<o*o+n*n?lr.FULL:lr.PARTIAL):(i=h.subtract(t,this._horizonPlanePosition,i),h.dot(i,this._horizonPlaneNormal)>-n?lr.PARTIAL:lr.FULL))}}return lr.NONE};var GD=new h;_c.computeOccludeePoint=function(e,t,n){let i=h.clone(t),o=h.clone(e.center),r=e.radius,s=n.length,a=h.normalize(h.subtract(i,o,GD),GD),c=-h.dot(a,o),d=_c._anyRotationVector(o,a,c),u=_c._horizonToPlaneNormalDotProduct(e,a,c,d,n[0]);if(!u)return;let m;for(let b=1;b<s;++b){if(m=_c._horizonToPlaneNormalDotProduct(e,a,c,d,n[b]),!m)return;m<u&&(u=m)}if(u<.0017453283658983088)return;let p=r/u;return h.add(o,h.multiplyByScalar(a,p,GD),GD)};var uat=[];_c.computeOccludeePointFromRectangle=function(e,t){t=g(t,oe.WGS84);let n=le.subsample(e,t,0,uat),i=ce.fromPoints(n),o=h.ZERO;if(!h.equals(o,i.center))return _c.computeOccludeePoint(new ce(o,t.minimumRadius),i.center,n)};var mat=new h;_c._anyRotationVector=function(e,t,n){let i=h.abs(t,mat),o=i.x>i.y?0:1;(o===0&&i.z>i.x||o===1&&i.z>i.y)&&(o=2);let r=new h,s;o===0?(i.x=e.x,i.y=e.y+1,i.z=e.z+1,s=h.UNIT_X):o===1?(i.x=e.x+1,i.y=e.y,i.z=e.z+1,s=h.UNIT_Y):(i.x=e.x+1,i.y=e.y+1,i.z=e.z,s=h.UNIT_Z);let a=(h.dot(t,i)+n)/-h.dot(t,s);return h.normalize(h.subtract(h.add(i,h.multiplyByScalar(s,a,r),i),e,i),i)};var hat=new h;_c._rotationVector=function(e,t,n,i,o){let r=h.subtract(i,e,hat);if(r=h.normalize(r,r),h.dot(t,r)<.9999999847691291){let s=h.cross(t,r,r);if(h.magnitude(s)>P.EPSILON13)return h.normalize(s,new h)}return o};var Y4=new h,fat=new h,ED=new h,Mye=new h;_c._horizonToPlaneNormalDotProduct=function(e,t,n,i,o){let r=h.clone(o,Y4),s=h.clone(e.center,fat),a=e.radius,c=h.subtract(s,r,ED),d=h.magnitudeSquared(c),u=a*a;if(d<u)return!1;let m=d-u,p=Math.sqrt(m),f=1/Math.sqrt(d),_=p*f*p;c=h.normalize(c,c);let C=h.add(r,h.multiplyByScalar(c,_,Mye),Mye),V=Math.sqrt(m-_*_),L=this._rotationVector(s,t,n,r,i),R=h.fromElements(L.x*L.x*c.x+(L.x*L.y-L.z)*c.y+(L.x*L.z+L.y)*c.z,(L.x*L.y+L.z)*c.x+L.y*L.y*c.y+(L.y*L.z-L.x)*c.z,(L.x*L.z-L.y)*c.x+(L.y*L.z+L.x)*c.y+L.z*L.z*c.z,Y4);R=h.normalize(R,R);let G=h.multiplyByScalar(R,V,Y4);L=h.normalize(h.subtract(h.add(C,G,ED),s,ED),ED);let X=h.dot(t,L);L=h.normalize(h.subtract(h.subtract(C,G,L),s,L),L);let v=h.dot(t,L);return X<v?X:v};var Vw=_c;var xZi=T(S(),1);var hZi=T(S(),1);function Bf(e){e=g(e,g.EMPTY_OBJECT),this.left=e.left,this._left=void 0,this.right=e.right,this._right=void 0,this.top=e.top,this._top=void 0,this.bottom=e.bottom,this._bottom=void 0,this.near=g(e.near,1),this._near=this.near,this.far=g(e.far,5e8),this._far=this.far,this._cullingVolume=new os,this._perspectiveMatrix=new M,this._infinitePerspective=new M}function O4(e){let t=e.top,n=e.bottom,i=e.right,o=e.left,r=e.near,s=e.far;(t!==e._top||n!==e._bottom||o!==e._left||i!==e._right||r!==e._near||s!==e._far)&&(e._left=o,e._right=i,e._top=t,e._bottom=n,e._near=r,e._far=s,e._perspectiveMatrix=M.computePerspectiveOffCenter(o,i,n,t,r,s,e._perspectiveMatrix),e._infinitePerspective=M.computeInfinitePerspectiveOffCenter(o,i,n,t,r,e._infinitePerspective))}Object.defineProperties(Bf.prototype,{projectionMatrix:{get:function(){return O4(this),this._perspectiveMatrix}},infiniteProjectionMatrix:{get:function(){return"
}