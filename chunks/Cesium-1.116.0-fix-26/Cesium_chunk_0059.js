{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 59,
    "total_chunks": 194,
    "chunk_size": 7764,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.681Z"
  },
  "content": "absEndPlaneDistance, startPlane3D.xyz, endPlane3D.xyz); vec3 upOrDown = normalize(cross(rightPlane3D.xyz, planeDirection)); // Points \"up\" for start plane, \"down\" at end plane. vec3 normalEC = normalize(cross(planeDirection, upOrDown)); // In practice, the opposite seems to work too. // Nudge the top vertex upwards to prevent flickering vec3 geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc3D)); geodeticSurfaceNormal *= float(0.0 <= rightNormalAndTextureCoordinateNormalizationY.w && rightNormalAndTextureCoordinateNormalizationY.w <= 1.0); geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT; positionEc3D.xyz += geodeticSurfaceNormal; // Determine if this vertex is on the \"left\" or \"right\" normalEC *= sign(endNormalAndTextureCoordinateNormalizationX.w); // A \"perfect\" implementation would push along normals according to the angle against forward. // In practice, just pushing the normal out by halfWidth is sufficient for morph views. positionEc3D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc3D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera) // ****** 2D ****** // Check distance to the end plane and start plane, pick the plane that is closer vec4 positionEc2D = czm_modelViewRelativeToEye * czm_translateRelativeToEye(position2DHigh.zxy, position2DLow.zxy); // w = 1.0, see czm_computePosition absStartPlaneDistance = abs(czm_planeDistance(startPlane2D, positionEc2D.xyz)); absEndPlaneDistance = abs(czm_planeDistance(endPlane2D, positionEc2D.xyz)); planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlane2D.xyz, endPlane2D.xyz); upOrDown = normalize(cross(rightPlane2D.xyz, planeDirection)); // Points \"up\" for start plane, \"down\" at end plane. normalEC = normalize(cross(planeDirection, upOrDown)); // In practice, the opposite seems to work too. // Nudge the top vertex upwards to prevent flickering geodeticSurfaceNormal = normalize(cross(normalEC, forwardEc2D)); geodeticSurfaceNormal *= float(0.0 <= texcoordNormalization2D.y && texcoordNormalization2D.y <= 1.0); geodeticSurfaceNormal *= MAX_TERRAIN_HEIGHT; positionEc2D.xyz += geodeticSurfaceNormal; // Determine if this vertex is on the \"left\" or \"right\" normalEC *= sign(texcoordNormalization2D.x); #ifndef PER_INSTANCE_COLOR // Use vertex's sidedness to compute its texture coordinate. v_texcoordT = clamp(sign(texcoordNormalization2D.x), 0.0, 1.0); #endif // A \"perfect\" implementation would push along normals according to the angle against forward. // In practice, just pushing the normal out by halfWidth is sufficient for morph views. positionEc2D.xyz += halfWidth * max(0.0, czm_metersPerPixel(positionEc2D)) * normalEC; // prevent artifacts when czm_metersPerPixel is negative (behind camera) // Blend for actual position gl_Position = czm_projection * mix(positionEc2D, positionEc3D, czm_morphTime); #ifdef ANGLE_VARYING // Approximate relative screen space direction of the line. vec2 approxLineDirection = normalize(vec2(v_forwardDirectionEC.x, -v_forwardDirectionEC.y)); approxLineDirection.y = czm_branchFreeTernary(approxLineDirection.x == 0.0 && approxLineDirection.y == 0.0, -1.0, approxLineDirection.y); v_polylineAngle = czm_fastApproximateAtan(approxLineDirection.x, approxLineDirection.y); #endif } `;var B4t=T(S(),1),BE=`in vec3 position3DHigh; in vec3 position3DLow; // In 2D and in 3D, texture coordinate normalization component signs encodes: // * X sign - sidedness relative to right plane // * Y sign - is negative OR magnitude is greater than 1.0 if vertex is on bottom of volume #ifndef COLUMBUS_VIEW_2D in vec4 startHiAndForwardOffsetX; in vec4 startLoAndForwardOffsetY; in vec4 startNormalAndForwardOffsetZ; in vec4 endNormalAndTextureCoordinateNormalizationX; in vec4 rightNormalAndTextureCoordinateNormalizationY; #else in vec4 startHiLo2D; in vec4 offsetAndRight2D; in vec4 startEndNormals2D; in vec2 texcoordNormalization2D; #endif in float batchId; out vec4 v_startPlaneNormalEcAndHalfWidth; out vec4 v_endPlaneNormalEcAndBatchId; out vec4 v_rightPlaneEC; out vec4 v_endEcAndStartEcX; out vec4 v_texcoordNormalizationAndStartEcYZ; // @uranus change \\u65B0\\u589E\\u53D8\\u91CF\\u7528\\u6765\\u8BA1\\u7B97\\u8FB9\\u7F18\\u6297\\u952F\\u9F7F out float v_aa_width; out float v_aa_out; // For materials #ifdef WIDTH_VARYING out float v_width; #endif #ifdef ANGLE_VARYING out float v_polylineAngle; #endif #ifdef PER_INSTANCE_COLOR out vec4 v_color; #endif void main() { #ifdef COLUMBUS_VIEW_2D vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(vec3(0.0, startHiLo2D.xy), vec3(0.0, startHiLo2D.zw))).xyz; vec3 forwardDirectionEC = czm_normal * vec3(0.0, offsetAndRight2D.xy); vec3 ecEnd = forwardDirectionEC + ecStart; forwardDirectionEC = normalize(forwardDirectionEC); // Right plane v_rightPlaneEC.xyz = czm_normal * vec3(0.0, offsetAndRight2D.zw); v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart); // start plane vec4 startPlaneEC; startPlaneEC.xyz = czm_normal * vec3(0.0, startEndNormals2D.xy); startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart); // end plane vec4 endPlaneEC; endPlaneEC.xyz = czm_normal * vec3(0.0, startEndNormals2D.zw); endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd); v_texcoordNormalizationAndStartEcYZ.x = abs(texcoordNormalization2D.x); v_texcoordNormalizationAndStartEcYZ.y = texcoordNormalization2D.y; #else // COLUMBUS_VIEW_2D vec3 ecStart = (czm_modelViewRelativeToEye * czm_translateRelativeToEye(startHiAndForwardOffsetX.xyz, startLoAndForwardOffsetY.xyz)).xyz; vec3 offset = czm_normal * vec3(startHiAndForwardOffsetX.w, startLoAndForwardOffsetY.w, startNormalAndForwardOffsetZ.w); vec3 ecEnd = ecStart + offset; vec3 forwardDirectionEC = normalize(offset); // start plane vec4 startPlaneEC; startPlaneEC.xyz = czm_normal * startNormalAndForwardOffsetZ.xyz; startPlaneEC.w = -dot(startPlaneEC.xyz, ecStart); // end plane vec4 endPlaneEC; endPlaneEC.xyz = czm_normal * endNormalAndTextureCoordinateNormalizationX.xyz; endPlaneEC.w = -dot(endPlaneEC.xyz, ecEnd); // Right plane v_rightPlaneEC.xyz = czm_normal * rightNormalAndTextureCoordinateNormalizationY.xyz; v_rightPlaneEC.w = -dot(v_rightPlaneEC.xyz, ecStart); v_texcoordNormalizationAndStartEcYZ.x = abs(endNormalAndTextureCoordinateNormalizationX.w); v_texcoordNormalizationAndStartEcYZ.y = rightNormalAndTextureCoordinateNormalizationY.w; #endif // COLUMBUS_VIEW_2D v_endEcAndStartEcX.xyz = ecEnd; v_endEcAndStartEcX.w = ecStart.x; v_texcoordNormalizationAndStartEcYZ.zw = ecStart.yz; #ifdef PER_INSTANCE_COLOR v_color = czm_batchTable_color(batchId); #endif // PER_INSTANCE_COLOR // Compute a normal along which to \"push\" the position out, extending the miter depending on view distance. // Position has already been \"pushed\" by unit length along miter normal, and miter normals are encoded in the planes. // Decode the normal to use at this specific vertex, push the position back, and then push to where it needs to be. vec4 positionRelativeToEye = czm_computePosition(); // Check distance to the end plane and start plane, pick the plane that is closer vec4 positionEC = czm_modelViewRelativeToEye * positionRelativeToEye; // w = 1.0, see czm_computePosition float absStartPlaneDistance = abs(czm_planeDistance(startPlaneEC, positionEC.xyz)); float absEndPlaneDistance = abs(czm_planeDistance(endPlaneEC, positionEC.xyz)); vec3 planeDirection = czm_branchFreeTernary(absStartPlaneDistance < absEndPlaneDistance, startPlaneEC.xyz, endPlaneEC.xyz); vec3 upOrDown = normalize(cross(v_rightPlaneEC.xyz, planeDirection)); // Points \"up\" for start plane, \"down\" at end plane. vec3 normalEC = normalize(cross(planeDirection, upOrDown)); // In practice, the opposite seems to work too. // Extrude bottom vertices downward for far view distances, like for GroundPrimitives"
}