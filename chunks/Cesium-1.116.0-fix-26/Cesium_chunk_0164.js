{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 164,
    "total_chunks": 194,
    "chunk_size": 7834,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.748Z"
  },
  "content": "the ray #if (INTERSECTION_COUNT > 1) initializeIntersections(ix); for (int i = 0; i < INTERSECTION_COUNT; ++i) { intersection = nextIntersection(ix); if (intersection.exit.w > 0.0) { // Set start to 0.0 when ray is inside the shape. intersection.entry.w = max(intersection.entry.w, 0.0); break; } } #else // Set start to 0.0 when ray is inside the shape. intersection.entry.w = max(intersection.entry.w, 0.0); #endif return intersection; } `;var GAi=T(S(),1),e9=`/* Box defines (set in Scene/VoxelBoxShape.js) #define BOX_HAS_SHAPE_BOUNDS */ #if defined(BOX_HAS_SHAPE_BOUNDS) uniform vec3 u_boxUvToShapeUvScale; uniform vec3 u_boxUvToShapeUvTranslate; #endif PointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) { // For BOX, UV space = shape space, so we can use positionUv as-is, // and the Jacobian is the identity matrix, except that a step of 1 // only spans half the shape space [-1, 1], so the identity is scaled. return PointJacobianT(positionUv, mat3(0.5)); } vec3 convertShapeToShapeUvSpace(in vec3 positionShape) { #if defined(BOX_HAS_SHAPE_BOUNDS) return positionShape * u_boxUvToShapeUvScale + u_boxUvToShapeUvTranslate; #else return positionShape; #endif } PointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) { PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv); pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point); return pointJacobian; } vec3 convertShapeUvToUvSpace(in vec3 shapeUv) { #if defined(BOX_HAS_SHAPE_BOUNDS) return (shapeUv - u_boxUvToShapeUvTranslate) / u_boxUvToShapeUvScale; #else return shapeUv; #endif } vec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) { #if defined(BOX_HAS_SHAPE_BOUNDS) return shapeUv / u_boxUvToShapeUvScale; #else return shapeUv; #endif }`;var XAi=T(S(),1),t9=`/* Cylinder defines (set in Scene/VoxelCylinderShape.js) #define CYLINDER_HAS_SHAPE_BOUNDS_RADIUS #define CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT #define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE #define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY #define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY #define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED */ #if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS) uniform vec2 u_cylinderUvToShapeUvRadius; // x = scale, y = offset #endif #if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT) uniform vec2 u_cylinderUvToShapeUvHeight; // x = scale, y = offset #endif #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE) uniform vec2 u_cylinderUvToShapeUvAngle; // x = scale, y = offset #endif #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY) uniform vec2 u_cylinderShapeUvAngleMinMax; #endif #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED) uniform float u_cylinderShapeUvAngleRangeZeroMid; #endif PointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) { // Convert from Cartesian UV space [0, 1] to Cartesian local space [-1, 1] vec3 position = positionUv * 2.0 - 1.0; float radius = length(position.xy); // [0, 1] vec3 radial = normalize(vec3(position.xy, 0.0)); // Shape space height is defined within [0, 1] float height = positionUv.z; // [0, 1] vec3 z = vec3(0.0, 0.0, 1.0); float angle = atan(position.y, position.x); vec3 east = normalize(vec3(-position.y, position.x, 0.0)); vec3 point = vec3(radius, height, angle); mat3 jacobianT = mat3(radial, z, east / length(position.xy)); return PointJacobianT(point, jacobianT); } vec3 convertShapeToShapeUvSpace(in vec3 positionShape) { float radius = positionShape.x; #if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS) radius = radius * u_cylinderUvToShapeUvRadius.x + u_cylinderUvToShapeUvRadius.y; #endif float height = positionShape.y; #if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT) height = height * u_cylinderUvToShapeUvHeight.x + u_cylinderUvToShapeUvHeight.y; #endif float angle = (positionShape.z + czm_pi) / czm_twoPi; #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE) #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED) // Comparing against u_cylinderShapeUvAngleMinMax has precision problems. u_cylinderShapeUvAngleRangeZeroMid is more conservative. angle += float(angle < u_cylinderShapeUvAngleRangeZeroMid); #endif // Avoid flickering from reading voxels from both sides of the -pi/+pi discontinuity. #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY) angle = angle > u_cylinderShapeUvAngleRangeZeroMid ? u_cylinderShapeUvAngleMinMax.x : angle; #elif defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY) angle = angle < u_cylinderShapeUvAngleRangeZeroMid ? u_cylinderShapeUvAngleMinMax.y : angle; #endif angle = angle * u_cylinderUvToShapeUvAngle.x + u_cylinderUvToShapeUvAngle.y; #endif return vec3(radius, height, angle); } PointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) { PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv); pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point); return pointJacobian; } vec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) { float radius = shapeUv.x; #if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS) radius /= u_cylinderUvToShapeUvRadius.x; #endif float height = shapeUv.y; #if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT) height /= u_cylinderUvToShapeUvHeight.x; #endif float angle = shapeUv.z * czm_twoPi; #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE) angle /= u_cylinderUvToShapeUvAngle.x; #endif return vec3(radius, height, angle); } `;var WAi=T(S(),1),n9=`/* Ellipsoid defines (set in Scene/VoxelEllipsoidShape.js) #define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY #define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY #define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE #define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED #define ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE */ uniform vec3 u_ellipsoidRadiiUv; // [0,1] uniform vec2 u_evoluteScale; // (radiiUv.x ^ 2 - radiiUv.z ^ 2) * vec2(1.0, -1.0) / radiiUv; uniform vec3 u_ellipsoidInverseRadiiSquaredUv; #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY) || defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY) || defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED) uniform vec3 u_ellipsoidShapeUvLongitudeMinMaxMid; #endif #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE) uniform vec2 u_ellipsoidUvToShapeUvLongitude; // x = scale, y = offset #endif #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE) uniform vec2 u_ellipsoidUvToShapeUvLatitude; // x = scale, y = offset #endif uniform float u_ellipsoidInverseHeightDifferenceUv; // robust iterative solution without trig functions // https://github.com/0xfaded/ellipse_demo/issues/1 // https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse // Extended to return radius of curvature along with the point vec3 nearestPointAndRadiusOnEllipse(vec2 pos, vec2 radii) { vec2 p = abs(pos); vec2 inverseRadii = 1.0 / radii; // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t)) // but store the cos and sin of t in a vec2 for efficiency. // Initial guess: t = pi/4 vec2 tTrigs = vec2(0.7071067811865476); // Initial guess of point on ellipsoid vec2 v = radii * tTrigs; // Center of curvature of the ellipse at v vec2 evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs; const int iterations = 3; for (int i = 0; i < iterations; ++i) { // Find the (approximate) intersection of p - evolute with the ellipsoid. vec2 q = normalize(p - evolute) * length(v - evolute); // Update the estimate of t. tTrigs = (q + evolute) * inverseRadii; tTrigs = normalize(clamp(tTrigs, 0.0, 1.0)); v = radii * tTrigs; evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs; } return vec3(v * sign(pos), length(v - evolute)); } PointJacobianT"
}