{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 121,
    "total_chunks": 194,
    "chunk_size": 19492,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.724Z"
  },
  "content": "Array(Ie),ct=new Array(Ie),Jt=W?new Array(Ie):[],be=Z?new Array(Ie):[],Ve=0,Bt=u,mt=0,Pi=d;p&&(--Ve,++Bt,--mt,++Pi);let Co=1e-5;for(let Ye=Ve;Ye<Bt;++Ye){let gt=Ye;gt<0&&(gt=0),gt>=u&&(gt=u-1);let zt=_.north-ee*gt;b?zt=a(zt):zt=s-2*o(r(-zt*x));let Gn=(zt-L)/(G-L);Gn=P.clamp(Gn,0,1);let Vo=Ye===Ve,tr=Ye===Bt-1;m>0&&(Vo?zt+=Co*J:tr&&(zt-=Co*J));let Da=t(zt),nr=n(zt),ir=pe*nr,zi;W&&(zi=(Li.geodeticLatitudeToMercatorAngle(zt)-Le)*Re);for(let ds=mt;ds<Pi;++ds){let es=ds;es<0&&(es=0),es>=d&&(es=d-1);let dl=gt*(d*B)+es*B,Uo;if(k===1)Uo=c[dl];else{Uo=0;let Xc;if(Y)for(Xc=0;Xc<k;++Xc)Uo=Uo*U+c[dl+Xc];else for(Xc=k-1;Xc>=0;--Xc)Uo=Uo*U+c[dl+Xc]}Uo=Uo*I+w,ae=Math.max(ae,Uo),_e=Math.min(_e,Uo);let ur=_.west+z*es;b?ur=a(ur):ur=ur*x;let Ec=(ur-V)/(R-V);Ec=P.clamp(Ec,0,1);let ul=gt*d+es;if(m>0){let Xc=ds===mt,Ah=ds===Pi-1,fM=Vo||tr||Xc||Ah;if((Vo||tr)&&(Xc||Ah))continue;fM&&(Uo-=m,Xc?(ul=Dt+(u-gt-1),ur-=Co*N):tr?ul=Dt+u+(d-es-1):Ah?(ul=Dt+u+d+gt,ur+=Co*N):Vo&&(ul=Dt+u+d+u+es))}let vi=Da*t(ur),ga=Da*n(ur),Tr=j*vi,kr=q*ga,xa=1/i(Tr*vi+kr*ga+ir*nr),yb=Tr*xa,_a=kr*xa,um=ir*xa,mm=new h;mm.x=yb+vi*Uo,mm.y=_a+ga*Uo,mm.z=um+nr*Uo,M.multiplyByPoint(Te,mm,l4),h.minimumByComponent(l4,ke,ke),h.maximumByComponent(l4,rt,rt),yt=Math.min(yt,Uo),ft[ul]=mm,ct[ul]=new D(Ec,Gn),Ke[ul]=Uo,W&&(Jt[ul]=zi),Z&&(be[ul]=f.geodeticSurfaceNormal(mm))}}let Es=ce.fromPoints(ft),$r;l(C)&&($r=Zn.fromRectangle(C,_e,ae,f));let Nr;v&&(Nr=new L0(f).computeHorizonCullingPointPossiblyUnderEllipsoid(X,ft,_e));let Qs=new vb(ke,rt,X),De=new gc(X,Qs,yt,ae,ye,!1,W,Z,F,A),et=new Float32Array(Ie*De.stride),qe=0;for(let Ye=0;Ye<Ie;++Ye)qe=De.encode(et,qe,ft[Ye],ct[Ye],Ke[Ye],void 0,Jt[Ye],be[Ye]);return{vertices:et,maximumHeight:ae,minimumHeight:_e,encoding:De,boundingSphere3D:Es,orientedBoundingBox:$r,occludeePointInScaledSpace:Nr}};var xV=Nf;var I0i=T(S(),1);function ug(){fe.throwInstantiationError()}Object.defineProperties(ug.prototype,{credits:{get:fe.throwInstantiationError},waterMask:{get:fe.throwInstantiationError}});ug.prototype.interpolateHeight=fe.throwInstantiationError;ug.prototype.isChildAvailable=fe.throwInstantiationError;ug.prototype.createMesh=fe.throwInstantiationError;ug.prototype.upsample=fe.throwInstantiationError;ug.prototype.wasCreatedByUpsampling=fe.throwInstantiationError;ug.maximumAsynchronousTasks=5;var gh=ug;var v0i=T(S(),1);function uit(e,t,n,i,o,r,s,a,c,d,u,m,p,b,f,x){this.center=e,this.vertices=t,this.stride=g(d,6),this.indices=n,this.indexCountWithoutSkirts=i,this.vertexCountWithoutSkirts=o,this.minimumHeight=r,this.maximumHeight=s,this.boundingSphere3D=a,this.occludeePointInScaledSpace=c,this.orientedBoundingBox=u,this.encoding=m,this.westIndicesSouthToNorth=p,this.southIndicesEastToWest=b,this.eastIndicesNorthToSouth=f,this.northIndicesWestToEast=x}var Qu=uit;var k0i=T(S(),1);function nl(){fe.throwInstantiationError()}Object.defineProperties(nl.prototype,{errorEvent:{get:fe.throwInstantiationError},credit:{get:fe.throwInstantiationError},tilingScheme:{get:fe.throwInstantiationError},hasWaterMask:{get:fe.throwInstantiationError},hasVertexNormals:{get:fe.throwInstantiationError},availability:{get:fe.throwInstantiationError}});var cbe=[];nl.getRegularGridIndices=function(e,t){let n=cbe[e];l(n)||(cbe[e]=n=[]);let i=n[t];return l(i)||(e*t<P.SIXTY_FOUR_KILOBYTES?i=n[t]=new Uint16Array((e-1)*(t-1)*6):i=n[t]=new Uint32Array((e-1)*(t-1)*6),mbe(e,t,i,0)),i};var lbe=[];nl.getRegularGridIndicesAndEdgeIndices=function(e,t){let n=lbe[e];l(n)||(lbe[e]=n=[]);let i=n[t];if(!l(i)){let o=nl.getRegularGridIndices(e,t),r=ube(e,t),s=r.westIndicesSouthToNorth,a=r.southIndicesEastToWest,c=r.eastIndicesNorthToSouth,d=r.northIndicesWestToEast;i=n[t]={indices:o,westIndicesSouthToNorth:s,southIndicesEastToWest:a,eastIndicesNorthToSouth:c,northIndicesWestToEast:d}}return i};var dbe=[];nl.getRegularGridAndSkirtIndicesAndEdgeIndices=function(e,t){let n=dbe[e];l(n)||(dbe[e]=n=[]);let i=n[t];if(!l(i)){let o=e*t,r=(e-1)*(t-1)*6,s=e*2+t*2,a=Math.max(0,s-4)*6,c=o+s,d=r+a,u=ube(e,t),m=u.westIndicesSouthToNorth,p=u.southIndicesEastToWest,b=u.eastIndicesNorthToSouth,f=u.northIndicesWestToEast,x=Ae.createTypedArray(c,d);mbe(e,t,x,0),nl.addSkirtIndices(m,p,b,f,o,x,r),i=n[t]={indices:x,westIndicesSouthToNorth:m,southIndicesEastToWest:p,eastIndicesNorthToSouth:b,northIndicesWestToEast:f,indexCountWithoutSkirts:r}}return i};nl.addSkirtIndices=function(e,t,n,i,o,r,s){let a=o;s=jU(e,a,r,s),a+=e.length,s=jU(t,a,r,s),a+=t.length,s=jU(n,a,r,s),a+=n.length,jU(i,a,r,s)};function ube(e,t){let n=new Array(t),i=new Array(e),o=new Array(t),r=new Array(e),s;for(s=0;s<e;++s)r[s]=s,i[s]=e*t-1-s;for(s=0;s<t;++s)o[s]=(s+1)*e-1,n[s]=(t-s-1)*e;return{westIndicesSouthToNorth:n,southIndicesEastToWest:i,eastIndicesNorthToSouth:o,northIndicesWestToEast:r}}function mbe(e,t,n,i){let o=0;for(let r=0;r<t-1;++r){for(let s=0;s<e-1;++s){let a=o,c=a+e,d=c+1,u=a+1;n[i++]=a,n[i++]=c,n[i++]=u,n[i++]=u,n[i++]=c,n[i++]=d,++o}++o}}function jU(e,t,n,i){let o=e[0],r=e.length;for(let s=1;s<r;++s){let a=e[s];n[i++]=o,n[i++]=a,n[i++]=t,n[i++]=t,n[i++]=a,n[i++]=t+1,o=a,++t}return i}nl.heightmapTerrainQuality=.25;nl.getEstimatedLevelZeroGeometricErrorForAHeightmap=function(e,t,n){return e.maximumRadius*2*Math.PI*nl.heightmapTerrainQuality/(t*n)};nl.prototype.requestTileGeometry=fe.throwInstantiationError;nl.prototype.getLevelMaximumGeometricError=fe.throwInstantiationError;nl.prototype.getTileDataAvailable=fe.throwInstantiationError;nl.prototype.loadTileDataAvailability=fe.throwInstantiationError;var Jr=nl;function z0(e){this._buffer=e.buffer,this._width=e.width,this._height=e.height,this._childTileMask=g(e.childTileMask,15),this._encoding=g(e.encoding,Ku.NONE);let t=xV.DEFAULT_STRUCTURE,n=e.structure;l(n)?n!==t&&(n.heightScale=g(n.heightScale,t.heightScale),n.heightOffset=g(n.heightOffset,t.heightOffset),n.elementsPerHeight=g(n.elementsPerHeight,t.elementsPerHeight),n.stride=g(n.stride,t.stride),n.elementMultiplier=g(n.elementMultiplier,t.elementMultiplier),n.isBigEndian=g(n.isBigEndian,t.isBigEndian)):n=t,this._structure=n,this._createdByUpsampling=g(e.createdByUpsampling,!1),this._waterMask=e.waterMask,this._skirtHeight=void 0,this._bufferType=this._encoding===Ku.LERC?Float32Array:this._buffer.constructor,this._mesh=void 0}Object.defineProperties(z0.prototype,{credits:{get:function(){}},waterMask:{get:function(){return this._waterMask}},childTileMask:{get:function(){return this._childTileMask}}});var hbe=\"createVerticesFromHeightmap\",mit=new di(hbe),hit=new di(hbe,gh.maximumAsynchronousTasks);z0.prototype.createMesh=function(e){e=g(e,g.EMPTY_OBJECT);let t=e.tilingScheme,n=e.x,i=e.y,o=e.level,r=g(e.exaggeration,1),s=g(e.exaggerationRelativeHeight,0),a=g(e.throttle,!0),c=t.ellipsoid,d=t.tileXYToNativeRectangle(n,i,o),u=t.tileXYToRectangle(n,i,o),m=c.cartographicToCartesian(le.center(u)),p=this._structure,f=Jr.getEstimatedLevelZeroGeometricErrorForAHeightmap(c,this._width,t.getNumberOfXTilesAtLevel(0))/(1<<o);this._skirtHeight=Math.min(f*4,1e3);let _=(a?hit:mit).scheduleTask({heightmap:this._buffer,structure:p,includeWebMercatorT:!0,width:this._width,height:this._height,nativeRectangle:d,rectangle:u,relativeToCenter:m,ellipsoid:c,skirtHeight:this._skirtHeight,isGeographic:t.projection instanceof Ci,exaggeration:r,exaggerationRelativeHeight:s,encoding:this._encoding});if(!l(_))return;let C=this;return Promise.resolve(_).then(function(V){let L;C._skirtHeight>0?L=Jr.getRegularGridAndSkirtIndicesAndEdgeIndices(V.gridWidth,V.gridHeight):L=Jr.getRegularGridIndicesAndEdgeIndices(V.gridWidth,V.gridHeight);let R=V.gridWidth*V.gridHeight;return C._mesh=new Qu(m,new Float32Array(V.vertices),L.indices,L.indexCountWithoutSkirts,R,V.minimumHeight,V.maximumHeight,ce.clone(V.boundingSphere3D),h.clone(V.occludeePointInScaledSpace),V.numberOfAttributes,Zn.clone(V.orientedBoundingBox),gc.clone(V.encoding),L.westIndicesSouthToNorth,L.southIndicesEastToWest,L.eastIndicesNorthToSouth,L.northIndicesWestToEast),C._buffer=void 0,C._mesh})};z0.prototype._createMeshSync=function(e){let t=e.tilingScheme,n=e.x,i=e.y,o=e.level,r=g(e.exaggeration,1),s=g(e.exaggerationRelativeHeight,0),a=t.ellipsoid,c=t.tileXYToNativeRectangle(n,i,o),d=t.tileXYToRectangle(n,i,o),u=a.cartographicToCartesian(le.center(d)),m=this._structure,b=Jr.getEstimatedLevelZeroGeometricErrorForAHeightmap(a,this._width,t.getNumberOfXTilesAtLevel(0))/(1<<o);this._skirtHeight=Math.min(b*4,1e3);let f=xV.computeVertices({heightmap:this._buffer,structure:m,includeWebMercatorT:!0,width:this._width,height:this._height,nativeRectangle:c,rectangle:d,relativeToCenter:u,ellipsoid:a,skirtHeight:this._skirtHeight,isGeographic:t.projection instanceof Ci,exaggeration:r,exaggerationRelativeHeight:s});this._buffer=void 0;let x;this._skirtHeight>0?x=Jr.getRegularGridAndSkirtIndicesAndEdgeIndices(this._width,this._height):x=Jr.getRegularGridIndicesAndEdgeIndices(this._width,this._height);let _=f.gridWidth*f.gridHeight;return this._mesh=new Qu(u,f.vertices,x.indices,x.indexCountWithoutSkirts,_,f.minimumHeight,f.maximumHeight,f.boundingSphere3D,f.occludeePointInScaledSpace,f.encoding.stride,f.orientedBoundingBox,f.encoding,x.westIndicesSouthToNorth,x.southIndicesEastToWest,x.eastIndicesNorthToSouth,x.northIndicesWestToEast),this._mesh};z0.prototype.interpolateHeight=function(e,t,n){let i=this._width,o=this._height,r=this._structure,s=r.stride,a=r.elementsPerHeight,c=r.elementMultiplier,d=r.isBigEndian,u=r.heightOffset,m=r.heightScale,p=l(this._mesh),b=this._encoding===Ku.LERC;if(!p&&b)return;let x;if(p){let _=this._mesh.vertices,C=this._mesh.encoding;x=fbe(_,C,u,m,e,i,o,t,n)}else x=fit(this._buffer,a,c,s,d,e,i,o,t,n),x=x*m+u;return x};z0.prototype.upsample=function(e,t,n,i,o,r,s){let a=this._mesh;if(!l(a))return;let c=this._width,d=this._height,u=this._structure,m=u.stride,p=new this._bufferType(c*d*m),b=a.vertices,f=a.encoding,x=e.tileXYToRectangle(t,n,i),_=e.tileXYToRectangle(o,r,s),C=u.heightOffset,V=u.heightScale,L=u.elementsPerHeight,R=u.elementMultiplier,G=u.isBigEndian,X=Math.pow(R,L-1);for(let v=0;v<d;++v){let W=P.lerp(_.north,_.south,v/(d-1));for(let F=0;F<c;++F){let A=P.lerp(_.west,_.east,F/(c-1)),y=fbe(b,f,C,V,x,c,d,A,W);y=y<u.lowestEncodedHeight?u.lowestEncodedHeight:y,y=y>u.highestEncodedHeight?u.highestEncodedHeight:y,pit(p,L,R,X,m,G,v*c+F,y)}}return Promise.resolve(new z0({buffer:p,width:c,height:d,childTileMask:0,structure:this._structure,createdByUpsampling:!0}))};z0.prototype.isChildAvailable=function(e,t,n,i){let o=2;return n!==e*2&&++o,i!==t*2&&(o-=2),(this._childTileMask&1<<o)!==0};z0.prototype.wasCreatedByUpsampling=function(){return this._createdByUpsampling};function fit(e,t,n,i,o,r,s,a,c,d){let u=(c-r.west)*(s-1)/(r.east-r.west),m=(d-r.south)*(a-1)/(r.north-r.south),p=u|0,b=p+1;b>=s&&(b=s-1,p=s-2);let f=m|0,x=f+1;x>=a&&(x=a-1,f=a-2);let _=u-p,C=m-f;f=a-1-f,x=a-1-x;let V=qU(e,t,n,i,o,f*s+p),L=qU(e,t,n,i,o,f*s+b),R=qU(e,t,n,i,o,x*s+p),G=qU(e,t,n,i,o,x*s+b);return pbe(_,C,V,L,R,G)}function fbe(e,t,n,i,o,r,s,a,c){let d=(a-o.west)*(r-1)/(o.east-o.west),u=(c-o.south)*(s-1)/(o.north-o.south),m=d|0,p=m+1;p>=r&&(p=r-1,m=r-2);let b=u|0,f=b+1;f>=s&&(f=s-1,b=s-2);let x=d-m,_=u-b;b=s-1-b,f=s-1-f;let C=(t.decodeHeight(e,b*r+m)-n)/i,V=(t.decodeHeight(e,b*r+p)-n)/i,L=(t.decodeHeight(e,f*r+m)-n)/i,R=(t.decodeHeight(e,f*r+p)-n)/i;return pbe(x,_,C,V,L,R)}function pbe(e,t,n,i,o,r){return t<e?n+e*(i-n)+t*(r-i):n+e*(r-o)+t*(o-n)}function qU(e,t,n,i,o,r){r*=i;let s=0,a;if(o)for(a=0;a<t;++a)s=s*n+e[r+a];else for(a=t-1;a>=0;--a)s=s*n+e[r+a];return s}function pit(e,t,n,i,o,r,s,a){s*=o;let c;if(r)for(c=0;c<t-1;++c)e[s+c]=a/i|0,a-=e[s+c]*i,i/=n;else for(c=t-1;c>0;--c)e[s+c]=a/i|0,a-=e[s+c]*i,i/=n;e[s+c]=a}var Fa=z0;function _V(e){e=g(e,g.EMPTY_OBJECT),this._tilingScheme=e.tilingScheme,l(this._tilingScheme)||(this._tilingScheme=new Ui({ellipsoid:g(e.ellipsoid,oe.WGS84)})),this._levelZeroMaximumGeometricError=Jr.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid,64,this._tilingScheme.getNumberOfXTilesAtLevel(0)),this._errorEvent=new ge}Object.defineProperties(_V.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){}},tilingScheme:{get:function(){return this._tilingScheme}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},availability:{get:function(){}}});_V.prototype.requestTileGeometry=function(e,t,n,i){return Promise.resolve(new Fa({buffer:new Uint8Array(16*16),width:16,height:16}))};_V.prototype.getLevelMaximumGeometricError=function(e){return this._levelZeroMaximumGeometricError/(1<<e)};_V.prototype.getTileDataAvailable=function(e,t,n){};_V.prototype.loadTileDataAvailability=function(e,t,n){};var kf=_V;var fbi=T(S(),1),Av=`uniform vec4 u_initialColor; #if TEXTURE_UNITS > 0 uniform sampler2D u_dayTextures[TEXTURE_UNITS]; uniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS]; uniform bool u_dayTextureUseWebMercatorT[TEXTURE_UNITS]; #ifdef APPLY_ALPHA uniform float u_dayTextureAlpha[TEXTURE_UNITS]; #endif #ifdef APPLY_DAY_NIGHT_ALPHA uniform float u_dayTextureNightAlpha[TEXTURE_UNITS]; uniform float u_dayTextureDayAlpha[TEXTURE_UNITS]; #endif #ifdef APPLY_SPLIT uniform float u_dayTextureSplit[TEXTURE_UNITS]; #endif #ifdef APPLY_BRIGHTNESS uniform float u_dayTextureBrightness[TEXTURE_UNITS]; #endif #ifdef APPLY_CONTRAST uniform float u_dayTextureContrast[TEXTURE_UNITS]; #endif #ifdef APPLY_HUE uniform float u_dayTextureHue[TEXTURE_UNITS]; #endif #ifdef APPLY_SATURATION uniform float u_dayTextureSaturation[TEXTURE_UNITS]; #endif #ifdef APPLY_GAMMA uniform float u_dayTextureOneOverGamma[TEXTURE_UNITS]; #endif #ifdef APPLY_IMAGERY_CUTOUT uniform vec4 u_dayTextureCutoutRectangles[TEXTURE_UNITS]; #endif #ifdef APPLY_COLOR_TO_ALPHA uniform vec4 u_colorsToAlpha[TEXTURE_UNITS]; #endif #ifdef APPLY_TILE_UV_CORRECTION uniform mat3 u_dayTileUVCorrections[TEXTURE_UNITS]; #endif uniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS]; #endif #ifdef SHOW_REFLECTIVE_OCEAN uniform sampler2D u_waterMask; uniform vec4 u_waterMaskTranslationAndScale; uniform float u_zoomedOutOceanSpecularIntensity; #endif #ifdef SHOW_OCEAN_WAVES uniform sampler2D u_oceanNormalMap; #endif #if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE) uniform vec2 u_lightingFadeDistance; #endif #ifdef TILE_LIMIT_RECTANGLE uniform vec4 u_cartographicLimitRectangle; #endif #ifdef GROUND_ATMOSPHERE uniform vec2 u_nightFadeDistance; #endif #ifdef ENABLE_CLIPPING_PLANES uniform highp sampler2D u_clippingPlanes; uniform mat4 u_clippingPlanesMatrix; uniform vec4 u_clippingPlanesEdgeStyle; #endif #if defined(GROUND_ATMOSPHERE) || defined(FOG) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING)) uniform float u_minimumBrightness; #endif #ifdef COLOR_CORRECT uniform vec3 u_hsbShift; // Hue, saturation, brightness #endif #ifdef HIGHLIGHT_FILL_TILE uniform vec4 u_fillHighlightColor; #endif #ifdef TRANSLUCENT uniform vec4 u_frontFaceAlphaByDistance; uniform vec4 u_backFaceAlphaByDistance; uniform vec4 u_translucencyRectangle; #endif #ifdef UNDERGROUND_COLOR uniform vec4 u_undergroundColor; uniform vec4 u_undergroundColorAlphaByDistance; #endif #ifdef ENABLE_VERTEX_LIGHTING uniform float u_lambertDiffuseMultiplier; uniform float u_vertexShadowDarkness; #endif in vec3 v_positionMC; in vec3 v_positionEC; in vec3 v_textureCoordinates; in vec3 v_normalMC; in vec3 v_normalEC; #ifdef APPLY_MATERIAL in float v_height; in float v_slope; in float v_aspect; #endif #if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) in float v_distance; #endif #if defined(GROUND_ATMOSPHERE) || defined(FOG) in vec3 v_atmosphereRayleighColor; in vec3 v_atmosphereMieColor; in float v_atmosphereOpacity; #endif #if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) float interpolateByDistance(vec4 nearFarScalar, float distance) { float startDistance = nearFarScalar.x; float startValue = nearFarScalar.y; float endDistance = nearFarScalar.z; float endValue = nearFarScalar.w; float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0); return mix(startValue, endValue, t); } #endif #if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) || defined(APPLY_MATERIAL) vec4 alphaBlend(vec4 sourceColor, vec4 destinationColor) { return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a); } #endif #ifdef TRANSLUCENT bool inTranslucencyRectangle() { return v_textureCoordinates.x > u_translucencyRectangle.x && v_textureCoordinates.x < u_translucencyRectangle.z && v_textureCoordinates.y > u_translucencyRectangle.y && v_textureCoordinates.y < u_translucencyRectangle.w; } #endif vec4 sampleAndBlend( vec4 previousColor, sampler2D textureToSample, vec2 tileTextureCoordinates, vec4 textureCoordinateRectangle, vec4 textureCoordinateTranslationAndScale, float textureAlpha, float textureNightAlpha, float textureDayAlpha, float textureBrightness, float textureContrast, float textureHue, float textureSaturation, float textureOneOverGamma, float split, vec4 colorToAlpha, float nightBlend, mat3 correction ) { // This crazy step stuff sets the alpha to 0.0 if this following condition is true: // tileTextureCoordinates.s < textureCoordinateRectangle.s || // tileTextureCoordinates.s > textureCoordinateRectangle.p || // tileTextureCoordinates.t < textureCoordinateRectangle.t || // tileTextureCoordinates.t > textureCoordinateRectangle.q // In other words, the alpha is zero if the fragment is outside the rectangle // covered by this texture. Would an actual 'if' yield better performance? #ifndef APPLY_TILE_UV_CORRECTION vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates); textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y; alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates); textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y; #endif #if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING) textureAlpha *= mix(textureDayAlpha, textureNightAlpha, nightBlend); #endif vec2 translation = textureCoordinateTranslationAndScale.xy; vec2 scale = textureCoordinateTranslationAndScale.zw; vec2 textureCoordinates = tileTextureCoordinates * scale + translation; #ifdef APPLY_TILE_UV_CORRECTION vec3 textureCoordinatesHomo = vec3(textureCoordinates, 1.0); textureCoordinatesHomo = correction * textureCoordinatesHomo; textureCoordinates = textureCoordinatesHomo.xy / textureCoordinatesHomo.z; #endif vec4 value = texture(textureToSample, textureCoordinates); vec3 color = value.rgb; float alpha = value.a; #ifdef APPLY_TILE_UV_CORRECTION if (textureCoordinates.x > 1.0 || textureCoordinates.x < 0.0 || textureCoordinates.y > 1.0 || textureCoordinates.y < 0.0) { alpha = 0.0; } #endif #ifdef APPLY_COLOR_TO_ALPHA vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb); colorDiff.r = max(max(colorDiff.r, colorDiff.g), colorDiff.b); alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha); #endif #if !defined(APPLY_GAMMA) vec4 tempColor = czm_gammaCorrect(vec4(color, alpha)); color = tempColor.rgb; alpha = tempColor.a; #else color = pow(color, vec3(textureOneOverGamma)); #endif #ifdef APPLY_SPLIT float splitPosition = czm_splitPosition; float splitMode = czm_splitMode; if (splitMode > 0.0) { // Split to the left if (split < 0.0 && gl_FragCoord.x > splitPosition) { alpha = 0.0; } // Split to the right else if (split > 0.0 && gl_FragCoord.x < splitPosition) { alpha = 0.0;"
}