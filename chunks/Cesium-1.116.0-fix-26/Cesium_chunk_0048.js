{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 48,
    "total_chunks": 194,
    "chunk_size": 6498,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.674Z"
  },
  "content": "(x - p0.x) + p0.y; } czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st; #if (__VERSION__ == 300 || defined(GL_OES_standard_derivatives)) float base = 1.0 - abs(fwidth(st.s)) * 10.0 * czm_pixelRatio; #else // If no derivatives available (IE 10?), 2.5% of the line will be the arrow head float base = 0.975; #endif vec2 center = vec2(1.0, 0.5); float ptOnUpperLine = getPointOnLine(vec2(base, 1.0), center, st.s); float ptOnLowerLine = getPointOnLine(vec2(base, 0.0), center, st.s); float halfWidth = 0.15; float s = step(0.5 - halfWidth, st.t); s *= 1.0 - step(0.5 + halfWidth, st.t); s *= 1.0 - step(base, st.s); float t = step(base, materialInput.st.s); t *= 1.0 - step(ptOnUpperLine, st.t); t *= step(ptOnLowerLine, st.t); // Find the distance from the closest separator (region between two colors) float dist; if (st.s < base) { float d1 = abs(st.t - (0.5 - halfWidth)); float d2 = abs(st.t - (0.5 + halfWidth)); dist = min(d1, d2); } else { float d1 = czm_infinity; if (st.t < 0.5 - halfWidth && st.t > 0.5 + halfWidth) { d1 = abs(st.s - base); } float d2 = abs(st.t - ptOnUpperLine); float d3 = abs(st.t - ptOnLowerLine); dist = min(min(d1, d2), d3); } vec4 outsideColor = vec4(0.0); vec4 currentColor = mix(outsideColor, color, clamp(s + t, 0.0, 1.0)); vec4 outColor = czm_antialias(outsideColor, color, currentColor, dist); outColor = czm_gammaCorrect(outColor); material.diffuse = outColor.rgb; material.alpha = outColor.a; return material; } `;var q3t=T(S(),1),mE=`uniform vec4 color; uniform vec4 gapColor; uniform float dashLength; uniform float dashPattern; in float v_polylineAngle; const float maskLength = 16.0; mat2 rotate(float rad) { float c = cos(rad); float s = sin(rad); return mat2( c, s, -s, c ); } czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec2 pos = rotate(v_polylineAngle) * gl_FragCoord.xy; // Get the relative position within the dash from 0 to 1 float dashPosition = fract(pos.x / (dashLength * czm_pixelRatio)); // Figure out the mask index. float maskIndex = floor(dashPosition * maskLength); // Test the bit mask. float maskTest = floor(dashPattern / pow(2.0, maskIndex)); vec4 fragColor = (mod(maskTest, 2.0) < 1.0) ? gapColor : color; if (fragColor.a < 0.005) { // matches 0/255 and 1/255 discard; } fragColor = czm_gammaCorrect(fragColor); material.emission = fragColor.rgb; material.alpha = fragColor.a; return material; } `;var eBt=T(S(),1),hE=`uniform vec4 color; uniform float glowPower; uniform float taperPower; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st; float glow = glowPower / abs(st.t - 0.5) - (glowPower / 0.5); if (taperPower <= 0.99999) { glow *= min(1.0, taperPower / (0.5 - st.s * 0.5) - (taperPower / 0.5)); } vec4 fragColor; fragColor.rgb = max(vec3(glow - 1.0 + color.rgb), color.rgb); fragColor.a = clamp(0.0, 1.0, glow) * color.a; fragColor = czm_gammaCorrect(fragColor); material.emission = fragColor.rgb; material.alpha = fragColor.a; return material; } `;var nBt=T(S(),1),fE=`uniform vec4 color; uniform vec4 outlineColor; uniform float outlineWidth; in float v_width; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec2 st = materialInput.st; float halfInteriorWidth = 0.5 * (v_width - outlineWidth) / v_width; float b = step(0.5 - halfInteriorWidth, st.t); b *= 1.0 - step(0.5 + halfInteriorWidth, st.t); // Find the distance from the closest separator (region between two colors) float d1 = abs(st.t - (0.5 - halfInteriorWidth)); float d2 = abs(st.t - (0.5 + halfInteriorWidth)); float dist = min(d1, d2); vec4 currentColor = mix(outlineColor, color, b); vec4 outColor = czm_antialias(outlineColor, color, currentColor, dist); outColor = czm_gammaCorrect(outColor); material.diffuse = outColor.rgb; material.alpha = outColor.a; return material; } `;var oBt=T(S(),1),pE=`uniform vec4 color; uniform vec4 rimColor; uniform float width; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); // See http://www.fundza.com/rman_shaders/surface/fake_rim/fake_rim1.html float d = 1.0 - dot(materialInput.normalEC, normalize(materialInput.positionToEyeEC)); float s = smoothstep(1.0 - width, 1.0, d); vec4 outColor = czm_gammaCorrect(color); vec4 outRimColor = czm_gammaCorrect(rimColor); material.diffuse = outColor.rgb; material.emission = outRimColor.rgb * s; material.alpha = mix(outColor.a, outRimColor.a, s); return material; } `;var sBt=T(S(),1),bE=`uniform sampler2D image; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); vec4 rampColor = texture(image, vec2(materialInput.slope / (czm_pi / 2.0), 0.5)); rampColor = czm_gammaCorrect(rampColor); material.diffuse = rampColor.rgb; material.alpha = rampColor.a; return material; } `;var cBt=T(S(),1),yE=`uniform vec4 evenColor; uniform vec4 oddColor; uniform float offset; uniform float repeat; uniform bool horizontal; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); // Based on the Stripes Fragment Shader in the Orange Book (11.1.2) float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal)); float value = fract((coord - offset) * (repeat * 0.5)); float dist = min(value, min(abs(value - 0.5), 1.0 - value)); vec4 currentColor = mix(evenColor, oddColor, step(0.5, value)); vec4 color = czm_antialias(evenColor, oddColor, currentColor, dist); color = czm_gammaCorrect(color); material.diffuse = color.rgb; material.alpha = color.a; return material; } `;var dBt=T(S(),1),gE=`// Thanks for the contribution Jonas // http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog uniform sampler2D specularMap; uniform sampler2D normalMap; uniform vec4 baseWaterColor; uniform vec4 blendColor; uniform float frequency; uniform float animationSpeed; uniform float amplitude; uniform float specularIntensity; uniform float fadeFactor; czm_material czm_getMaterial(czm_materialInput materialInput) { czm_material material = czm_getDefaultMaterial(materialInput); float time = czm_frameNumber * animationSpeed; // fade is a function of the distance from the fragment and"
}