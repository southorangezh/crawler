{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 36,
    "total_chunks": 194,
    "chunk_size": 6345,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.666Z"
  },
  "content": "(1.0 - near / (depthFromNear + near)) / (far - near); #endif return logZ; } `;var owt=T(S(),1),lG=`/** * Round a floating point value. This function exists because round() doesn't * exist in GLSL 1.00. * * @param {float|vec2|vec3|vec4} value The value to round * @param {float|vec2|vec3|vec3} The rounded value. The type matches the input. */ float czm_round(float value) { return floor(value + 0.5); } vec2 czm_round(vec2 value) { return floor(value + 0.5); } vec3 czm_round(vec3 value) { return floor(value + 0.5); } vec4 czm_round(vec4 value) { return floor(value + 0.5); } `;var swt=T(S(),1),dG=`/** * Samples the 4 neighboring pixels and return the weighted average. * * @private */ vec3 czm_sampleOctahedralProjectionWithFiltering(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod) { direction /= dot(vec3(1.0), abs(direction)); vec2 rev = abs(direction.zx) - vec2(1.0); vec2 neg = vec2(direction.x < 0.0 ? rev.x : -rev.x, direction.z < 0.0 ? rev.y : -rev.y); vec2 uv = direction.y < 0.0 ? neg : direction.xz; vec2 coord = 0.5 * uv + vec2(0.5); vec2 pixel = 1.0 / textureSize; if (lod > 0.0) { // Each subseqeuent mip level is half the size float scale = 1.0 / pow(2.0, lod); float offset = ((textureSize.y + 1.0) / textureSize.x); coord.x *= offset; coord *= scale; coord.x += offset + pixel.x; coord.y += (1.0 - (1.0 / pow(2.0, lod - 1.0))) + pixel.y * (lod - 1.0) * 2.0; } else { coord.x *= (textureSize.y / textureSize.x); } // Do bilinear filtering #ifndef OES_texture_float_linear vec3 color1 = texture(projectedMap, coord + vec2(0.0, pixel.y)).rgb; vec3 color2 = texture(projectedMap, coord + vec2(pixel.x, 0.0)).rgb; vec3 color3 = texture(projectedMap, coord + pixel).rgb; vec3 color4 = texture(projectedMap, coord).rgb; vec2 texturePosition = coord * textureSize; float fu = fract(texturePosition.x); float fv = fract(texturePosition.y); vec3 average1 = mix(color4, color2, fu); vec3 average2 = mix(color1, color3, fu); vec3 color = mix(average1, average2, fv); #else vec3 color = texture(projectedMap, coord).rgb; #endif return color; } /** * Samples from a cube map that has been projected using an octahedral projection from the given direction. * * @name czm_sampleOctahedralProjection * @glslFunction * * @param {sampler2D} projectedMap The texture with the octahedral projected cube map. * @param {vec2} textureSize The width and height dimensions in pixels of the projected map. * @param {vec3} direction The normalized direction used to sample the cube map. * @param {float} lod The level of detail to sample. * @param {float} maxLod The maximum level of detail. * @returns {vec3} The color of the cube map at the direction. */ vec3 czm_sampleOctahedralProjection(sampler2D projectedMap, vec2 textureSize, vec3 direction, float lod, float maxLod) { float currentLod = floor(lod + 0.5); float nextLod = min(currentLod + 1.0, maxLod); vec3 colorCurrentLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, currentLod); vec3 colorNextLod = czm_sampleOctahedralProjectionWithFiltering(projectedMap, textureSize, direction, nextLod); return mix(colorNextLod, colorCurrentLod, nextLod - lod); } `;var cwt=T(S(),1),uG=`/** * Adjusts the saturation of a color. * * @name czm_saturation * @glslFunction * * @param {vec3} rgb The color. * @param {float} adjustment The amount to adjust the saturation of the color. * * @returns {float} The color with the saturation adjusted. * * @example * vec3 greyScale = czm_saturation(color, 0.0); * vec3 doubleSaturation = czm_saturation(color, 2.0); */ vec3 czm_saturation(vec3 rgb, float adjustment) { // Algorithm from Chapter 16 of OpenGL Shading Language const vec3 W = vec3(0.2125, 0.7154, 0.0721); vec3 intensity = vec3(dot(rgb, W)); return mix(intensity, rgb, adjustment); } `;var dwt=T(S(),1),mG=` float czm_sampleShadowMap(highp samplerCube shadowMap, vec3 d) { return czm_unpackDepth(czm_textureCube(shadowMap, d)); } float czm_sampleShadowMap(highp sampler2D shadowMap, vec2 uv) { #ifdef USE_SHADOW_DEPTH_TEXTURE return texture(shadowMap, uv).r; #else return czm_unpackDepth(texture(shadowMap, uv)); #endif } float czm_shadowDepthCompare(samplerCube shadowMap, vec3 uv, float depth) { return step(depth, czm_sampleShadowMap(shadowMap, uv)); } float czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth) { return step(depth, czm_sampleShadowMap(shadowMap, uv)); } `;var mwt=T(S(),1),hG=` float czm_private_shadowVisibility(float visibility, float nDotL, float normalShadingSmooth, float darkness) { #ifdef USE_NORMAL_SHADING #ifdef USE_NORMAL_SHADING_SMOOTH float strength = clamp(nDotL / normalShadingSmooth, 0.0, 1.0); #else float strength = step(0.0, nDotL); #endif visibility *= strength; #endif visibility = max(visibility, darkness); return visibility; } #ifdef USE_CUBE_MAP_SHADOW float czm_shadowVisibility(samplerCube shadowMap, czm_shadowParameters shadowParameters) { float depthBias = shadowParameters.depthBias; float depth = shadowParameters.depth; float nDotL = shadowParameters.nDotL; float normalShadingSmooth = shadowParameters.normalShadingSmooth; float darkness = shadowParameters.darkness; vec3 uvw = shadowParameters.texCoords; depth -= depthBias; float visibility = czm_shadowDepthCompare(shadowMap, uvw, depth); return czm_private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness); } #else float czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters) { float depthBias = shadowParameters.depthBias; float depth = shadowParameters.depth; float nDotL = shadowParameters.nDotL; float normalShadingSmooth = shadowParameters.normalShadingSmooth; float darkness = shadowParameters.darkness; vec2 uv = shadowParameters.texCoords; depth -= depthBias; #ifdef USE_SOFT_SHADOWS vec2 texelStepSize = shadowParameters.texelStepSize; float radius = 1.0; float dx0 = -texelStepSize.x * radius; float dy0 = -texelStepSize.y * radius; float dx1 = texelStepSize.x * radius; float dy1 = texelStepSize.y * radius; float visibility = ( czm_shadowDepthCompare(shadowMap, uv, depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) + czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) + czm_shadowDepthCompare(shadowMap,"
}