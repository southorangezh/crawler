{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 40,
    "total_chunks": 194,
    "chunk_size": 6065,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.668Z"
  },
  "content": "value) + offset; } mat4 czm_valueTransform(mat4 offset, mat4 scale, mat4 value) { return matrixCompMult(scale, value) + offset; } `;var kwt=T(S(),1),RG=`#ifdef LOG_DEPTH // 1.0 at the near plane, increasing linearly from there. out float v_depthFromNearPlusOne; #ifdef SHADOW_MAP out vec3 v_logPositionEC; #endif #endif vec4 czm_updatePositionDepth(vec4 coords) { #if defined(LOG_DEPTH) #ifdef SHADOW_MAP vec3 logPositionEC = (czm_inverseProjection * coords).xyz; v_logPositionEC = logPositionEC; #endif // With the very high far/near ratios used with the logarithmic depth // buffer, floating point rounding errors can cause linear depth values // to end up on the wrong side of the far plane, even for vertices that // are really nowhere near it. Since we always write a correct logarithmic // depth value in the fragment shader anyway, we just need to make sure // such errors don't cause the primitive to be clipped entirely before // we even get to the fragment shader. coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w; #endif return coords; } /** * Writes the logarithmic depth to gl_Position using the already computed gl_Position. * * @name czm_vertexLogDepth * @glslFunction */ void czm_vertexLogDepth() { #ifdef LOG_DEPTH v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0; gl_Position = czm_updatePositionDepth(gl_Position); #endif } /** * Writes the logarithmic depth to gl_Position using the provided clip coordinates. * <p> * An example use case for this function would be moving the vertex in window coordinates * before converting back to clip coordinates. Use the original vertex clip coordinates. * </p> * @name czm_vertexLogDepth * @glslFunction * * @param {vec4} clipCoords The vertex in clip coordinates. * * @example * czm_vertexLogDepth(czm_projection * vec4(positionEyeCoordinates, 1.0)); */ void czm_vertexLogDepth(vec4 clipCoords) { #ifdef LOG_DEPTH v_depthFromNearPlusOne = (clipCoords.w - czm_currentFrustum.x) + 1.0; czm_updatePositionDepth(clipCoords); #endif } `;var Dwt=T(S(),1),GG=`vec4 czm_screenToEyeCoordinates(vec4 screenCoordinate) { // Reconstruct NDC coordinates float x = 2.0 * screenCoordinate.x - 1.0; float y = 2.0 * screenCoordinate.y - 1.0; float z = (screenCoordinate.z - czm_viewportTransformation[3][2]) / czm_viewportTransformation[2][2]; vec4 q = vec4(x, y, z, 1.0); // Reverse the perspective division to obtain clip coordinates. q /= screenCoordinate.w; // Reverse the projection transformation to obtain eye coordinates. if (!(czm_inverseProjection == mat4(0.0))) // IE and Edge sometimes do something weird with != between mat4s { q = czm_inverseProjection * q; } else { float top = czm_frustumPlanes.x; float bottom = czm_frustumPlanes.y; float left = czm_frustumPlanes.z; float right = czm_frustumPlanes.w; float near = czm_currentFrustum.x; float far = czm_currentFrustum.y; q.x = (q.x * (right - left) + left + right) * 0.5; q.y = (q.y * (top - bottom) + bottom + top) * 0.5; q.z = (q.z * (near - far) - near - far) * 0.5; q.w = 1.0; } return q; } /** * Transforms a position from window to eye coordinates. * The transform from window to normalized device coordinates is done using components * of (@link czm_viewport} and {@link czm_viewportTransformation} instead of calculating * the inverse of <code>czm_viewportTransformation</code>. The transformation from * normalized device coordinates to clip coordinates is done using <code>fragmentCoordinate.w</code>, * which is expected to be the scalar used in the perspective divide. The transformation * from clip to eye coordinates is done using {@link czm_inverseProjection}. * * @name czm_windowToEyeCoordinates * @glslFunction * * @param {vec4} fragmentCoordinate The position in window coordinates to transform. * * @returns {vec4} The transformed position in eye coordinates. * * @see czm_modelToWindowCoordinates * @see czm_eyeToWindowCoordinates * @see czm_inverseProjection * @see czm_viewport * @see czm_viewportTransformation * * @example * vec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord); */ vec4 czm_windowToEyeCoordinates(vec4 fragmentCoordinate) { vec2 screenCoordXY = (fragmentCoordinate.xy - czm_viewport.xy) / czm_viewport.zw; return czm_screenToEyeCoordinates(vec4(screenCoordXY, fragmentCoordinate.zw)); } vec4 czm_screenToEyeCoordinates(vec2 screenCoordinateXY, float depthOrLogDepth) { // See reverseLogDepth.glsl. This is separate to re-use the pow. #if defined(LOG_DEPTH) || defined(LOG_DEPTH_READ_ONLY) float near = czm_currentFrustum.x; float far = czm_currentFrustum.y; float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne; float depthFromNear = pow(2.0, log2Depth) - 1.0; float depthFromCamera = depthFromNear + near; vec4 screenCoord = vec4(screenCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0); vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord); eyeCoordinate.w = 1.0 / depthFromCamera; // Better precision return eyeCoordinate; #else vec4 screenCoord = vec4(screenCoordinateXY, depthOrLogDepth, 1.0); vec4 eyeCoordinate = czm_screenToEyeCoordinates(screenCoord); #endif return eyeCoordinate; } /** * Transforms a position given as window x/y and a depth or a log depth from window to eye coordinates. * This function produces more accurate results for window positions with log depth than * conventionally unpacking the log depth using czm_reverseLogDepth and using the standard version * of czm_windowToEyeCoordinates. * * @name czm_windowToEyeCoordinates * @glslFunction * * @param {vec2} fragmentCoordinateXY The XY position in window coordinates to transform. * @param {float} depthOrLogDepth A depth or log depth for the fragment. * * @see czm_modelToWindowCoordinates * @see czm_eyeToWindowCoordinates * @see czm_inverseProjection * @see czm_viewport * @see czm_viewportTransformation * * @returns {vec4} The transformed position in eye coordinates. */ vec4 czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth) { vec2 screenCoordXY = (fragmentCoordinateXY.xy - czm_viewport.xy) / czm_viewport.zw; return"
}