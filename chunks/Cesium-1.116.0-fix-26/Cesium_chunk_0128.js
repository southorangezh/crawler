{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 128,
    "total_chunks": 194,
    "chunk_size": 12919,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.727Z"
  },
  "content": "vec3 attenuation = exp(-((u_atmosphereMieCoefficient * (opticalDepth.y + lightOpticalDepth.y)) + (u_atmosphereRayleighCoefficient * (opticalDepth.x + lightOpticalDepth.x)))); // Accumulate the scattering. rayleighAccumulation += sampleDensity.x * attenuation; mieAccumulation += sampleDensity.y * attenuation; // Increment distance on primary ray. rayPositionLength += (rayStepLength += rayStepLengthIncrease); } // Compute the scattering amount. rayleighColor = u_atmosphereRayleighCoefficient * rayleighAccumulation; mieColor = u_atmosphereMieCoefficient * mieAccumulation; // Compute the transmittance i.e. how much light is passing through the atmosphere. opacity = length(exp(-((u_atmosphereMieCoefficient * opticalDepth.y) + (u_atmosphereRayleighCoefficient * opticalDepth.x)))); } vec4 computeAtmosphereColor( vec3 positionWC, vec3 lightDirection, vec3 rayleighColor, vec3 mieColor, float opacity ) { // Setup the primary ray: from the camera position to the vertex position. vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC; vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC); float cosAngle = dot(cameraToPositionWCDirection, lightDirection); float cosAngleSq = cosAngle * cosAngle; float G = u_atmosphereMieAnisotropy; float GSq = G * G; // The Rayleigh phase function. float rayleighPhase = 3.0 / (50.2654824574) * (1.0 + cosAngleSq); // The Mie phase function. float miePhase = 3.0 / (25.1327412287) * ((1.0 - GSq) * (cosAngleSq + 1.0)) / (pow(1.0 + GSq - 2.0 * cosAngle * G, 1.5) * (2.0 + GSq)); // The final color is generated by combining the effects of the Rayleigh and Mie scattering. vec3 rayleigh = rayleighPhase * rayleighColor; vec3 mie = miePhase * mieColor; vec3 color = (rayleigh + mie) * u_atmosphereLightIntensity; return vec4(color, opacity); } `;var _bi=T(S(),1),TV=`void computeAtmosphereScattering(vec3 positionWC, vec3 lightDirection, out vec3 rayleighColor, out vec3 mieColor, out float opacity) { vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC; vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC); czm_ray primaryRay = czm_ray(czm_viewerPositionWC, cameraToPositionWCDirection); float atmosphereInnerRadius = length(positionWC); computeScattering( primaryRay, length(cameraToPositionWC), lightDirection, atmosphereInnerRadius, rayleighColor, mieColor, opacity ); } `;var Wbi=T(S(),1);var Vbi=T(S(),1);var bit=new D;function yit(e,t){let n=e.unionClippingRegions,i=e.length,o=fs.useFloatTexture(t),r=fs.getTextureResolution(e,t,bit),s=r.x,a=r.y,c=o?_it(s,a):Tit(s,a);return c+=` `,c+=n?git(i):xit(i),c}function git(e){return`float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix) { vec4 position = czm_windowToEyeCoordinates(fragCoord); vec3 clipNormal = vec3(0.0); vec3 clipPosition = vec3(0.0); float clipAmount; float pixelWidth = czm_metersPerPixel(position); bool breakAndDiscard = false; for (int i = 0; i < ${e}; ++i) { vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix); clipNormal = clippingPlane.xyz; clipPosition = -clippingPlane.w * clipNormal; float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth; clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount)); if (amount <= 0.0) { breakAndDiscard = true; break; } } if (breakAndDiscard) { discard; } return clipAmount; } `}function xit(e){return`float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix) { bool clipped = true; vec4 position = czm_windowToEyeCoordinates(fragCoord); vec3 clipNormal = vec3(0.0); vec3 clipPosition = vec3(0.0); float clipAmount = 0.0; float pixelWidth = czm_metersPerPixel(position); for (int i = 0; i < ${e}; ++i) { vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix); clipNormal = clippingPlane.xyz; clipPosition = -clippingPlane.w * clipNormal; float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth; clipAmount = max(amount, clipAmount); clipped = clipped && (amount <= 0.0); } if (clipped) { discard; } return clipAmount; } `}function _it(e,t){let n=1/e,i=1/t,o=`${n}`;o.indexOf(\".\")===-1&&(o+=\".0\");let r=`${i}`;return r.indexOf(\".\")===-1&&(r+=\".0\"),`vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform) { int pixY = clippingPlaneNumber / ${e}; int pixX = clippingPlaneNumber - (pixY * ${e}); float u = (float(pixX) + 0.5) * ${o}; float v = (float(pixY) + 0.5) * ${r}; vec4 plane = texture(packedClippingPlanes, vec2(u, v)); return czm_transformPlane(plane, transform); } `}function Tit(e,t){let n=1/e,i=1/t,o=`${n}`;o.indexOf(\".\")===-1&&(o+=\".0\");let r=`${i}`;return r.indexOf(\".\")===-1&&(r+=\".0\"),`vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform) { int clippingPlaneStartIndex = clippingPlaneNumber * 2; int pixY = clippingPlaneStartIndex / ${e}; int pixX = clippingPlaneStartIndex - (pixY * ${e}); float u = (float(pixX) + 0.5) * ${o}; float v = (float(pixY) + 0.5) * ${r}; vec4 oct32 = texture(packedClippingPlanes, vec2(u, v)) * 255.0; vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w); vec4 plane; plane.xyz = czm_octDecode(oct, 65535.0); plane.w = czm_unpackFloat(texture(packedClippingPlanes, vec2(u + ${o}, v))); return czm_transformPlane(plane, transform); } `}var K0=yit;function Sit(e,t,n,i,o){this.numberOfDayTextures=e,this.flags=t,this.material=n,this.shaderProgram=i,this.clippingShaderState=o}function d4(){this.baseVertexShaderSource=void 0,this.baseFragmentShaderSource=void 0,this._shadersByTexturesFlags=[],this.material=void 0}function Cit(e){let t=\"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }\",n=\"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }\",i=\"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }\",o;switch(e){case ie.SCENE3D:o=t;break;case ie.SCENE2D:case ie.COLUMBUS_VIEW:o=n;break;case ie.MORPHING:o=i;break}return o}function Vit(e){return e?\"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }\":\"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }\"}d4.prototype.getShaderProgram=function(e){let t=e.frameState,n=e.surfaceTile,i=e.numberOfDayTextures,o=e.applyBrightness,r=e.applyContrast,s=e.applyHue,a=e.applySaturation,c=e.applyGamma,d=e.applyAlpha,u=e.applyDayNightAlpha,m=e.applySplit,p=e.showReflectiveOcean,b=e.showOceanWaves,f=e.enableLighting,x=e.dynamicAtmosphereLighting,_=e.dynamicAtmosphereLightingFromSun,C=e.showGroundAtmosphere,V=e.perFragmentGroundAtmosphere,L=e.hasVertexNormals,R=e.useWebMercatorProjection,G=e.enableFog,X=e.enableClippingPlanes,v=e.clippingPlanes,W=e.clippedByBoundaries,F=e.hasImageryLayerCutout,A=e.colorCorrect,y=e.highlightFillTile,Z=e.colorToAlpha,E=e.hasGeodeticSurfaceNormals,I=e.hasExaggeration,w=e.showUndergroundColor,k=e.translucent,B=e.applyTileUVCorrection,U=0,Y=\"\",J=n.renderedMesh.encoding;J.quantization===Os.BITS12&&(U=1,Y=\"QUANTIZATION_BITS12\");let ee=0,H=\"\";W&&(ee=1,H=\"TILE_LIMIT_RECTANGLE\");let j=0,q=\"\";F&&(j=1,q=\"APPLY_IMAGERY_CUTOUT\");let pe=t.mode,_e=pe|o<<2|r<<3|s<<4|a<<5|c<<6|d<<7|p<<8|b<<9|f<<10|x<<11|_<<12|C<<13|V<<14|L<<15|R<<16|G<<17|U<<18|m<<19|X<<20|ee<<21|j<<22|A<<23|y<<24|Z<<25|E<<26|I<<27|w<<28|k<<29|u<<30,ae=0;l(v)&&v.length>0&&(ae=X?v.clippingPlanesState:0);let ye=n.surfaceShader;if(l(ye)&&ye.numberOfDayTextures===i&&ye.flags===_e&&ye.material===this.material&&ye.clippingShaderState===ae)return ye.shaderProgram;let Te=this._shadersByTexturesFlags[i];if(l(Te)||(Te=this._shadersByTexturesFlags[i]=[]),ye=Te[_e],!l(ye)||ye.material!==this.material||ye.clippingShaderState!==ae){let Le=this.baseVertexShaderSource.clone(),Re=this.baseFragmentShaderSource.clone();ae!==0&&Re.sources.unshift(K0(v,t.context)),Le.defines.push(Y),Re.defines.push(`TEXTURE_UNITS ${i}`,H,q),o&&Re.defines.push(\"APPLY_BRIGHTNESS\"),r&&Re.defines.push(\"APPLY_CONTRAST\"),s&&Re.defines.push(\"APPLY_HUE\"),a&&Re.defines.push(\"APPLY_SATURATION\"),c&&Re.defines.push(\"APPLY_GAMMA\"),d&&Re.defines.push(\"APPLY_ALPHA\"),u&&Re.defines.push(\"APPLY_DAY_NIGHT_ALPHA\"),p&&(Re.defines.push(\"SHOW_REFLECTIVE_OCEAN\"),Le.defines.push(\"SHOW_REFLECTIVE_OCEAN\")),b&&Re.defines.push(\"SHOW_OCEAN_WAVES\"),Z&&Re.defines.push(\"APPLY_COLOR_TO_ALPHA\"),w&&(Le.defines.push(\"UNDERGROUND_COLOR\"),Re.defines.push(\"UNDERGROUND_COLOR\")),k&&(Le.defines.push(\"TRANSLUCENT\"),Re.defines.push(\"TRANSLUCENT\")),f&&(L?(Le.defines.push(\"ENABLE_VERTEX_LIGHTING\"),Re.defines.push(\"ENABLE_VERTEX_LIGHTING\")):(Le.defines.push(\"ENABLE_DAYNIGHT_SHADING\"),Re.defines.push(\"ENABLE_DAYNIGHT_SHADING\"))),x&&(Le.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\"),Re.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\"),_&&(Le.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\"),Re.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\"))),C&&(Le.defines.push(\"GROUND_ATMOSPHERE\"),Re.defines.push(\"GROUND_ATMOSPHERE\"),V&&(Le.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\"),Re.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\"))),Le.defines.push(\"INCLUDE_WEB_MERCATOR_Y\"),Re.defines.push(\"INCLUDE_WEB_MERCATOR_Y\"),G&&(Le.defines.push(\"FOG\"),Re.defines.push(\"FOG\")),m&&Re.defines.push(\"APPLY_SPLIT\"),X&&Re.defines.push(\"ENABLE_CLIPPING_PLANES\"),A&&Re.defines.push(\"COLOR_CORRECT\"),y&&Re.defines.push(\"HIGHLIGHT_FILL_TILE\"),E&&Le.defines.push(\"GEODETIC_SURFACE_NORMALS\"),I&&Le.defines.push(\"EXAGGERATION\"),B&&Re.defines.push(\"APPLY_TILE_UV_CORRECTION\");let ke=` vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend) { vec4 color = initialColor; mat3 correction = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0); `;F&&(ke+=` vec4 cutoutAndColorResult; bool texelUnclipped; `);for(let yt=0;yt<i;++yt){let Dt=B?`correction = u_dayTileUVCorrections[${yt}]; `:\"\";F?ke+=` cutoutAndColorResult = u_dayTextureCutoutRectangles[${yt}]; texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y; ${Dt} cutoutAndColorResult = sampleAndBlend( `:ke+=Dt+` color = sampleAndBlend( `,ke+=` color, u_dayTextures[${yt}], u_dayTextureUseWebMercatorT[${yt}] ? textureCoordinates.xz : textureCoordinates.xy, u_dayTextureTexCoordsRectangle[${yt}], u_dayTextureTranslationAndScale[${yt}], ${d?`u_dayTextureAlpha[${yt}]`:\"1.0\"}, ${u?`u_dayTextureNightAlpha[${yt}]`:\"1.0\"}, ${u?`u_dayTextureDayAlpha[${yt}]`:\"1.0\"}, ${o?`u_dayTextureBrightness[${yt}]`:\"0.0\"}, ${r?`u_dayTextureContrast[${yt}]`:\"0.0\"}, ${s?`u_dayTextureHue[${yt}]`:\"0.0\"}, ${a?`u_dayTextureSaturation[${yt}]`:\"0.0\"}, ${c?`u_dayTextureOneOverGamma[${yt}]`:\"0.0\"}, ${m?`u_dayTextureSplit[${yt}]`:\"0.0\"}, ${Z?`u_colorsToAlpha[${yt}]`:\"vec4(0.0)\"}, nightBlend, correction ); `,F&&(ke+=` color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color); `)}ke+=` return color; }`,Re.sources.push(ke),Le.sources.push(Cit(pe)),Le.sources.push(Vit(R));let rt=Ht.fromCache({context:t.context,vertexShaderSource:Le,fragmentShaderSource:Re,attributeLocations:J.getAttributeLocations()});ye=Te[_e]=new Sit(i,_e,this.material,rt,ae)}return n.surfaceShader=ye,ye.shaderProgram};d4.prototype.destroy=function(){let e,t,n=this._shadersByTexturesFlags;for(let i in n)if(n.hasOwnProperty(i)){let o=n[i];if(!l(o))continue;for(e in o)o.hasOwnProperty(e)&&(t=o[e],l(t)&&t.shaderProgram.destroy())}return me(this)};var Nv=d4;var f1i=T(S(),1);var vbi=T(S(),1),Lit={NONE:-1,PARTIAL:0,FULL:1},lr=Object.freeze(Lit);var _yi=T(S(),1);var Nbi=T(S(),1);function $U(e,t,n,i,o,r,s){this.provider=e,this.message=t,this.x=n,this.y=i,this.level=o,this.timesRetried=g(r,0),this.retry=!1,this.error=s}$U.reportError=function(e,t,n,i,o,r,s,a){let c=e;return l(e)?(c.provider=t,c.message=i,c.x=o,c.y=r,c.level=s,c.retry=!1,c.error=a,++c.timesRetried):c=new $U(t,i,o,r,s,0,a),l(n)&&n.numberOfListeners>0?n.raiseEvent(c):l(t)&&console.log(`An error occurred in \"${t.constructor.name}\": ${Mf(i)}`),c};$U.reportSuccess=function(e){l(e)&&(e.timesRetried=-1)};var So=$U;var Ubi=T(S(),1),Zit={UNLOADED:0,TRANSITIONING:1,RECEIVED:2,TEXTURE_LOADED:3,READY:4,FAILED:5,INVALID:6,PLACEHOLDER:7},$n=Object.freeze(Zit);var Bbi=T(S(),1),Rit={START:0,LOADING:1,DONE:2,FAILED:3},zs=Object.freeze(Rit);var Obi=T(S(),1),Git={FAILED:0,UNLOADED:1,RECEIVING:2,RECEIVED:3,TRANSFORMING:4,TRANSFORMED:5,READY:6},co=Object.freeze(Git);function jo(){this.imagery=[],this.waterMaskTexture=void 0,this.waterMaskTranslationAndScale=new se(0,0,1,1),this.terrainData=void 0,this.vertexArray=void 0,this.tileBoundingRegion=void 0,this.occludeePointInScaledSpace=new"
}