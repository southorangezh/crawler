{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 167,
    "total_chunks": 194,
    "chunk_size": 6707,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.749Z"
  },
  "content": "ivec3(childCoord)); if (childData.flag != OCTREE_FLAG_INTERNAL) { // leaf tile - stop traversing break; } // interior tile - keep going deeper start = mix(start, center, childCoord); end = mix(center, end, childCoord); traversalData.parentOctreeIndex = childData.data; } return childData; } /** * Transform a given position to an octree tile coordinate and a position within that tile, * and find the corresponding megatexture index and texture coordinates */ void traverseOctreeFromBeginning(in vec3 shapePosition, out TraversalData traversalData, out SampleData sampleDatas[SAMPLE_COUNT]) { traversalData.octreeCoords = ivec4(0); traversalData.parentOctreeIndex = 0; OctreeNodeData nodeData = getOctreeNodeData(vec2(0.0)); if (nodeData.flag != OCTREE_FLAG_LEAF) { nodeData = traverseOctreeDownwards(shapePosition, traversalData); } #if (SAMPLE_COUNT == 1) getOctreeLeafSampleData(nodeData, traversalData.octreeCoords, sampleDatas[0]); sampleDatas[0].tileUv = getClampedTileUv(shapePosition, sampleDatas[0].tileCoords); #else getOctreeLeafSampleDatas(nodeData, traversalData.octreeCoords, sampleDatas); sampleDatas[0].tileUv = getClampedTileUv(shapePosition, sampleDatas[0].tileCoords); sampleDatas[1].tileUv = getClampedTileUv(shapePosition, sampleDatas[1].tileCoords); #endif } bool inRange(in vec3 v, in vec3 minVal, in vec3 maxVal) { return clamp(v, minVal, maxVal) == v; } bool insideTile(in vec3 shapePosition, in ivec4 octreeCoords) { vec3 tileUv = getTileUv(shapePosition, octreeCoords); bool inside = inRange(tileUv, vec3(0.0), vec3(1.0)); // Assume (!) the position is always inside the root tile. return inside || octreeCoords.w == 0; } void traverseOctreeFromExisting(in vec3 shapePosition, inout TraversalData traversalData, inout SampleData sampleDatas[SAMPLE_COUNT]) { if (insideTile(shapePosition, traversalData.octreeCoords)) { for (int i = 0; i < SAMPLE_COUNT; i++) { sampleDatas[0].tileUv = getClampedTileUv(shapePosition, sampleDatas[0].tileCoords); } return; } // Go up tree until we find a parent tile containing shapePosition for (int i = 0; i < OCTREE_MAX_LEVELS; ++i) { traversalData.octreeCoords.xyz /= 2; traversalData.octreeCoords.w -= 1; if (insideTile(shapePosition, traversalData.octreeCoords)) { break; } traversalData.parentOctreeIndex = getOctreeParentIndex(traversalData.parentOctreeIndex); } // Go down tree OctreeNodeData nodeData = traverseOctreeDownwards(shapePosition, traversalData); #if (SAMPLE_COUNT == 1) getOctreeLeafSampleData(nodeData, traversalData.octreeCoords, sampleDatas[0]); sampleDatas[0].tileUv = getClampedTileUv(shapePosition, sampleDatas[0].tileCoords); #else getOctreeLeafSampleDatas(nodeData, traversalData.octreeCoords, sampleDatas); sampleDatas[0].tileUv = getClampedTileUv(shapePosition, sampleDatas[0].tileCoords); sampleDatas[1].tileUv = getClampedTileUv(shapePosition, sampleDatas[1].tileCoords); #endif } `;var FAi=T(S(),1),o9=`// See Octree.glsl for the definitions of SampleData and intMod /* Megatexture defines (set in Scene/VoxelRenderResources.js) #define SAMPLE_COUNT ### #define NEAREST_SAMPLING #define PADDING */ uniform ivec2 u_megatextureSliceDimensions; // number of slices per tile, in two dimensions uniform ivec2 u_megatextureTileDimensions; // number of tiles per megatexture, in two dimensions uniform vec2 u_megatextureVoxelSizeUv; uniform vec2 u_megatextureSliceSizeUv; uniform vec2 u_megatextureTileSizeUv; uniform ivec3 u_dimensions; // does not include padding #if defined(PADDING) uniform ivec3 u_paddingBefore; uniform ivec3 u_paddingAfter; #endif // Integer min, max, clamp: For WebGL1 only int intMin(int a, int b) { return a <= b ? a : b; } int intMax(int a, int b) { return a >= b ? a : b; } int intClamp(int v, int minVal, int maxVal) { return intMin(intMax(v, minVal), maxVal); } vec2 index1DTo2DTexcoord(int index, ivec2 dimensions, vec2 uvScale) { int indexX = intMod(index, dimensions.x); int indexY = index / dimensions.x; return vec2(indexX, indexY) * uvScale; } /* How is 3D data stored in a 2D megatexture? In this example there is only one loaded tile and it has 2x2x2 voxels (8 voxels total). The data is sliced by Z. The data at Z = 0 is placed in texels (0,0), (0,1), (1,0), (1,1) and the data at Z = 1 is placed in texels (2,0), (2,1), (3,0), (3,1). Note that there could be empty space in the megatexture because it's a power of two. 0 1 2 3 +---+---+---+---+ | | | | | 3 +---+---+---+---+ | | | | | 2 +-------+-------+ |010|110|011|111| 1 |--- ---|--- ---| |000|100|001|101| 0 +-------+-------+ When doing linear interpolation the megatexture needs to be sampled twice: once for the Z slice above the voxel coordinate and once for the slice below. The two slices are interpolated with fract(coord.z - 0.5). For example, a Z coordinate of 1.0 is halfway between two Z slices so the interpolation factor is 0.5. Below is a side view of the 3D voxel grid with voxel coordinates on the left side. 2 +---+ |001| 1 +-z-+ |000| 0 +---+ When doing nearest neighbor the megatexture only needs to be sampled once at the closest Z slice. */ Properties getPropertiesFromMegatexture(in SampleData sampleData) { int tileIndex = sampleData.megatextureIndex; vec3 voxelCoord = sampleData.tileUv * vec3(u_dimensions); ivec3 voxelDimensions = u_dimensions; #if defined(PADDING) voxelDimensions += u_paddingBefore + u_paddingAfter; voxelCoord += vec3(u_paddingBefore); #endif #if defined(NEAREST_SAMPLING) // Round to the center of the nearest voxel voxelCoord = floor(voxelCoord) + vec3(0.5); #endif // Tile location vec2 tileUvOffset = index1DTo2DTexcoord(tileIndex, u_megatextureTileDimensions, u_megatextureTileSizeUv); // Slice location float slice = voxelCoord.z - 0.5; int sliceIndex = int(floor(slice)); int sliceIndex0 = intClamp(sliceIndex, 0, voxelDimensions.z - 1); vec2 sliceUvOffset0 = index1DTo2DTexcoord(sliceIndex0, u_megatextureSliceDimensions, u_megatextureSliceSizeUv); // Voxel location vec2 voxelUvOffset = clamp(voxelCoord.xy, vec2(0.5), vec2(voxelDimensions.xy) - vec2(0.5)) * u_megatextureVoxelSizeUv; // Final location in the megatexture vec2 uv0 = tileUvOffset + sliceUvOffset0 + voxelUvOffset; #if defined(NEAREST_SAMPLING) return getPropertiesFromMegatextureAtUv(uv0); #else float sliceLerp = fract(slice); int sliceIndex1 = intMin(sliceIndex + 1, voxelDimensions.z - 1); vec2 sliceUvOffset1 = index1DTo2DTexcoord(sliceIndex1, u_megatextureSliceDimensions, u_megatextureSliceSizeUv); vec2 uv1 = tileUvOffset + sliceUvOffset1 + voxelUvOffset; Properties properties0 = getPropertiesFromMegatextureAtUv(uv0); Properties properties1 = getPropertiesFromMegatextureAtUv(uv1); return mixProperties(properties0, properties1, sliceLerp); #endif } // Convert an array of sample datas to a final"
}