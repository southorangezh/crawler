{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 80,
    "total_chunks": 194,
    "chunk_size": 21420,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.694Z"
  },
  "content": "cpuStylingStage(material, selectedFeature); #endif #ifdef HAS_MODEL_COLOR modelColorStage(material); #endif #ifdef HAS_PRIMITIVE_OUTLINE primitiveOutlineStage(material); #endif vec4 color = handleAlpha(material.diffuse, material.alpha); #ifdef HAS_CLIPPING_PLANES modelClippingPlanesStage(color); #endif #if defined(HAS_SILHOUETTE) && defined(HAS_NORMALS) silhouetteStage(color); #endif #ifdef HAS_ATMOSPHERE atmosphereStage(color, attributes); #endif out_FragColor = color; } `;var Qgn=T(S(),1),gI=`precision highp float; czm_modelVertexOutput defaultVertexOutput(vec3 positionMC) { czm_modelVertexOutput vsOutput; vsOutput.positionMC = positionMC; vsOutput.pointSize = 1.0; return vsOutput; } void main() { // Initialize the attributes struct with all // attributes except quantized ones. ProcessedAttributes attributes; initializeAttributes(attributes); // Dequantize the quantized ones and add them to the // attributes struct. #ifdef USE_DEQUANTIZATION dequantizationStage(attributes); #endif #ifdef HAS_MORPH_TARGETS morphTargetsStage(attributes); #endif #ifdef HAS_SKINNING skinningStage(attributes); #endif #ifdef HAS_PRIMITIVE_OUTLINE primitiveOutlineStage(); #endif // Compute the bitangent according to the formula in the glTF spec. // Normal and tangents can be affected by morphing and skinning, so // the bitangent should not be computed until their values are finalized. #ifdef HAS_BITANGENTS attributes.bitangentMC = normalize(cross(attributes.normalMC, attributes.tangentMC) * attributes.tangentSignMC); #endif FeatureIds featureIds; featureIdStage(featureIds, attributes); #ifdef HAS_SELECTED_FEATURE_ID SelectedFeature feature; selectedFeatureIdStage(feature, featureIds); // Handle any show properties that come from the style. cpuStylingStage(attributes.positionMC, feature); #endif #if defined(USE_2D_POSITIONS) || defined(USE_2D_INSTANCING) // The scene mode 2D pipeline stage and instancing stage add a different // model view matrix to accurately project the model to 2D. However, the // output positions and normals should be transformed by the 3D matrices // to keep the data the same for the fragment shader. mat4 modelView = czm_modelView3D; mat3 normal = czm_normal3D; #else // These are used for individual model projection because they will // automatically change based on the scene mode. mat4 modelView = czm_modelView; mat3 normal = czm_normal; #endif // Update the position for this instance in place #ifdef HAS_INSTANCING // The legacy instance stage is used when rendering i3dm models that // encode instances transforms in world space, as opposed to glTF models // that use EXT_mesh_gpu_instancing, where instance transforms are encoded // in object space. #ifdef USE_LEGACY_INSTANCING mat4 instanceModelView; mat3 instanceModelViewInverseTranspose; legacyInstancingStage(attributes, instanceModelView, instanceModelViewInverseTranspose); modelView = instanceModelView; normal = instanceModelViewInverseTranspose; #else instancingStage(attributes); #endif #ifdef USE_PICKING v_pickColor = a_pickColor; #endif #endif Metadata metadata; MetadataClass metadataClass; MetadataStatistics metadataStatistics; metadataStage(metadata, metadataClass, metadataStatistics, attributes); #ifdef HAS_VERTICAL_EXAGGERATION verticalExaggerationStage(attributes); #endif #ifdef HAS_CUSTOM_VERTEX_SHADER czm_modelVertexOutput vsOutput = defaultVertexOutput(attributes.positionMC); customShaderStage(vsOutput, attributes, featureIds, metadata, metadataClass, metadataStatistics); #endif // Compute the final position in each coordinate system needed. // This returns the value that will be assigned to gl_Position. vec4 positionClip = geometryStage(attributes, modelView, normal); // This must go after the geometry stage as it needs v_positionWC #ifdef HAS_ATMOSPHERE atmosphereStage(attributes); #endif #ifdef HAS_SILHOUETTE silhouetteStage(attributes, positionClip); #endif #ifdef HAS_POINT_CLOUD_SHOW_STYLE float show = pointCloudShowStylingStage(attributes, metadata); #else float show = 1.0; #endif #ifdef HAS_POINT_CLOUD_BACK_FACE_CULLING show *= pointCloudBackFaceCullingStage(); #endif #ifdef HAS_POINT_CLOUD_COLOR_STYLE v_pointCloudColor = pointCloudColorStylingStage(attributes, metadata); #endif #ifdef PRIMITIVE_TYPE_POINTS #ifdef HAS_CUSTOM_VERTEX_SHADER gl_PointSize = vsOutput.pointSize; #elif defined(HAS_POINT_CLOUD_POINT_SIZE_STYLE) || defined(HAS_POINT_CLOUD_ATTENUATION) gl_PointSize = pointCloudPointSizeStylingStage(attributes, metadata); #else gl_PointSize = 1.0; #endif gl_PointSize *= show; #endif gl_Position = show * positionClip; } `;var dxn=T(S(),1);function kz(e){e=g(e,g.EMPTY_OBJECT);let t=e.command,n=e.primitiveRenderResources,i=n.model;this._command=t,this._model=i,this._runtimePrimitive=n.runtimePrimitive,this._modelMatrix=t.modelMatrix,this._boundingVolume=t.boundingVolume,this._cullFace=t.renderState.cull.face;let o=i.classificationType;this._classificationType=o,this._classifiesTerrain=o!==Un.CESIUM_3D_TILE,this._classifies3DTiles=o!==Un.TERRAIN,this._useDebugWireframe=i._enableDebugWireframe&&i.debugWireframe,this._pickId=n.pickId,this._commandListTerrain=[],this._commandList3DTiles=[],this._commandListIgnoreShow=[],this._commandListDebugWireframe=[],this._commandListTerrainPicking=[],this._commandList3DTilesPicking=[],Mke(this)}function wke(e){return{colorMask:{red:!1,green:!1,blue:!1,alpha:!1},stencilTest:{enabled:!0,frontFunction:e,frontOperation:{fail:dt.KEEP,zFail:dt.DECREMENT_WRAP,zPass:dt.KEEP},backFunction:e,backOperation:{fail:dt.KEEP,zFail:dt.INCREMENT_WRAP,zPass:dt.KEEP},reference:Mt.CESIUM_3D_TILE_MASK,mask:Mt.CESIUM_3D_TILE_MASK},stencilMask:Mt.CLASSIFICATION_MASK,depthTest:{enabled:!0,func:tc.LESS_OR_EQUAL},depthMask:!1}}var Fke={stencilTest:{enabled:!0,frontFunction:vn.NOT_EQUAL,frontOperation:{fail:dt.ZERO,zFail:dt.ZERO,zPass:dt.ZERO},backFunction:vn.NOT_EQUAL,backOperation:{fail:dt.ZERO,zFail:dt.ZERO,zPass:dt.ZERO},reference:0,mask:Mt.CLASSIFICATION_MASK},stencilMask:Mt.CLASSIFICATION_MASK,depthTest:{enabled:!1},depthMask:!1,blending:un.PRE_MULTIPLIED_ALPHA_BLEND},Ake={stencilTest:{enabled:!0,frontFunction:vn.NOT_EQUAL,frontOperation:{fail:dt.ZERO,zFail:dt.ZERO,zPass:dt.ZERO},backFunction:vn.NOT_EQUAL,backOperation:{fail:dt.ZERO,zFail:dt.ZERO,zPass:dt.ZERO},reference:0,mask:Mt.CLASSIFICATION_MASK},stencilMask:Mt.CLASSIFICATION_MASK,depthTest:{enabled:!1},depthMask:!1},Yre=[];function Mke(e){let t=e._command,n=Yre;if(e._useDebugWireframe){t.pass=Ze.OPAQUE,n.length=0,n.push(t),e._commandListDebugWireframe=xI(e,n,e._commandListDebugWireframe);let r=e._commandListDebugWireframe,s=r.length;for(let a=0;a<s;a++){let c=r[a];c.count*=2,c.offset*=2}return}let o=e.model.allowPicking;if(e._classifiesTerrain){let r=Ze.TERRAIN_CLASSIFICATION,s=Nz(t,r),a=Dre(t,r);n.length=0,n.push(s,a),e._commandListTerrain=xI(e,n,e._commandListTerrain),o&&(e._commandListTerrainPicking=Bre(e,n,e._commandListTerrainPicking))}if(e._classifies3DTiles){let r=Ze.CESIUM_3D_TILE_CLASSIFICATION,s=Nz(t,r),a=Dre(t,r);n.length=0,n.push(s,a),e._commandList3DTiles=xI(e,n,e._commandList3DTiles),o&&(e._commandList3DTilesPicking=Bre(e,n,e._commandList3DTilesPicking))}}function xI(e,t,n){let i=e._runtimePrimitive,o=i.batchLengths,r=i.batchOffsets,s=o.length,a=t.length;for(let c=0;c<s;c++){let d=o[c],u=r[c];for(let m=0;m<a;m++){let p=t[m],b=je.shallowClone(p);b.count=d,b.offset=u,n.push(b)}}return n}function Nz(e,t){let n=je.shallowClone(e);n.cull=!1,n.pass=t;let i=t===Ze.TERRAIN_CLASSIFICATION?vn.ALWAYS:vn.EQUAL,o=wke(i);return n.renderState=Ne.fromCache(o),n}function Dre(e,t){let n=je.shallowClone(e);return n.cull=!1,n.pass=t,n.renderState=Ne.fromCache(Fke),n}var Nke=[];function Bre(e,t,n){let i=Ne.fromCache(Ake),o=t[0],r=t[1],s=je.shallowClone(o);s.cull=!0,s.pickOnly=!0;let a=je.shallowClone(r);a.cull=!0,a.pickOnly=!0,a.renderState=i,a.pickId=e._pickId;let c=Nke;return c.length=0,c.push(s,a),xI(e,c,n)}Object.defineProperties(kz.prototype,{command:{get:function(){return this._command}},runtimePrimitive:{get:function(){return this._runtimePrimitive}},batchLengths:{get:function(){return this._runtimePrimitive.batchLengths}},batchOffsets:{get:function(){return this._runtimePrimitive.batchOffsets}},model:{get:function(){return this._model}},classificationType:{get:function(){return this._classificationType}},modelMatrix:{get:function(){return this._modelMatrix},set:function(e){this._modelMatrix=M.clone(e,this._modelMatrix);let t=this._runtimePrimitive.boundingSphere;this._boundingVolume=ce.transform(t,this._modelMatrix,this._boundingVolume)}},boundingVolume:{get:function(){return this._boundingVolume}},cullFace:{get:function(){return this._cullFace},set:function(e){this._cullFace=e}}});kz.prototype.pushCommands=function(e,t){let n=e.passes;if(n.render){if(this._useDebugWireframe){t.push.apply(t,this._commandListDebugWireframe);return}if(this._classifiesTerrain&&t.push.apply(t,this._commandListTerrain),this._classifies3DTiles&&t.push.apply(t,this._commandList3DTiles),e.invertClassification&&this._classifies3DTiles){if(this._commandListIgnoreShow.length===0){let o=Ze.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW,r=Nz(this._command,o),s=Yre;s.length=0,s.push(r),this._commandListIgnoreShow=xI(this,s,this._commandListIgnoreShow)}t.push.apply(t,this._commandListIgnoreShow)}}return n.pick&&(this._classifiesTerrain&&t.push.apply(t,this._commandListTerrainPicking),this._classifies3DTiles&&t.push.apply(t,this._commandList3DTilesPicking)),t};var _I=kz;var Ixn=T(S(),1);function uN(e){e=g(e,g.EMPTY_OBJECT);let t=e.command,n=e.primitiveRenderResources,i=n.model;this._model=i;let o=n.runtimePrimitive;this._runtimePrimitive=o;let r=t.pass===Ze.TRANSLUCENT,a=!o.primitive.material.doubleSided&&!r,c=n.hasSilhouette,d=!r&&!c,u=n.hasSkipLevelOfDetail&&!r,m=c;this._command=t,this._modelMatrix=M.clone(t.modelMatrix),this._boundingVolume=ce.clone(t.boundingVolume),this._modelMatrix2D=new M,this._boundingVolume2D=new ce,this._modelMatrix2DDirty=!1,this._backFaceCulling=t.renderState.cull.enabled,this._cullFace=t.renderState.cull.face,this._shadows=i.shadows,this._debugShowBoundingVolume=t.debugShowBoundingVolume,this._usesBackFaceCulling=a,this._needsTranslucentCommand=d,this._needsSkipLevelOfDetailCommands=u,this._needsSilhouetteCommands=m,this._originalCommand=void 0,this._translucentCommand=void 0,this._skipLodBackfaceCommand=void 0,this._skipLodStencilCommand=void 0,this._silhouetteModelCommand=void 0,this._silhouetteColorCommand=void 0,this._derivedCommands=[],this._has2DCommands=!1,kke(this)}function t0(e){this.command=e.command,this.updateShadows=e.updateShadows,this.updateBackFaceCulling=e.updateBackFaceCulling,this.updateCullFace=e.updateCullFace,this.updateDebugShowBoundingVolume=e.updateDebugShowBoundingVolume,this.is2D=g(e.is2D,!1),this.derivedCommand2D=void 0}t0.clone=function(e){return new t0({command:e.command,updateShadows:e.updateShadows,updateBackFaceCulling:e.updateBackFaceCulling,updateCullFace:e.updateCullFace,updateDebugShowBoundingVolume:e.updateDebugShowBoundingVolume,is2D:e.is2D,derivedCommand2D:e.derivedCommand2D})};function kke(e){let t=e._command;t.modelMatrix=e._modelMatrix,t.boundingVolume=e._boundingVolume;let n=e._model,i=e._usesBackFaceCulling,o=e._derivedCommands;e._originalCommand=new t0({command:t,updateShadows:!0,updateBackFaceCulling:i,updateCullFace:i,updateDebugShowBoundingVolume:!0,is2D:!1}),o.push(e._originalCommand),e._needsTranslucentCommand&&(e._translucentCommand=new t0({command:Hke(t),updateShadows:!0,updateBackFaceCulling:!1,updateCullFace:!1,updateDebugShowBoundingVolume:!0}),o.push(e._translucentCommand)),e._needsSkipLevelOfDetailCommands&&(e._skipLodBackfaceCommand=new t0({command:$ke(t),updateShadows:!1,updateBackFaceCulling:!1,updateCullFace:i,updateDebugShowBoundingVolume:!1}),e._skipLodStencilCommand=new t0({command:eUe(t,n),updateShadows:!0,updateBackFaceCulling:i,updateCullFace:i,updateDebugShowBoundingVolume:!0}),o.push(e._skipLodBackfaceCommand),o.push(e._skipLodStencilCommand)),e._needsSilhouetteCommands&&(e._silhouetteModelCommand=new t0({command:Kke(t,n),updateShadows:!0,updateBackFaceCulling:i,updateCullFace:i,updateDebugShowBoundingVolume:!0}),e._silhouetteColorCommand=new t0({command:Jke(t,n),updateShadows:!1,updateBackFaceCulling:!1,updateCullFace:!1,updateDebugShowBoundingVolume:!1}),o.push(e._silhouetteModelCommand),o.push(e._silhouetteColorCommand))}Object.defineProperties(uN.prototype,{command:{get:function(){return this._command}},runtimePrimitive:{get:function(){return this._runtimePrimitive}},model:{get:function(){return this._model}},primitiveType:{get:function(){return this._command.primitiveType}},modelMatrix:{get:function(){return this._modelMatrix},set:function(e){this._modelMatrix=M.clone(e,this._modelMatrix),this._modelMatrix2DDirty=!0,this._boundingVolume=ce.transform(this.runtimePrimitive.boundingSphere,this._modelMatrix,this._boundingVolume)}},boundingVolume:{get:function(){return this._boundingVolume}},shadows:{get:function(){return this._shadows},set:function(e){this._shadows=e,Dke(this)}},backFaceCulling:{get:function(){return this._backFaceCulling},set:function(e){this._backFaceCulling!==e&&(this._backFaceCulling=e,Bke(this))}},cullFace:{get:function(){return this._cullFace},set:function(e){this._cullFace!==e&&(this._cullFace=e,Yke(this))}},debugShowBoundingVolume:{get:function(){return this._debugShowBoundingVolume},set:function(e){this._debugShowBoundingVolume!==e&&(this._debugShowBoundingVolume=e,Oke(this))}}});function Uke(e,t){let n=e._modelMatrix;e._modelMatrix2D=M.clone(n,e._modelMatrix2D),e._modelMatrix2D[13]-=P.sign(n[13])*2*P.PI*t.mapProjection.ellipsoid.maximumRadius,e._boundingVolume2D=ce.transform(e.runtimePrimitive.boundingSphere,e._modelMatrix2D,e._boundingVolume2D)}function Dke(e){let t=e.shadows,n=_n.castShadows(t),i=_n.receiveShadows(t),o=e._derivedCommands;for(let r=0;r<o.length;++r){let s=o[r];if(s.updateShadows){let a=s.command;a.castShadows=n,a.receiveShadows=i}}}function Bke(e){let t=e.backFaceCulling,n=e._derivedCommands;for(let i=0;i<n.length;++i){let o=n[i];if(o.updateBackFaceCulling){let r=o.command,s=Oe(r.renderState,!0);s.cull.enabled=t,r.renderState=Ne.fromCache(s)}}}function Yke(e){let t=e.cullFace,n=e._derivedCommands;for(let i=0;i<n.length;++i){let o=n[i];if(o.updateCullFace){let r=o.command,s=Oe(r.renderState,!0);s.cull.face=t,r.renderState=Ne.fromCache(s)}}}function Oke(e){let t=e.debugShowBoundingVolume,n=e._derivedCommands;for(let i=0;i<n.length;++i){let o=n[i];if(o.updateDebugShowBoundingVolume){let r=o.command;r.debugShowBoundingVolume=t}}}uN.prototype.pushCommands=function(e,t){let n=Ore(this,e);n&&!this._has2DCommands&&(zke(this),this._has2DCommands=!0,this._modelMatrix2DDirty=!0),this._modelMatrix2DDirty&&(Uke(this,e),this._modelMatrix2DDirty=!1);let i=this.model.styleCommandsNeeded;if(!(this._needsTranslucentCommand&&l(i)&&(i!==Bm.ALL_OPAQUE&&wC(t,this._translucentCommand,n),i===Bm.ALL_TRANSLUCENT))){if(this._needsSkipLevelOfDetailCommands){let{tileset:o,tile:r}=this._model.content;if(o.hasMixedContent){r._finalResolution||wC(o._backfaceCommands,this._skipLodBackfaceCommand,n),Qke(this,r,n),wC(t,this._skipLodStencilCommand,n);return}}if(this._needsSilhouetteCommands){wC(t,this._silhouetteModelCommand,n);return}return wC(t,this._originalCommand,n),t}};uN.prototype.pushSilhouetteCommands=function(e,t){let n=Ore(this,e);return wC(t,this._silhouetteColorCommand,n),t};function wC(e,t,n){e.push(t.command),n&&e.push(t.derivedCommand2D.command)}function Ore(e,t){if(t.mode!==ie.SCENE2D||e.model._projectTo2D)return!1;let i=e.model.sceneGraph._boundingSphere2D,o=i.center.y-i.radius,r=i.center.y+i.radius,s=t.mapProjection.ellipsoid.maximumRadius*P.PI;return o<s&&r>s||o<-s&&r>-s}function vC(e,t){if(!l(t))return;let n=t0.clone(t),i=je.shallowClone(t.command);return i.modelMatrix=e._modelMatrix2D,i.boundingVolume=e._boundingVolume2D,n.command=i,n.updateShadows=!1,n.is2D=!0,t.derivedCommand2D=n,e._derivedCommands.push(n),n}function zke(e){vC(e,e._originalCommand),vC(e,e._translucentCommand),vC(e,e._skipLodBackfaceCommand),vC(e,e._skipLodStencilCommand),vC(e,e._silhouetteModelCommand),vC(e,e._silhouetteColorCommand)}function Hke(e){let t=je.shallowClone(e);t.pass=Ze.TRANSLUCENT;let n=Oe(e.renderState,!0);return n.cull.enabled=!1,n.depthMask=!1,n.blending=un.ALPHA_BLEND,t.renderState=Ne.fromCache(n),t}function Kke(e,t){let n=t._silhouetteId%255,i=je.shallowClone(e),o=Oe(e.renderState,!0);return o.stencilTest={enabled:!0,frontFunction:ne.ALWAYS,backFunction:ne.ALWAYS,reference:n,mask:-1,frontOperation:{fail:ne.KEEP,zFail:ne.KEEP,zPass:ne.REPLACE},backOperation:{fail:ne.KEEP,zFail:ne.KEEP,zPass:ne.REPLACE}},t.isInvisible()&&(o.colorMask={red:!1,green:!1,blue:!1,alpha:!1}),i.renderState=Ne.fromCache(o),i}function Jke(e,t){let n=t._silhouetteId%255,i=je.shallowClone(e),o=Oe(e.renderState,!0);o.cull.enabled=!1,(e.pass===Ze.TRANSLUCENT||t.silhouetteColor.alpha<1)&&(i.pass=Ze.TRANSLUCENT,o.depthMask=!1,o.blending=un.ALPHA_BLEND),o.stencilTest={enabled:!0,frontFunction:ne.NOTEQUAL,backFunction:ne.NOTEQUAL,reference:n,mask:-1,frontOperation:{fail:ne.KEEP,zFail:ne.KEEP,zPass:ne.KEEP},backOperation:{fail:ne.KEEP,zFail:ne.KEEP,zPass:ne.KEEP}};let s=Oe(e.uniformMap);return s.model_silhouettePass=function(){return!0},i.renderState=Ne.fromCache(o),i.uniformMap=s,i.castShadows=!1,i.receiveShadows=!1,i}function Qke(e,t,n){let i=e._skipLodStencilCommand,o=i.command,r=t._selectionDepth,s=jke(o);if(r!==s){let a=qke(r),c=Oe(o.renderState,!0);c.stencilTest.reference=a,o.renderState=Ne.fromCache(c),n&&(i.derivedCommand2D.renderState=c)}}function jke(e){return(e.renderState.stencilTest.reference&Mt.SKIP_LOD_MASK)>>>Mt.SKIP_LOD_BIT_SHIFT}function qke(e){return Mt.CESIUM_3D_TILE_MASK|e<<Mt.SKIP_LOD_BIT_SHIFT}function $ke(e){let t=je.shallowClone(e),n=Oe(e.renderState,!0);n.cull.enabled=!0,n.cull.face=mi.FRONT,n.colorMask={red:!1,green:!1,blue:!1,alpha:!1},n.polygonOffset={enabled:!0,factor:5,units:5};let i=Oe(t.uniformMap),o=new D(5,5);return i.u_polygonOffset=function(){return o},t.renderState=Ne.fromCache(n),t.uniformMap=i,t.castShadows=!1,t.receiveShadows=!1,t}function eUe(e){let t=je.shallowClone(e),n=Oe(e.renderState,!0),{stencilTest:i}=n;return i.enabled=!0,i.mask=Mt.SKIP_LOD_MASK,i.reference=Mt.CESIUM_3D_TILE_MASK,i.frontFunction=vn.GREATER_OR_EQUAL,i.frontOperation.zPass=dt.REPLACE,i.backFunction=vn.GREATER_OR_EQUAL,i.backOperation.zPass=dt.REPLACE,n.stencilMask=Mt.CESIUM_3D_TILE_MASK|Mt.SKIP_LOD_MASK,t.renderState=Ne.fromCache(n),t}var TI=uN;function tUe(e,t){let n=e.shaderBuilder;n.addVertexLines(gI),n.addFragmentLines(yI);let i=nUe(e),o=new ti({context:t.context,indexBuffer:i,attributes:e.attributes}),r=e.model;r._pipelineResources.push(o);let s=n.buildShaderProgram(t.context);r._pipelineResources.push(s);let a=e.alphaOptions.pass,c=r.sceneGraph,d=t.mode===ie.SCENE3D,u,m;if(!d&&!t.scene3DOnly&&r._projectTo2D)u=M.multiplyTransformation(c._computedModelMatrix,e.runtimeNode.computedTransform,new M),m=e.runtimePrimitive.boundingSphere2D;else{let V=d?c._computedModelMatrix:c._computedModelMatrix2D;u=M.multiplyTransformation(V,e.runtimeNode.computedTransform,new M),m=ce.transform(e.boundingSphere,u,e.boundingSphere)}let p=Oe(Ne.fromCache(e.renderStateOptions),!0);p.cull.face=qt.getCullFace(u,e.primitiveType),p=Ne.fromCache(p);let b=l(r.classificationType),f=b?!1:_n.castShadows(r.shadows),x=b?!1:_n.receiveShadows(r.shadows),_=b?void 0:e.pickId,C=new je({boundingVolume:m,modelMatrix:u,uniformMap:e.uniformMap,renderState:p,vertexArray:o,shaderProgram:s,cull:r.cull,pass:a,count:e.count,owner:r,pickId:_,instanceCount:e.instanceCount,primitiveType:e.primitiveType,debugShowBoundingVolume:r.debugShowBoundingVolume,castShadows:f,receiveShadows:x});return b?new _I({primitiveRenderResources:e,command:C}):new TI({primitiveRenderResources:e,command:C})}function nUe(e){let t=e.wireframeIndexBuffer;if(l(t))return t;let n=e.indices;if(l(n))return n.buffer}var SI=tUe;var $xn=T(S(),1);var zre={name:\"TilesetPipelineStage\"};zre.process=function(e,t,n){if(t.hasSkipLevelOfDetail(n)){e.shaderBuilder.addDefine(\"POLYGON_OFFSET\",void 0,Ce.FRAGMENT);let r={u_polygonOffset:function(){return D.ZERO}};e.uniformMap=Ct(r,e.uniformMap),e.hasSkipLevelOfDetail=!0}let i=e.renderStateOptions;i.stencilTest=Mt.setCesium3DTileBit(),i.stencilMask=Mt.CESIUM_3D_TILE_MASK};var CI=zre;var d_n=T(S(),1);var t_n=T(S(),1),VI=`// robust iterative solution without trig functions // https://github.com/0xfaded/ellipse_demo/issues/1 // https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse // // This version uses only a single iteration for best performance. For fog // rendering, the difference is negligible. vec2 nearestPointOnEllipseFast(vec2 pos, vec2 radii) { vec2 p = abs(pos); vec2 inverseRadii = 1.0 / radii; vec2 evoluteScale = (radii.x * radii.x - radii.y * radii.y) * vec2(1.0, -1.0) * inverseRadii; // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t)) // but store the cos and sin of t in a vec2 for efficiency. // Initial guess: t = cos(pi/4) vec2 tTrigs = vec2(0.70710678118); vec2 v = radii * tTrigs; // Find the evolute of the ellipse (center of curvature) at v. vec2 evolute = evoluteScale * tTrigs * tTrigs * tTrigs; // Find the (approximate) intersection of p - evolute with the ellipsoid. vec2 q = normalize(p - evolute) * length(v - evolute); // Update the estimate of t. tTrigs = (q + evolute) *"
}