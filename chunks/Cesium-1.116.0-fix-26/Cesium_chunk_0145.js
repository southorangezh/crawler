{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 145,
    "total_chunks": 194,
    "chunk_size": 6197,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.738Z"
  },
  "content": "1.0) : vec4(czm_sunPositionColumbusView.zxy, 1.0); vec4 sunPositionEC = czm_view * sunPos; vec4 sunPositionWC = czm_eyeToWindowCoordinates(sunPositionEC); sunPos = czm_viewportOrthographic * vec4(sunPositionWC.xy, -sunPositionWC.z, 1.0); // If sun is not in the screen space, use original color. if(!isSpace || !((sunPos.x >= -1.1 && sunPos.x <= 1.1) && (sunPos.y >= -1.1 && sunPos.y <= 1.1))) { // Lens flare is disabled when not in space until #5932 is fixed. // https://github.com/CesiumGS/cesium/issues/5932 out_FragColor = originalColor; return; } vec2 texcoord = vec2(1.0) - v_textureCoordinates; vec2 pixelSize = czm_pixelRatio / czm_viewport.zw; vec2 invPixelSize = 1.0 / pixelSize; vec3 distortionVec = pixelSize.x * vec3(-distortion, 0.0, distortion); // ghost vector to image centre: vec2 ghostVec = (vec2(0.5) - texcoord) * ghostDispersal; vec3 direction = normalize(vec3(ghostVec, 0.0)); // sample ghosts: vec4 result = vec4(0.0); vec4 ghost = vec4(0.0); for (int i = 0; i < 4; ++i) { vec2 offset = fract(texcoord + ghostVec * float(i)); // Only bright spots from the centre of the source image ghost += textureDistorted(colorTexture, offset, direction.xy, distortionVec, isSpace); } result += ghost; // sample halo vec2 haloVec = normalize(ghostVec) * haloWidth; float weightForHalo = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5)); weightForHalo = pow(1.0 - weightForHalo, 5.0); result += textureDistorted(colorTexture, texcoord + haloVec, direction.xy, distortionVec, isSpace) * weightForHalo * 1.5; // dirt on lens vec2 dirtTexCoords = (v_textureCoordinates * invPixelSize) / dirtTextureDimensions; if (dirtTexCoords.x > 1.0) { dirtTexCoords.x = mod(floor(dirtTexCoords.x), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.x) : fract(dirtTexCoords.x); } if (dirtTexCoords.y > 1.0) { dirtTexCoords.y = mod(floor(dirtTexCoords.y), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.y) : fract(dirtTexCoords.y); } result += dirtAmount * texture(dirtTexture, dirtTexCoords); // Rotating starburst texture's coordinate // dot(czm_view[0].xyz, vec3(0.0, 0.0, 1.0)) + dot(czm_view[1].xyz, vec3(0.0, 1.0, 0.0)) float camrot = czm_view[0].z + czm_view[1].y; float cosValue = cos(camrot); float sinValue = sin(camrot); mat3 rotation = mat3( cosValue, -sinValue, 0.0, sinValue, cosValue, 0.0, 0.0, 0.0, 1.0 ); vec3 st1 = vec3(v_textureCoordinates * 2.0 - vec2(1.0), 1.0); vec3 st2 = vec3((rotation * st1).xy, 1.0); vec3 st3 = st2 * 0.5 + vec3(0.5); vec2 lensStarTexcoord = st3.xy; float weightForLensFlare = length(vec3(sunPos.xy, 0.0)); float oneMinusWeightForLensFlare = max(1.0 - weightForLensFlare, 0.0); if (!isSpace) { result *= oneMinusWeightForLensFlare * intensity * 0.2; } else { result *= oneMinusWeightForLensFlare * intensity; result *= texture(starTexture, lensStarTexcoord) * pow(weightForLensFlare, 1.0) * max((1.0 - length(vec3(st1.xy, 0.0))), 0.0) * 2.0; } result += texture(colorTexture, v_textureCoordinates); out_FragColor = result; } `;var tvi=T(S(),1),SF=`uniform sampler2D colorTexture; uniform vec3 white; in vec2 v_textureCoordinates; #ifdef AUTO_EXPOSURE uniform sampler2D autoExposure; #endif // See equation 4: // http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf void main() { vec4 fragmentColor = texture(colorTexture, v_textureCoordinates); vec3 color = fragmentColor.rgb; #ifdef AUTO_EXPOSURE float exposure = texture(autoExposure, vec2(0.5)).r; color /= exposure; #endif color = (color * (1.0 + color / white)) / (1.0 + color); color = czm_inverseGamma(color); out_FragColor = vec4(color, fragmentColor.a); } `;var ivi=T(S(),1),CF=`uniform sampler2D colorTexture; in vec2 v_textureCoordinates; float rand(vec2 co) { return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453); } void main(void) { float noiseValue = rand(v_textureCoordinates + sin(czm_frameNumber)) * 0.1; vec3 rgb = texture(colorTexture, v_textureCoordinates).rgb; vec3 green = vec3(0.0, 1.0, 0.0); out_FragColor = vec4((noiseValue + rgb) * green, 1.0); } `;var rvi=T(S(),1),VF=`uniform sampler2D colorTexture; in vec2 v_textureCoordinates; #ifdef AUTO_EXPOSURE uniform sampler2D autoExposure; #endif // See equation 3: // http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf void main() { vec4 fragmentColor = texture(colorTexture, v_textureCoordinates); vec3 color = fragmentColor.rgb; #ifdef AUTO_EXPOSURE float exposure = texture(autoExposure, vec2(0.5)).r; color /= exposure; #endif color = color / (1.0 + color); color = czm_inverseGamma(color); out_FragColor = vec4(color, fragmentColor.a); } `;var avi=T(S(),1),LF=`uniform sampler2D colorTexture; uniform sampler2D silhouetteTexture; in vec2 v_textureCoordinates; void main(void) { vec4 silhouetteColor = texture(silhouetteTexture, v_textureCoordinates); vec4 color = texture(colorTexture, v_textureCoordinates); out_FragColor = mix(color, silhouetteColor, silhouetteColor.a); } `;var lvi=T(S(),1);/** * @license * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above copyright * notice, this list of conditions and the following disclaimer in the * documentation and/or other materials provided with the distribution. * * Neither the name of NVIDIA CORPORATION nor the names of its * contributors may be used to endorse or promote products derived * from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY *"
}