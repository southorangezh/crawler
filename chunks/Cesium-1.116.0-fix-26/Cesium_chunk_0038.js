{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 38,
    "total_chunks": 194,
    "chunk_size": 6255,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.667Z"
  },
  "content": "pow(srgbIn.rgb, vec3(2.2)); return vec4(linearOut, srgbIn.a); } `;var _wt=T(S(),1),yG=`/** * Creates a matrix that transforms vectors from tangent space to eye space. * * @name czm_tangentToEyeSpaceMatrix * @glslFunction * * @param {vec3} normalEC The normal vector in eye coordinates. * @param {vec3} tangentEC The tangent vector in eye coordinates. * @param {vec3} bitangentEC The bitangent vector in eye coordinates. * * @returns {mat3} The matrix that transforms from tangent space to eye space. * * @example * mat3 tangentToEye = czm_tangentToEyeSpaceMatrix(normalEC, tangentEC, bitangentEC); * vec3 normal = tangentToEye * texture(normalMap, st).xyz; */ mat3 czm_tangentToEyeSpaceMatrix(vec3 normalEC, vec3 tangentEC, vec3 bitangentEC) { vec3 normal = normalize(normalEC); vec3 tangent = normalize(tangentEC); vec3 bitangent = normalize(bitangentEC); return mat3(tangent.x , tangent.y , tangent.z, bitangent.x, bitangent.y, bitangent.z, normal.x , normal.y , normal.z); } `;var Swt=T(S(),1),gG=`/** * A wrapper around the texture (WebGL2) / textureCube (WebGL1) * function to allow for WebGL 1 support. * * @name czm_textureCube * @glslFunction * * @param {samplerCube} sampler The sampler. * @param {vec3} p The coordinates to sample the texture at. */ vec4 czm_textureCube(samplerCube sampler, vec3 p) { #if __VERSION__ == 300 return texture(sampler, p); #else return textureCube(sampler, p); #endif }`;var Vwt=T(S(),1),xG=`/** * Transforms a plane. * * @name czm_transformPlane * @glslFunction * * @param {vec4} plane The plane in Hessian Normal Form. * @param {mat4} transform The inverse-transpose of a transformation matrix. */ vec4 czm_transformPlane(vec4 plane, mat4 transform) { vec4 transformedPlane = transform * plane; // Convert the transformed plane to Hessian Normal Form float normalMagnitude = length(transformedPlane.xyz); return transformedPlane / normalMagnitude; } `;var Zwt=T(S(),1),_G=`/** * Translates a position (or any <code>vec3</code>) that was encoded with {@link EncodedCartesian3}, * and then provided to the shader as separate <code>high</code> and <code>low</code> bits to * be relative to the eye. As shown in the example, the position can then be transformed in eye * or clip coordinates using {@link czm_modelViewRelativeToEye} or {@link czm_modelViewProjectionRelativeToEye}, * respectively. * <p> * This technique, called GPU RTE, eliminates jittering artifacts when using large coordinates as * described in {@link http://help.agi.com/AGIComponents/html/BlogPrecisionsPrecisions.htm|Precisions, Precisions}. * </p> * * @name czm_translateRelativeToEye * @glslFunction * * @param {vec3} high The position's high bits. * @param {vec3} low The position's low bits. * @returns {vec3} The position translated to be relative to the camera's position. * * @example * in vec3 positionHigh; * in vec3 positionLow; * * void main() * { * vec4 p = czm_translateRelativeToEye(positionHigh, positionLow); * gl_Position = czm_modelViewProjectionRelativeToEye * p; * } * * @see czm_modelViewRelativeToEye * @see czm_modelViewProjectionRelativeToEye * @see czm_computePosition * @see EncodedCartesian3 */ vec4 czm_translateRelativeToEye(vec3 high, vec3 low) { vec3 highDifference = high - czm_encodedCameraPositionMCHigh; // This check handles the case when NaN values have gotten into \\`highDifference\\`. // Such a thing could happen on devices running iOS. if (length(highDifference) == 0.0) { highDifference = vec3(0); } vec3 lowDifference = low - czm_encodedCameraPositionMCLow; return vec4(highDifference + lowDifference, 1.0); } `;var Gwt=T(S(),1),TG=`/** * @private */ vec4 czm_translucentPhong(vec3 toEye, czm_material material, vec3 lightDirectionEC) { // Diffuse from directional light sources at eye (for top-down and horizon views) float diffuse = czm_getLambertDiffuse(vec3(0.0, 0.0, 1.0), material.normal); if (czm_sceneMode == czm_sceneMode3D) { // (and horizon views in 3D) diffuse += czm_getLambertDiffuse(vec3(0.0, 1.0, 0.0), material.normal); } diffuse = clamp(diffuse, 0.0, 1.0); float specular = czm_getSpecular(lightDirectionEC, toEye, material.normal, material.shininess); // Temporary workaround for adding ambient. vec3 materialDiffuse = material.diffuse * 0.5; vec3 ambient = materialDiffuse; vec3 color = ambient + material.emission; color += materialDiffuse * diffuse * czm_lightColor; color += material.specular * specular * czm_lightColor; return vec4(color, material.alpha); } `;var Xwt=T(S(),1),SG=`/** * Returns the transpose of the matrix. The input <code>matrix</code> can be * a <code>mat2</code>, <code>mat3</code>, or <code>mat4</code>. * * @name czm_transpose * @glslFunction * * @param {} matrix The matrix to transpose. * * @returns {} The transposed matrix. * * @example * // GLSL declarations * mat2 czm_transpose(mat2 matrix); * mat3 czm_transpose(mat3 matrix); * mat4 czm_transpose(mat4 matrix); * * // Transpose a 3x3 rotation matrix to find its inverse. * mat3 eastNorthUpToEye = czm_eastNorthUpToEyeCoordinates( * positionMC, normalEC); * mat3 eyeToEastNorthUp = czm_transpose(eastNorthUpToEye); */ mat2 czm_transpose(mat2 matrix) { return mat2( matrix[0][0], matrix[1][0], matrix[0][1], matrix[1][1]); } mat3 czm_transpose(mat3 matrix) { return mat3( matrix[0][0], matrix[1][0], matrix[2][0], matrix[0][1], matrix[1][1], matrix[2][1], matrix[0][2], matrix[1][2], matrix[2][2]); } mat4 czm_transpose(mat4 matrix) { return mat4( matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0], matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1], matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2], matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]); } `;var Wwt=T(S(),1),CG=`/** * Unpacks a vec4 depth value to a float in [0, 1) range. * * @name czm_unpackDepth * @glslFunction * * @param {vec4} packedDepth The packed depth. * * @returns {float} The floating-point depth in [0, 1) range. */ float czm_unpackDepth(vec4 packedDepth) { // See Aras Pranckevi\\u010Dius' post Encoding Floats to RGBA // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/ return dot(packedDepth, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)); } `;var vwt=T(S(),1),VG=`/** * Unpack an IEEE 754 single-precision float that is packed as a little-endian unsigned normalized"
}