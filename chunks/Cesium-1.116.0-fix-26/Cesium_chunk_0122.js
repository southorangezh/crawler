{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 122,
    "total_chunks": 194,
    "chunk_size": 6977,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.724Z"
  },
  "content": "#ifndef APPLY_TILE_UV_CORRECTION vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates); textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y; alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates); textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y; #endif #if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING) textureAlpha *= mix(textureDayAlpha, textureNightAlpha, nightBlend); #endif vec2 translation = textureCoordinateTranslationAndScale.xy; vec2 scale = textureCoordinateTranslationAndScale.zw; vec2 textureCoordinates = tileTextureCoordinates * scale + translation; #ifdef APPLY_TILE_UV_CORRECTION vec3 textureCoordinatesHomo = vec3(textureCoordinates, 1.0); textureCoordinatesHomo = correction * textureCoordinatesHomo; textureCoordinates = textureCoordinatesHomo.xy / textureCoordinatesHomo.z; #endif vec4 value = texture(textureToSample, textureCoordinates); vec3 color = value.rgb; float alpha = value.a; #ifdef APPLY_TILE_UV_CORRECTION if (textureCoordinates.x > 1.0 || textureCoordinates.x < 0.0 || textureCoordinates.y > 1.0 || textureCoordinates.y < 0.0) { alpha = 0.0; } #endif #ifdef APPLY_COLOR_TO_ALPHA vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb); colorDiff.r = max(max(colorDiff.r, colorDiff.g), colorDiff.b); alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha); #endif #if !defined(APPLY_GAMMA) vec4 tempColor = czm_gammaCorrect(vec4(color, alpha)); color = tempColor.rgb; alpha = tempColor.a; #else color = pow(color, vec3(textureOneOverGamma)); #endif #ifdef APPLY_SPLIT float splitPosition = czm_splitPosition; float splitMode = czm_splitMode; if (splitMode > 0.0) { // Split to the left if (split < 0.0 && gl_FragCoord.x > splitPosition) { alpha = 0.0; } // Split to the right else if (split > 0.0 && gl_FragCoord.x < splitPosition) { alpha = 0.0; } } else if (splitMode < 0.0) { // Split to the up if (split < 0.0 && gl_FragCoord.y < splitPosition) { alpha = 0.0; } // Split to the bottom else if (split > 0.0 && gl_FragCoord.y > splitPosition) { alpha = 0.0; } } #endif #ifdef APPLY_BRIGHTNESS color = mix(vec3(0.0), color, textureBrightness); #endif #ifdef APPLY_CONTRAST color = mix(vec3(0.5), color, textureContrast); #endif #ifdef APPLY_HUE color = czm_hue(color, textureHue); #endif #ifdef APPLY_SATURATION color = czm_saturation(color, textureSaturation); #endif float sourceAlpha = alpha * textureAlpha; float outAlpha = mix(previousColor.a, 1.0, sourceAlpha); outAlpha += sign(outAlpha) - 1.0; vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha; // When rendering imagery for a tile in multiple passes, // some GPU/WebGL implementation combinations will not blend fragments in // additional passes correctly if their computation includes an unmasked // divide-by-zero operation, // even if it's not in the output or if the output has alpha zero. // // For example, without sanitization for outAlpha, // this renders without artifacts: // if (outAlpha == 0.0) { outColor = vec3(0.0); } // // but using czm_branchFreeTernary will cause portions of the tile that are // alpha-zero in the additional pass to render as black instead of blending // with the previous pass: // outColor = czm_branchFreeTernary(outAlpha == 0.0, vec3(0.0), outColor); // // So instead, sanitize against divide-by-zero, // store this state on the sign of outAlpha, and correct on return. return vec4(outColor, max(outAlpha, 0.0)); } vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend); vec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue, float fade); const float fExposure = 2.0; vec3 computeEllipsoidPosition() { float mpp = czm_metersPerPixel(vec4(0.0, 0.0, -czm_currentFrustum.x, 1.0), 1.0); vec2 xy = gl_FragCoord.xy / czm_viewport.zw * 2.0 - vec2(1.0); xy *= czm_viewport.zw * mpp * 0.5; vec3 direction = normalize(vec3(xy, -czm_currentFrustum.x)); czm_ray ray = czm_ray(vec3(0.0), direction); vec3 ellipsoid_center = czm_view[3].xyz; czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii); vec3 ellipsoidPosition = czm_pointAlongRay(ray, intersection.start); return (czm_inverseView * vec4(ellipsoidPosition, 1.0)).xyz; } void main() { #ifdef TILE_LIMIT_RECTANGLE if (v_textureCoordinates.x < u_cartographicLimitRectangle.x || u_cartographicLimitRectangle.z < v_textureCoordinates.x || v_textureCoordinates.y < u_cartographicLimitRectangle.y || u_cartographicLimitRectangle.w < v_textureCoordinates.y) { discard; } #endif #ifdef ENABLE_CLIPPING_PLANES float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix); #endif #if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(HDR) vec3 normalMC = czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)); // normalized surface normal in model coordinates vec3 normalEC = czm_normal3D * normalMC; // normalized surface normal in eye coordinates #endif #if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING) float nightBlend = 1.0 - clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0, 0.0, 1.0); #else float nightBlend = 0.0; #endif // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0 // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the // fragments on the edges of tiles even though the vertex shader is outputting // coordinates strictly in the 0-1 range. vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0), nightBlend); #ifdef SHOW_TILE_BOUNDARIES if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) || v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0)) { color = vec4(1.0, 0.0, 0.0, 1.0); } #endif #if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE) float cameraDist; if (czm_sceneMode == czm_sceneMode2D) { cameraDist = max(czm_frustumPlanes.x - czm_frustumPlanes.y, czm_frustumPlanes.w - czm_frustumPlanes.z) * 0.5; } else if (czm_sceneMode == czm_sceneModeColumbusView) { cameraDist = -czm_view[3].z; } else { cameraDist = length(czm_view[3]); } float fadeOutDist = u_lightingFadeDistance.x; float fadeInDist = u_lightingFadeDistance.y; if (czm_sceneMode != czm_sceneMode3D) { vec3 radii = czm_ellipsoidRadii; float maxRadii = max(radii.x, max(radii.y, radii.z)); fadeOutDist -= maxRadii; fadeInDist -= maxRadii; } float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0); #else float fade = 0.0; #endif #ifdef SHOW_REFLECTIVE_OCEAN vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy; vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw; vec2 waterMaskTextureCoordinates = v_textureCoordinates.xy * waterMaskScale + waterMaskTranslation; waterMaskTextureCoordinates.y"
}