{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 162,
    "total_chunks": 194,
    "chunk_size": 5679,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.747Z"
  },
  "content": "return vec2(NO_HIT); } else if (a == 0.0) { // Ray is parallel to cone surface return (b == 0.0) ? vec2(NO_HIT) // Ray is on cone surface : vec2(-0.5 * c / b, NO_HIT); } determinant = sqrt(determinant); // Compute larger root using standard formula float signB = b < 0.0 ? -1.0 : 1.0; float t1 = (-b - signB * determinant) / a; // The other root may suffer from subtractive cancellation in the standard formula. // Compute it from the first root instead. float t2 = c / (a * t1); float tmin = min(t1, t2); float tmax = max(t1, t2); return vec2(tmin, tmax); } /** * Given a point on a conical surface, find the surface normal at that point. */ vec3 getConeNormal(in vec3 p, in bool convex) { // Start with radial component pointing toward z-axis vec2 radial = -abs(p.z) * normalize(p.xy); // Z component points toward opening of cone float zSign = (p.z < 0.0) ? -1.0 : 1.0; float z = length(p.xy) * zSign; // Flip normal if shape is convex float flip = (convex) ? -1.0 : 1.0; return normalize(vec3(radial, z) * flip); } /** * Compute the shift between the ellipsoid origin and the apex of a cone of latitude */ float getLatitudeConeShift(in float sinLatitude) { // Find prime vertical radius of curvature: // the distance along the ellipsoid normal to the intersection with the z-axis float x2 = u_eccentricitySquared * sinLatitude * sinLatitude; float primeVerticalRadius = inversesqrt(1.0 - x2); // Compute a shift from the origin to the intersection of the cone with the z-axis return primeVerticalRadius * u_eccentricitySquared * sinLatitude; } void intersectFlippedCone(in Ray ray, in float cosHalfAngle, out RayShapeIntersection intersections[2]) { // Undo the scaling from ellipsoid to sphere ray.pos = ray.pos * u_ellipsoidRadiiUv; ray.dir = ray.dir * u_ellipsoidRadiiUv; // Shift the ray to account for the latitude cone not being centered at the Earth center ray.pos.z += getLatitudeConeShift(cosHalfAngle); float cosSqrHalfAngle = cosHalfAngle * cosHalfAngle; vec2 intersect = intersectDoubleEndedCone(ray, cosSqrHalfAngle); vec4 miss = vec4(normalize(ray.dir), NO_HIT); vec4 farSide = vec4(normalize(ray.dir), INF_HIT); // Initialize output with no intersections intersections[0].entry = -1.0 * farSide; intersections[0].exit = farSide; intersections[1].entry = miss; intersections[1].exit = miss; if (intersect.x == NO_HIT) { return; } // Find the points of intersection float tmin = intersect.x; float tmax = intersect.y; vec3 p0 = ray.pos + tmin * ray.dir; vec3 p1 = ray.pos + tmax * ray.dir; vec4 intersect0 = vec4(getConeNormal(p0, true), tmin); vec4 intersect1 = vec4(getConeNormal(p1, true), tmax); bool p0InShadowCone = sign(p0.z) != sign(cosHalfAngle); bool p1InShadowCone = sign(p1.z) != sign(cosHalfAngle); if (p0InShadowCone && p1InShadowCone) { // no valid intersections } else if (p0InShadowCone) { intersections[0].exit = intersect1; } else if (p1InShadowCone) { intersections[0].entry = intersect0; } else { intersections[0].exit = intersect0; intersections[1].entry = intersect1; intersections[1].exit = farSide; } } RayShapeIntersection intersectRegularCone(in Ray ray, in float cosHalfAngle, in bool convex) { // Undo the scaling from ellipsoid to sphere ray.pos = ray.pos * u_ellipsoidRadiiUv; ray.dir = ray.dir * u_ellipsoidRadiiUv; // Shift the ray to account for the latitude cone not being centered at the Earth center ray.pos.z += getLatitudeConeShift(cosHalfAngle); float cosSqrHalfAngle = cosHalfAngle * cosHalfAngle; vec2 intersect = intersectDoubleEndedCone(ray, cosSqrHalfAngle); vec4 miss = vec4(normalize(ray.dir), NO_HIT); vec4 farSide = vec4(normalize(ray.dir), INF_HIT); if (intersect.x == NO_HIT) { return RayShapeIntersection(miss, miss); } // Find the points of intersection float tmin = intersect.x; float tmax = intersect.y; vec3 p0 = ray.pos + tmin * ray.dir; vec3 p1 = ray.pos + tmax * ray.dir; vec4 intersect0 = vec4(getConeNormal(p0, convex), tmin); vec4 intersect1 = vec4(getConeNormal(p1, convex), tmax); bool p0InShadowCone = sign(p0.z) != sign(cosHalfAngle); bool p1InShadowCone = sign(p1.z) != sign(cosHalfAngle); if (p0InShadowCone && p1InShadowCone) { return RayShapeIntersection(miss, miss); } else if (p0InShadowCone) { return RayShapeIntersection(intersect1, farSide); } else if (p1InShadowCone) { return RayShapeIntersection(-1.0 * farSide, intersect0); } else { return RayShapeIntersection(intersect0, intersect1); } } void intersectShape(in Ray ray, inout Intersections ix) { // Position is converted from [0,1] to [-1,+1] because shape intersections assume unit space is [-1,+1]. // Direction is scaled as well to be in sync with position. ray.pos = ray.pos * 2.0 - 1.0; ray.dir *= 2.0; // Outer ellipsoid RayShapeIntersection outerIntersect = intersectHeight(ray, u_clipMinMaxHeight.y, true); setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX, outerIntersect); // Exit early if the outer ellipsoid was missed. if (outerIntersect.entry.w == NO_HIT) { return; } // Inner ellipsoid RayShapeIntersection innerIntersect = intersectHeight(ray, u_clipMinMaxHeight.x, false); if (innerIntersect.entry.w == NO_HIT) { setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN, innerIntersect); } else { // When the ellipsoid is large and thin it's possible for floating point math // to cause the ray to intersect the inner ellipsoid before the outer ellipsoid. // To prevent this from happening, clamp innerIntersect to outerIntersect and // sandwich the inner ellipsoid intersection inside the outer ellipsoid intersection. // Without this special case, // [outerMin, outerMax, innerMin, innerMax] will bubble sort to // [outerMin, innerMin, outerMax, innerMax] which will cause the back // side"
}