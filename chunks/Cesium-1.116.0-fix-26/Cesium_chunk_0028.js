{
  "metadata": {
    "source_file": "Cesium-1.116.0-fix-26\\Cesium.js",
    "chunk_index": 28,
    "total_chunks": 194,
    "chunk_size": 6027,
    "word_count": 800,
    "model_kwargs": {
      "model": "text-embedding-3-large",
      "dimensions": 3072,
      "encoding_format": "float"
    },
    "text_splitter": {
      "split_by": "word",
      "chunk_size": 800,
      "chunk_overlap": 200
    },
    "created_at": "2025-12-17T23:57:49.662Z"
  },
  "content": "@glslFunction * * @param {float} distanceToCamera The distance to the camera in meters. * @param {vec3} color The original color. * @param {vec3} fogColor The color of the fog. * * @returns {vec3} The color adjusted for fog at the distance from the camera. */ vec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) { float scalar = distanceToCamera * czm_fogDensity; float fog = 1.0 - exp(-(scalar * scalar)); return mix(color, fogColor, fog); } /** * Gets the color with fog at a distance from the camera. * * @name czm_fog * @glslFunction * * @param {float} distanceToCamera The distance to the camera in meters. * @param {vec3} color The original color. * @param {vec3} fogColor The color of the fog. * @param {float} fogModifierConstant A constant to modify the appearance of fog. * * @returns {vec3} The color adjusted for fog at the distance from the camera. */ vec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) { float scalar = distanceToCamera * czm_fogDensity; float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant)))); return mix(color, fogColor, fog); } `;var KPt=T(S(),1),IR=`/** * Converts a color from RGB space to linear space. * * @name czm_gammaCorrect * @glslFunction * * @param {vec3} color The color in RGB space. * @returns {vec3} The color in linear space. */ vec3 czm_gammaCorrect(vec3 color) { #ifdef HDR color = pow(color, vec3(czm_gamma)); #endif return color; } vec4 czm_gammaCorrect(vec4 color) { #ifdef HDR color.rgb = pow(color.rgb, vec3(czm_gamma)); #endif return color; } `;var QPt=T(S(),1),WR=`/** * DOC_TBA * * @name czm_geodeticSurfaceNormal * @glslFunction * * @param {vec3} positionOnEllipsoid DOC_TBA * @param {vec3} ellipsoidCenter DOC_TBA * @param {vec3} oneOverEllipsoidRadiiSquared DOC_TBA * * @returns {vec3} DOC_TBA. */ vec3 czm_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared) { return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared); } `;var qPt=T(S(),1),PR=`/** * An czm_material with default values. Every material's czm_getMaterial * should use this default material as a base for the material it returns. * The default normal value is given by materialInput.normalEC. * * @name czm_getDefaultMaterial * @glslFunction * * @param {czm_materialInput} input The input used to construct the default material. * * @returns {czm_material} The default material. * * @see czm_materialInput * @see czm_material * @see czm_getMaterial */ czm_material czm_getDefaultMaterial(czm_materialInput materialInput) { czm_material material; material.diffuse = vec3(0.0); material.specular = 0.0; material.shininess = 1.0; material.normal = materialInput.normalEC; material.emission = vec3(0.0); material.alpha = 1.0; return material; } `;var evt=T(S(),1),vR=`/** * Select which direction vector to use for dynamic atmosphere lighting based on an enum value * * @name czm_getDynamicAtmosphereLightDirection * @glslfunction * @see DynamicAtmosphereLightingType.js * * @param {vec3} positionWC the position of the vertex/fragment in world coordinates. This is normalized and returned when dynamic lighting is turned off. * @param {float} lightEnum The enum value for selecting between light sources. * @return {vec3} The normalized light direction vector. Depending on the enum value, it is either positionWC, czm_lightDirectionWC or czm_sunDirectionWC */ vec3 czm_getDynamicAtmosphereLightDirection(vec3 positionWC, float lightEnum) { const float NONE = 0.0; const float SCENE_LIGHT = 1.0; const float SUNLIGHT = 2.0; vec3 lightDirection = positionWC * float(lightEnum == NONE) + czm_lightDirectionWC * float(lightEnum == SCENE_LIGHT) + czm_sunDirectionWC * float(lightEnum == SUNLIGHT); return normalize(lightDirection); } `;var nvt=T(S(),1),wR=`/** * Calculates the intensity of diffusely reflected light. * * @name czm_getLambertDiffuse * @glslFunction * * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates. * @param {vec3} normalEC The surface normal in eye coordinates. * * @returns {float} The intensity of the diffuse reflection. * * @see czm_phong * * @example * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC); * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200); * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity); */ float czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC) { return max(dot(lightDirectionEC, normalEC), 0.0); } `;var ovt=T(S(),1),FR=`/** * Calculates the specular intensity of reflected light. * * @name czm_getSpecular * @glslFunction * * @param {vec3} lightDirectionEC Unit vector pointing to the light source in eye coordinates. * @param {vec3} toEyeEC Unit vector pointing to the eye position in eye coordinates. * @param {vec3} normalEC The surface normal in eye coordinates. * @param {float} shininess The sharpness of the specular reflection. Higher values create a smaller, more focused specular highlight. * * @returns {float} The intensity of the specular highlight. * * @see czm_phong * * @example * float diffuseIntensity = czm_getLambertDiffuse(lightDirectionEC, normalEC); * float specularIntensity = czm_getSpecular(lightDirectionEC, toEyeEC, normalEC, 200); * vec3 color = (diffuseColor * diffuseIntensity) + (specularColor * specularIntensity); */ float czm_getSpecular(vec3 lightDirectionEC, vec3 toEyeEC, vec3 normalEC, float shininess) { vec3 toReflectedLight = reflect(-lightDirectionEC, normalEC); float specular = max(dot(toReflectedLight, toEyeEC), 0.0); // pow has undefined behavior if both parameters <= 0. // Prevent this by making sure shininess is at least czm_epsilon2. return pow(specular, max(shininess, czm_epsilon2)); } `;var svt=T(S(),1),AR=`/** * @private */ vec4 czm_getWaterNoise(sampler2D normalMap, vec2 uv, float time, float angleInRadians) { float cosAngle = cos(angleInRadians);"
}